Introduction to Go
01 January 2021

Julien Cretel
jcretel-infosec+golang-human-coders@protonmail.com
@jub0bs

* Go's mascot

\... is a gopher ([[https://blog.golang.org/gopher][more about this choice on Golang's blog]])

.image https://blog.golang.org/gopher/gopher.png 400 _



* Concurrency

- Go has native support for concurrency.
- arguably Go's most fascinating aspect
- very relevant in this era of multicores

Disclaimer: cooking metaphors galore ahead!



* Concurrency is not parallelism

*Concurrency*

- the art of composing a programme in terms of independenly executing computations
- a quality of the programme's structure (happens at _writing_ time)

*Parallelism*

- the act of executing code on multiple cores 
- a quality of the programme's execution (happens at _run_ time)

Concurrency _enables_ parallelism.

[[https://www.youtube.com/watch?v=oV9rvDllKEg][see Rob Pike's talk on the topic]]



* Go's concurrency model

Largely inspired by [[https://dl.acm.org/doi/10.1145/359576.359585][Tony Hoare's  _Communicating_Sequential_Processes_ (1978)]]

Two fundamental mechanisms

- goroutines
- channels



* Goroutines

A goroutine

- is a concurrent function execution
- can be thought of as a very lightweight thread
- has no ID, unlike a Unix process ([[https://talks.golang.org/2014/go4gophers.slide#38][rationale]])

The `main` function is itself a goroutine that is created when the programme starts.

It's common for programmes to have hundreds, or even thousands of goroutines.



* The Go scheduler

It's the part of Go's runtime responsible for "juggling" goroutines in order to maximise work.

No need to understand how the Go scheduler works, at this stage of your Go learning.

Just think of the Go Scheduler and goroutines as a chef and his/her kitchen assistants.



* The go keyword

- spawns a new goroutine
- causes the following function call to get executed "in the background"

  go grindCoffeeBeans()
  go frothMilk()

- similar to the ampersand operator in Unix shells

  #!/usr/bin/env sh

  grindCoffeeBeans &
  frothMilk &

- `go` statements return _immediately_!

: terminology: spawning goroutine vs. spawned goroutine



* The golden rule

Before launching a goroutine, you must understand exactly under what conditions it will terminate.

In other words, do not spawn goroutines willy-nilly!

Otherwise, you would expose yourself to bugs and _goroutine_leaks_.



* Exercise: concurrent coffee making

Write two functions, `grindBeans` and `frothMilk`, that

- take no parameters and return no results,
- simply write an informative message to stdout.

Call them concurrently in the `main` function.

: Q: Which message will be printed first? We can't tell. Up to the scheduler.



* Exercise: concurrent coffee making (first attempt)

.play goroutines_without_waitgroup.go /^//START/,/^//END/

Does the programme behave as you expected? Why or why not?



* main does not wait!

Nothing gets written to stdout because

- `go` statements _immediately_ transfer control back to `main`, and
- `main` terminates _before_ your two goroutines themselves terminate!

We need a way to tell `main` to "wait" until the two goroutines terminate.

Any ideas?



* Exercise: concurrent coffee making (with sleep)

Sleep a bit at the end?

.play goroutines_with_sleep.go /^//START/,/^//END/

Kinda works, but not entirely satisfactory... Why?



* Sleeping is not the answer

How long should the sleep be, exactly? Impossible to know in advance.

- Wait too little: `main` terminates too quickly for all the other goroutines to terminate.
- Wait too long: `main` ends up needlessly spinning and wasting time.

Sleeping is simply not a reliable way of coordinating goroutines!

We need another mechanism...



* Wait groups

The [[https://golang.org/pkg/sync/#WaitGroup][standard library]] provides a mechanism for _orchestrating_ goroutines: wait groups.

Wait groups are particularly useful when the number of goroutines to spawn is not known in advance.

: e.g. if you're spawning a goroutine for each line of a file that you're reading



* Declaring a wait group

The zero value is readily usable:

  wg := sync.WaitGroup{} // unnecessary

  var wg sync.WaitGroup  // better



* Operations on a wait group

A wait group is little more than a glorified counter with _concurrency-safe_ operations.

- `wg.Add(n)` increments the counter by n (positive).
- `wg.Done()` decrements the counter by 1 (equivalent to `wg.Add(-1)`).
- `wg.Wait()` blocks until the counter goes back to 0.



* How to use a wait group

Typically, you would call

- `wg.Add(1)` _just_before_ spawning a goroutine;
- `wg.Done()` at the very end of each spawned goroutine;
- `wg.Wait()` in the spawning goroutine to wait for all spawned goroutines to terminate.

Note that

- Calls to `wg.Add` must take place in the spawning goroutine, _not_ within the spawned goroutine!
- The call to `wg.Wait` must happen _after_ all calls to `wg.Add`!
- Calls to `wg.Done` can be _deferred_ at the very top of the spawned goroutines.



* Exercise: concurrent coffee making (using a wait group)

Use a wait group to make sure both `grindCoffeeBeans` and `frothMilk` have terminated when `main` terminates.



* Exercise: concurrent coffee making (using a wait group)

(implementations of `grindCoffeeBeans` and `frothMilk` are as before)

.play goroutines_with_waitgroup.go /^//START/,/^//END/

: don't forget the pair of parens at the end of each function literal!
