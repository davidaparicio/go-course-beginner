Formation Go
16 February 2022

Julien Cretel
jcretel-infosec@protonmail.com
https://jub0bs.com
@jub0bs



* Setup

Make sure you have the latest version of Go (1.17.3) installed by running

  go version

To figure out where your Go distribution is installed, run

  go env GOROOT

To learn Go, I recommend Visual Studio Code and its [[https://code.visualstudio.com/docs/languages/go][Go extension]], which embarks a number of utilities such as `goimports` and `gofmt`.

Also make sure you have Git installed.


* Running these slides

A README at the root of this Git repository explains how to run the slides using the `present` tool.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 300 _



* What to expect from the course

- interaction
- regular breaks
- learn the fundamentals
- emphasis on practice over theory
- long-running project
- gophers
- cooking analogies

: the source code of my solution will be available on GitHub



* Namecheck project

*Objectives*

Write a small CLI tool (and then a server) to check the validity and availability
of a username on multiple social networks: Twitter, GitHub, etc.

A forcing function for learning Go: we'll introduce new concepts as needed.

*Business* *case*

- Ability to choose a brand name consistent across multiple platforms.
- Username squatting!

.image https://raw.githubusercontent.com/nielsing/yar/master/images/yargopher3.png 150 _

: mention Newsweaver's rebranding to Poppulo, missed claiming @Poppulo on Twitter



* Go's history



* Genesis

Go was created in 2007 at Google by Robert Griesemer, Rob Pike, and Ken Thompson.

.image https://miro.medium.com/max/1256/0*pCC5UI7QqThjdBvm.png _ 800

: Griesemer: V8 JS engine, Hot Spot JVM
: Pike: predecessors to Go (Newsqueak), Plan 9, Unicode
: Thompson: recipient of Turing Award, UNIX (with Dennis Ritchie), Unicode (with Pike), Plan 9 (with Pike), increment/decrement operators (https://en.wikipedia.org/wiki/B_(programming_language)#History)



* Genesis

Robert, Rob, and Ken started working on Go [[https://www.youtube.com/watch?v=i0zzChzk8KE&t=545s][largely out of frustration with C++]]: language complexity, long build times, poor support for concurrency, etc.

.image https://imgs.xkcd.com/comics/compiling.png



* History of the Go project

- 2007: the project starts at Google.
- 2009: Go is open-sourced.
- 2012: Go 1.0 released.
- 2015: The go compiler (`gc`) becomes self-hosted.
- ...
- 2021: Go 1.17 is released.
- ...
- 2022: Go 1.18 is released. Generics are added to the language.



* What you should know about Go
: answer some questions you may have straight away
: manage your expectations



* Go's mascot

\... [[https://go.dev/blog/gopher][is a gopher]].

.image https://go.dev/blog/gopher/gopher.png 400 _

: more popular than the language's logo


* Go's logo

\... [[https://go.dev/blog/go-brand][is not the gopher!]]

.image https://go.dev/blog/go-brand/logos.jpg 400 _

: Lapins Crétins vibe!



* Reminiscent of, but different from, the C programming language

- strong typing
- fast compilation
- garbage collection
- memory safety
- packages
- full Unicode support
- concurrency primitives
- sensible `switch` behavior
- first-class functions
- multiple function results
- no semi-colons

: compiled, but type inference, so feels like a dynamic language
: memory safety: pointers, but no pointer arithmetic; no dangling pointers; no uninitialized variables
: mention heap-overflow vuln discovered in curl
: multiple returns allow principled error handling
: packages: no ifdef guards, no required ordering of top-level declarations
: also syntax differences: type name comes after variable name



* Go has a rich ecosystem

The `go` toolchain comes with tools for

- cross-compilation
- code formatting (`gofmt`)
- automatic package imports (`goimports`)
- testing & code coverage
- microbenchmarks
- profiling & tracing
- run-time race detector
- etc.

Moreover, the core library is pretty extensive; see [[https://pkg.go.dev/std][pkg.go.dev/std]].

: gofmt: enforced specific style. flattens learning curve and reduces friction for code reviews
: goimports: imports in canonical order and in alphabetical order per section



* Go is object-oriented... with a twist!

The ability to define custom types (and methods on them) promote _abstraction_.

Go's interfaces (and, soon, generics) enable _polymorphism_.

Go's packages enable _encapsulation_.

Go has no concept of _inheritance_, but facilitates _composition_ instead.

.image https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png 300 _



* Object orientation without inheritance

Can a language without inheritance be described as object-oriented? Sure!

.image https://i.redd.it/2dpp8t6mk7641.png 200 _

See also

- [[https://www.infoworld.com/article/2073649/why-extends-is-evil.html][Allen Holub - Why extends is evil (InfoWorld 2003)]]
- [[https://www.quora.com/What-does-Alan-Kay-think-about-inheritance-in-object-oriented-programming][What does Alan Kay think about inheritance in object-oriented programming? (Quora)]]
- [[https://golang.org/doc/faq#Is_Go_an_object-oriented_language][Is Go an object-oriented language? (golang.org FAQ)]]

: James Gosling (Java): "I'd leave classes out."
: No concept of inheritance in Alan Kay's Simula... a Web of objects



* Go also has functional aspects

Functions are first-class citizens. They can

- take other functions as parameters,
- return functions as results,
- be stored in variables,
- be stored in struct fields.

However, despite having anonymous functions, Go has no concise "lambda" notation.



* Go development pays well

See the results of the [[https://insights.stackoverflow.com/survey/2020#technology-what-languages-are-associated-with-the-highest-salaries-worldwide-global][Stack Overflow's 2020 Developer Survey]].

.image https://go.dev/blog/gophergala/fancygopher.jpg 400 _



* First steps in Go



* The Go Playground

The Go Playground ([[https://go.dev/play/][https://go.dev/play/]]) is a Web app that lets you write and run
a small Go program from your browser. Features include:

- permalinks (convenient for sharing code snippets)
- automatic formating
- automatic imports (from the core library)
- basic static analysis with `go`vet`
- [[https://go.dev/play/p/lEDjyvhttIB][limited support for modules and multiple packages]]
- downloading of the program source (^S or ⌘+S)

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/computer/gamer.svg 150 _

: It's a good place to experiment and fix ideas about the language and its core library.



* Some limitations of the Go Playground

As the name indicates, the Playground isn't meant for anything extensive.

Limitations include:

- single executable
- no networking allowed
- no command-line arguments
- poor support for third-party packages

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _

: In this course, we'll only use the Playground to solve simple exercises.
: An alternative with more features, incl. syntax highlighting: https://goplay.space/



* Hello, World!

.play -edit src/helloworld.go

You can play with this program [[https://go.dev/play/p/7vin2BK8_A6][in the Go Playground]].

.image https://go.dev/blog/gopher/plush.jpg 300 _

: we can already draw some observations from this piece of code



* Observations about our Hello-World program

.play -edit src/helloworld.go

All source file starts with a _package_clause_, i.e. the `package` keyword followed by the package's name: `package`main`

A package named `main` produces an executable program (as opposed to a library).

Imports specify _package_paths_ in double quotes.

The `main` function of a `main` package is the program's entrypoint; it takes no parameters and returns no results.



* More observations about our Hello-World program

.play -edit src/helloworld.go

Go's formal grammar [[https://golang.org/ref/spec#Semicolons][uses semicolons as statement terminators]], but those semicolons do not appear in the source; [[https://golang.org/doc/effective_go#semicolons][they're added by the compiler]]. As a result, you're not free to break lines wherever you want.

The formater uses tabs (not spaces) for indentation.

Go source files [[https://golang.org/ref/spec#Source_code_representation][*must* be encoded in UTF-8]], or compilation will fail.

: cmd args: os.Args
: guillemets doubles



* Namecheck project: a starting point

1. Create a folder named `namecheck`.

2. Create a file named `main.go` file at the root of the `namecheck` folder.

  namecheck
  └── main.go

3. Write a "Hello World" programme in main.go

4. Compile it by running the following command, which creates an executable
(named `main` on *nix systems or `main.exe` on Windows):

  go build main.go

5. Execute the executable.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 100 _

: for now, we'll code in this source file, but we'll reorganize our code later



* Compiling and executing a program in one fell swoop

If you just want to run the program without keeping the executable, run

  go run main.go

which is roughly equivalent (on *nix systems) to

  go build main.go
  ./main
  rm main

Don't use `go`run` in production, though.

.image https://miro.medium.com/max/4800/1*-bo7H329eM0O1eL_ASBVOA.jpeg 200 _



* Cross-compilation

By default, the compiler will produce an executable targeting your operating system and architecture.

However, you can cross-compile to a different operating system and architecture using the `GOOS` and `GOARCH` environment variables:

  GOOS=windows GOARCH=amd64 go build main.go

The following command lists all valid GOOS/GOARCH combinations:

  go tool dist list

.image https://go.dev/blog/store/gophers.jpg 200 _



* Modules

Go's solution to dependency management is known as the _module_system_.

A _module_ is set of packages that are versioned together.

You *must* initialize a module at the root of your project in order to manage dependencies (incl. packages within the same project).

A module is identified by its _path_, which

- takes the form of a schemeless URI where the module will be made available,
- acts as prefix for package import paths within the module.

The `go`mod` subcommand allows you to interact with the module system. You can initialize a module by running a command of the form

   go mod init <your-module-path>

: one module per project, initialized at the



* Namecheck project: initialize a module

At the root of your project, initialize a module:

  go mod init github.com/YOUR_GITHUB_USERNAME/namecheck

A go.mod file will be created at the root of your project:

  namecheck
  ├── go.mod
  └── main.go

Inspect its contents.



* Keywords

  break           default           func          interface       select
  case            defer             go            map             struct
  chan            else              goto          package         switch
  const           fallthrough       if            range           type
  continue        for               import        return          var

Discuss. Which keywords are new to you? Which one(s) seem to be missing?

.image https://go.dev/blog/5years/gophers5th.jpg 300 _



* Keywords

*chan* and *select* are related to _channels_, which allow you to communicate between goroutines (Go's lightweight threads).

*fallthrough* can be used to override `switch`'s normal "breaking" behavior.

*go* is used to spawn goroutines.

*goto* is present in the language, but you shouldn't have to ever use it.

*range*, used in conjunction with `for`, allows you to iterate over various data structures.

No `while` keyword in Go: all loops are written with the `for` keyword.

No `try`/`catch`/`finally` keywords in Go: errors are reported as normal values.

*defer* allows you to unconditionally execute some code at the end of a function.


: defer: a cleaner alternative to finally



* Predeclared names

Go also comes with several predeclared names accessible from anywhere in your code:

*Constants*

  false true nil iota

*Built-in*types*

  bool int rune uint byte float64 string
  struct map chan
  interface error

*Built-in*functions*

  make    len     cap     new
  append  copy    delete
  panic   recover

(None of those lists is exhaustive.)



* Comments

[[https://golang.org/ref/spec#Comments][_Line_comments_]] start with a double slash and extend to the end of the line:

  var foo = "foo" // this is a comment

[[https://golang.org/ref/spec#Comments][_General_comments_]] are delimited by `/*` and `*/`; they can be multiline and they do not nest:

  /*
    this is
    a general comment
  */

The documentation of a package is written as comments in the package's source file(s).

: won't talk too much about documentation in this first course



* Consuming packages



* Package path and package name

A package is identified by its _path_, which must be globally unique.

  fmt
  net/http
  github.com/jub0bs/missilelauncher

The _default_name_ of a package typically corresponds to the last component of its path:

  fmt
  http
  missilelauncher

Compiling a package whose default name is `main` produces an executable
(and a library otherwise).

: first two are part of core library; third one is third-party
: "usually": the exception is for a package whose enclosing folder doesn't mach the package name; best avoided
: also, with versions of modules after v1, it's the second last path component: "rsc.io/quote/v3" => quote



* Package: the unit of compilation

A package is composed of one or more source files that are compiled together.

All of a package's source files (and no other!) must

- be in the same folder (e.g. foo),
- start with the same package clause (e.g. `package`foo`).

Each source file of a package must import the packages it consumes.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _

: imports are not "shared" across source files.



* Exercise: a closer look at the fmt package with go list

`go`list` allows you to ask questions about packages at the command line.

Run the following command in your shell to list the production source files that make up the `fmt` package:

  go list -f "{{ join .GoFiles \"\\n\" }}" fmt

Run the following command in your shell to determine where the `fmt` package lives
on your machine, and check the contents of the folder:

  go list -f "{{ .Dir }}" fmt

Note that the folder also contains test files.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Exercise: a closer look at the fmt package

Consult the documentation of the `fmt` package.

The documentation is available offline via the `go`doc` subcommand:

  go doc fmt
  go doc fmt Println

It's also available online at [[https://pkg.go.dev/fmt][https://pkg.go.dev/fmt]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _



* Package: the unit of encapsulation

In Go, the package (not the type!) is the unit of encapsulation.

There are only two access levels: a package-level identifier is either

- _exported_ (i.e. accessible from another package), or
- _unexported_ (i.e. only accessible within its own package).

Whether a package-level identifier is exported depends on the case of its first letter:

  package foo

  var Bar = "Bar"                   // starts with an uppercase B:   exported by package foo
  type Baz struct { /* ... */ }     // starts with an uppercase B:   exported by package foo
  const qux = 42                    // starts with a lowercase q:  unexported by package foo
  func quux() { /* ... */ }         // starts with a lowercase q:  unexported by package foo



* Importing packages

A package can be imported in different ways: normal imports, named imports, blank imports, dot imports, relative imports.

The [[https://pkg.go.dev/golang.org/x/tools/cmd/goimports][`goimports`]] utility takes care of adding missing imports, removing unreferenced imports, and organizes imports in a canonical way:

  import (
    // core-library packages

    // third-party packages

    // project packages
  )

.image https://go.dev/blog/store/gophers.jpg 200 _

: We won't mention relative imports again because they are best avoided.
: goimports should run every time you save a file in VS Code



* Normal imports

This is the most common form of import.

You used a normal import in your Hello-World program:

.play -edit src/helloworld.go

To access an identifier exported by a different package (`fmt`, here), you must qualify it using the default package name as prefix (`fmt.Println`).

Importing a package without consuming it causes a compilation error!



* Named imports

Named imports allows you to use the imported package under a different name.

A named import is handy when you perceive the default package name as inappropriate:

  import ml "github.com/jub0bs/missilelauncher"

But named imports are especially useful

- when your code imports multiple packages whose default names collide:

  import "math/rand"
  import crand "crypto/rand"

- when your code uses multiple major versions of a _module_ within the same file:

  import "github.com/jub0bs/missilelauncher"
  import mlv2 "github.com/jub0bs/missilelauncher/v2"

: more on this later



* Blank imports

A blank import uses the blank identifier as package name:

  import _ "github.com/go-sql-driver/mysql"

A blank import makes none of the imported package's members available in the importing package.

The sole reason for using a blank import to import a package is the side effects carried out during [[https://golang.org/ref/spec#Package_initialization][the package's initialization]].

Blank imports are used in the so-called _registration_pattern_ in packages such as `database/sql` and `image`.

Use that pattern if you have to, but do not emulate it in your own code.

: difficult to understand, based on shared global state



* Dot imports

A dot import allows you to access all the exported identifiers of the imported package without the need to qualify them:

.play -edit src/helloworld_dot.go

Dot imports can be convenient in test code, but are otherwise best avoided because

- they pollute the namespace of your source file,
- they obscure the provenance of identifiers.

: similar to Java's static imports



* Types



* Basic types

Go provides basic types:

- booleans
- numeric (integer and floating-point)
- strings

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _



* Composites types

Go also provides composite types, which are composed of other existing types:

- pointers
- functions
- channels
- interfaces
- arrays
- slices
- maps
- structs



* Every type has a zero value

In Go, [[https://twitter.com/dildog/status/1390848784918327298][unlike in C]], there is no such thing as an uninitialized variable.

Every type, whether built-in or user-defined, has a default value called its _zero_value_.

When you declare a variable without initializing it, its value is the zero value of the variable's type:

  var i int    // the value of i is 0
  var s string // the value of s is the empty string ""

Types whose zero value is `nil` are known as _reference_types_: pointers, functions, channels, interfaces, slices, and maps.

: in French: valeur vierge



* Comparability

A type is said to be _comparable_ if arbitrary values of that type can be compared
for equality (with operator `==`) or inequality (with operator `!=`).

All basic types are comparable, but not all composite types are comparable;
for instance, functions, slices, and maps are not.

In some places (map keys, switch expressions, etc.), only comparable types can be used.

.image https://golangforall.com/assets/kanat.svg 200 _



* Type definitions

The `type` keyword lets you define a type based on some existing _underlying_type_:

  type Celsius int
  type Fahrenheit int
  type Kelvin int

`Celsius`, `Fahrenheit`, and `Kelvin` are three _defined_types_ all based on type `int`.

The four types share the same zero value (`0`, in this case).

However, they are distinct types and are *not* interchangeable.

.image https://go.dev/blog/gopher/header.jpg 150 _

: You can only declare methods on defined types that you own.
: you can have type definitions anywhere, incl. inside functions
:   - struct types useful for JSON encoding/decoding
:   - interface types useful for asserting on behaviour



* Type conversion

If two types are "compatible", an expression of one type can be [[https://golang.org/ref/spec#Conversions][converted]] to the other, either implicitly or explicitly.

However, Go requires many conversions from one type to another to be explicit

.play -edit src/type_conversion.go /^//START/,/^//END/



* Variables

Go's declaration syntax departs from C's in many ways.
Rob Pike clarified the motivations behind this departure in
[[https://go.dev/blog/declaration-syntax][a post entitled _Go's_Declaration_Syntax_]].

[[https://go.dev/play/p/GTMUrroC0lz][Playground]]



* var vs. short variable declaration

Short variable declaration is only allowed for local variables, declared within functions.

Moreover, you have to use `var` rather than `:=` when the default type of the initializing expression won't do or cannot be inferred:

  var f Fahrenheit = 32   // more idiomatic than f := Fahrenheit(32)

  userptr := nil          // won't compile: untyped nil
  var userptr *user = nil // fine

In other cases, the choice between the two syntaxes is up to you.

However, convention favors using `var` rather than `:=` when the variable's initial value must be the zero value or simply doesn't matter. Favor `:=` in all other cases.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 150 _



* Pointers

[[https://go.dev/play/p/QJNCrBMXP6b][Playground]]



* If and switch statements



* If statements

The condition must be of type `bool` and needs not be enclosed in parens.
However, braces around the body are mandatory.

.play -edit src/if_simple.go /^//START/,/^//END/

A [[https://golang.org/ref/spec#Statements][_simple_statement_]] (usually a short variable declaration) can precede the condition:

.play -edit src/if_short_variable_decl.go /^//START/,/^//END/

The scope of such variables is restricted to the if(-else) statement.

: mandatory braces: no dangling-else problem like in C, JS, etc.
: short-var-decl: useful for error handling



* If-else statements

Braces around the `else` body are also mandatory.

.play -edit src/if_else.go /^//START/,/^//END/

`else` is one of the least popular keyword in Go!

If-else chains are considered non-idiomatic, and can often be advantageously replaced by a _tagless_ `switch`.



* Switch statement

The switch expression, whose type must be comparable, is evaluated once.

The case expressions (not necessarily constants), are evaluated left-to-right and top-to-bottom and tested for equality against the case expression until a match is found.

The first match's case gets executed. Otherwise, the default case (if any) gets executed.

.play -edit src/switch.go /^//START/,/^//END/

No need for the `break` keyword at the end of cases! Use `fallthrough`, if needed.

: A short-variable-declaration statement can precede the switch condition.
: The default clause can occur at any place among the the normal cases.



* Tagless switch

You can omit the switch expression, which is equivalent to using `true`:

.play -edit src/tagless_switch.go /^//START/,/^//END/

This form of `switch` statement is preferred to a long if-else chain.



* Type switch

A _type_switch_ allows you to switch on an interface value and change the logic on the basis of the concrete type stored inside it:

.play -edit src/type_switch.go /^//START/,/^//END/

Use type switches sparingly. More on that when we cover interfaces.


* Loops


* While-style loop

Remember: no `while` keyword in Go!

.play -edit src/while.go /^//START/,/^//END/

The conditional expression

- must be of boolean type,
- needs not be parenthesized,
- can be omitted (to obtain an infinite loop).



* break and continue

As in other languages, the `break` keyword terminates the (innermost) loop;

.play -edit src/break.go /^//START/,/^//END/

the `continue` keyword skips to the next iteration of the (innermost) loop.

.play -edit src/continue.go /^//START/,/^//END/

For nested loops, those keywords can be used in conjunction with [[https://go.dev/ref/spec#Labeled_statements][_labels_]].



* C-style loop

The familiar loop syntax from the C-family languages is back.

.play -edit src/forc.go /^//START/,/^//END/

Again, no parentheses needed around the init/condition/post part.



* for-range loop

The `range` keyword can be used in conjunction with `for` to iterate over some data structures, such as a string:

.play -edit src/forrange.go /^//START/,/^//END/

A for-range loop can also be used to iterate over arrays, slices, maps, channels. More about that in due time.



* Functions



* Calling a function

To call a function, specify *all* the required arguments by *position* within parentheses
after the name of the function, using commas as delimiters:

.play -edit src/function_call.go /^//START/,/^//END/

[[https://docs.python.org/3/glossary.html#term-argument][Unlike Python]] (and others), Go doesn't allow you

- to specify arguments by keyword or name,
- to specify a default value for a parameter of your function.


* Evaluation strategy: call by value

Go's [[https://en.wikipedia.org/wiki/Evaluation_strategy][evaluation strategy]] is [[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value][_call_by_value_]], without any exception.

Each argument expression is eagerly evaluated, and the result is bound to the corresponding parameter variable within the function.

In brief, functions only operate on *copies* of their arguments:

.play -edit src/call_by_value.go /^//START/,/^//END/



* Evaluation strategy: call by sharing?

However, because some types (strings, slices, maps, channels, functions)
are composed of a pointer to some hidden data structure in memory.

[[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing][_Call_by_sharing_]] is perhaps a more appropriate term than _call_by_value_ to describe
what happens when values of such types are passed to a function.

.play -edit src/call_by_sharing.go /^//START/,/^//END/


* Function declaration

Here is a simple example of a named function:

  func CountWords(s string) int {
    return len(strings.Fields(s))
  }

A function can return multiple results (whose types must be specified within parens):

  func CountWordsInFile(path string) (int, error) {
    var count int
    // ...
    return count, nil
  }

Multiple function results are key to error reporting in Go!

There's no function overloading in Go: no two functions within the same scope
can have the same name but different signatures.



* Namecheck project: validation of Twitter usernames

A prospective username is valid on Twitter if it

- does not contain any case-insensitive match of "twitter" (e.g. "TwItTEr"),
- contains between 4 and 15 alphanumeric or underscore characters.

Write a function that implements the first rule:

  func containsNoIllegalPattern(username string) bool {
    // returns true if username does not contain "twitter"
    // (and all case variations, incl. "TwItTEr", etc.)
  }

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: hint: keep it simple


* Named results

You can name (either all or none of) your function's results:

  func CountWordsInFile(path string) (count int, err error) {
    // ...
    return
  }

Note the "naked" return: often, what to return is implied from the list of named results.

The code above is roughly equivalent to the following:

  func CountWordsInFile(path string) (int, error) {
    var count int
    var err error
    // ...
    return count, err
  }

Named results can be useful for documenting the results' roles and simplifying some implementations, but use them sparingly.




* Variadic functions

You can declare a function that accepts an arbitrary number of identically typed parameters:

.play -edit src/function_variadic.go /^//START/,/^//END/


The variadic argument (`rest`, here) is a _slice_ and must be the last to appear in the parameter list.

You've already used a variadic function... Which one? Check its signature in the doc.



* Type factorization in parameter and result lists

The type of identically typed consecutive parameters can be factored out:

  func Split(s, sep string) []string { // see the strings package

Similarly, the type of identically typed consecutive results can be factored out:

.play -edit src/function_factored_type_in_result_list.go /^//START/,/^//END/



* Recursion

Go supports recursion: a function can call itself (directly or indirectly).

.play -edit src/recursion.go /^//START/,/^//END/

Recursion is useful for traversing recursive data structures, such as trees.

Because call stacks grow and shrink as needed, unless you have a bug somewhere,
you're less likely to cause a stack overflow by recursing than in other languages.



* Functions are first-class values

Functions can [[https://pkg.go.dev/net/http/#HandleFunc][take other functions as parameters]], [[https://go.dev/play/p/LfT4e0lPmNV][return functions as results]],
be stored in variables, etc.

.play -edit src/function_nil.go /^//START/,/^//END/

Each function has a type.

Function types are *not* comparable.

The zero value of function types is `nil`.

Be careful: calling a `nil` function causes a panic!

: function-typed results can also be useful for cleaning up; see Mat Ryer's talk



* Anonymous functions and lexical closures

Go supports anonymous functions but lacks a concise "lambda" notation:

  incr := func (i int) int { return i + 1 }

An anonymous functions can _capture_ variables that are accessible to it:

.play -edit src/function_closure.go /^//START/,/^//END/

Anonymous functions are often conveniently used in conjunction with the `go` keyword to launch goroutines.



* And one more thing: defer

*defer* allows you to unconditionnaly execute some code at the end of a function call.

It's particularly useful for cleaning up, reclaiming resources, etc.

More about `defer` later in the course!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 300 _



* Namecheck project: validation of Twitter usernames

Use the `regexp` package to write a function that implements the second rule:

  func looksGood(username string) (bool, error) {
    // returns true iff username matches regexp ^[0-9A-Z_a-z]{4,15}$ and some (?) error
  }

Does the function's signature satisfy you?

What signature would you prefer? Why?

How would you achieve that?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/adventure/hiking.svg 200 _

: transition: we need to learn about error handling in Go, and for that we need to learn about if and switch statements



* Error handling



* Errors are values

There are no exceptions in Go! Anticipated failures are reported as [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=16m13s]["normal" values]] of the built-in interface type `error`.

A function that can fail returns an additional `error` result (the last one, by convention):

  func Get(url string) (resp *Response, err error) // example from the http package

A non-nil `error` result indicates that the function failed; hence this error-check idiom:

  resp, err := http.Get("https://jub0bs.com")
  if err != nil {
    fmt.Fprintln(os.Stderr, "failure to GET jub0bs.com:", err)
    return
  }
  // do something interesting with resp

: mention that a boolean result can be used if the function can fails for a single unambiguous cause

: compare with other languages
:   C: error codes, in-band, no multiple return values; write more to a volatile location in memory
:   Java/Scala: exceptions, or Option, Either or some Result type (more functional)



* Don't ignore errors

Few errors should be ignored. You can deviate from this general rule in some cases,
particularly with `fmt.Println` and friends.

You simply cannot assume success of a fallible function and the soundness
of its other results (if any) if you don't check the error it returns!

Error handling in Go is very explicit; it can be perceived as repetitive and tedious,
but that's actually [[https://changelog.com/gotime/16#transcript-68][a strength of the language]]. You will grow to love it!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-hug.svg 200 _

: for some functions, a non-nil error may indicate only a partial failure (e.g. Read)



* Line of sight

Always deal with the failure case first.

Don't do this:

  v, err := fallibleFunction()
  if err == nil {
    // success; do something interesting with v
  } else {
    // failure: handle error
  }

Do this instead:

  v, err := fallibleFunction()
  if err != nil {
    // failure: handle error and perhaps return early
  }
  // success; do something interesting with v

: Narrow code is better than deeply nested code!



* Line of sight (cont'd)

This idiom greatly contributes to the readability of Go code.

By avoiding the `else` keyword and eliminating error cases as they arise,

- you [[https://golang.org/doc/effective_go#if][keep the "happy path" on the left]],
- you [[https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting][minimize nesting]] (your code reads like columns of a broadsheet newspaper),
- you [[https://www.youtube.com/watch?v=yd_rtwYaXps&t=33m30s][reduce the cognitive load]] required to read and understand your code.

See also [[https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88][Mat Ryer's blog post on this topic]].

.image https://upload.wikimedia.org/wikipedia/commons/4/44/New_York_Times_1914-07-29.jpg 200 _

: also about cognitive load: https://talks.golang.org/2013/bestpractices.slide#3



* Different ways of handling errors

- bubble it up to the caller
- log it or print it to stderr
- compare it to some sentinel error value (e.g. `io.EOF`)
- inspect its underlying cause
- wrap it in a higher-level error

Which approach to favor is highly context-dependent. Discuss.

However you choose to handle an error, handle it only once!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _

: bubble it up: you lose context
: I've seen people logging the error at every stage of the call stack! => duplicate entries in logs, confusing



* Creating error values

`errors.New` allows you to create a simple error value:

	err := errors.New("namecheck: failure to check availability of 'jub0bs' on Twitter")

\... but `fmt.Errorf` is more flexible:

	username := "jub0bs"
	platform := "Twitter"
	err := fmt.Errorf("namecheck: failure to check availability of %q on %s", username, platform)

By convention, error messages

- are of the form "<package-name>: <human-readable-error-message>",
- should be lowercase,
- should not contain linebreaks.

You can also create your own error types (i.e. types that satisfy the `error` interface).

: more on custom error types later



* Panic

A panic is a runtime event that indicates an exceptional and fatal failure.

It can be triggered by a runtime error (such as calling a `nil` function) or some direct or indirect call to built-in function `panic`.

A panic stops the programme's normal execution, runs deferred function calls as it unwinds the stack, prints an error message and goroutine traces, and exit the program with a non-zero status:

.play -edit src/panic.go /^//START/,/^//END/

Panics can (but rarely, if ever, should) be [[https://go.dev/blog/defer-panic-and-recover][_recovered_]].

: recover: if you consume a third-party package that panic willy-nilly



* Don't panic willy-nilly in your code

Do not panic in your functions for anticipated and mundane failures:

- a file couldn't be opened
- a HTTP request failed
- the connection to the database dropped

In idiomatic Go, such failures are instead reported to the caller as `error` values.

However, panicking during the initialization of your package is legitimate
if some programming error renders the package unusable.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Namecheck project: fail early if the regexp is unusable

Use what you've learned to change the signature of your `looksGood` function to

  func looksGood(username string) bool {
    // returns true iff username matches regexp ^[0-9A-Z_a-z]{4,15}$
  }

Fail early if the regular expression doesn't compile.

.image https://i.redd.it/48emz1dvfz441.png 200 _

: use a bool variable to control the termination of the loop



* Namecheck project: validation of Twitter usernames

Write a function named `IsValid` that returns true if its parameter is a valid username on Twitter, and false otherwise:

  func IsValid(username string) bool {
    // returns true if username is valid on Twitter
  }

Write a few "tests" for `IsValid` in the `main` function.

All the code we've written in `main.go` so far is specific to Twitter, which is a bit messy.

It would be preferable to create a dedicated library package for each of the supported platforms (Twitter, GitHub, etc.)

Let's learn how to create a library package and import it in our `main` package.



* Designing and organizing packages



* Namecheck project: create a namecheck package

1. At the root of your project, create a namecheck.go file.

2. In it, simply write the following package clause:

  package namecheck

3. Try compiling. What happens?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Two kinds of packages

*Library*packages*

- A library package produces a library meant to be imported in other packages.
- The package name *must*not* be "main".
- The name of the enclosing folder should match the package name.

*Main*packages*

- A main package produces an executable.
- The package name *must* be "main".
- The package *must* declare a `main` function without any parameters or results.
- The name of the enclosing folder is arbitrary.
- If a project produces several executables, put each of the main packages in a subfolder of a folder named "cmd" located at the root of your project.

: only should, because _test package exception and also not enforced by tooling, but otherwise confusing
: in most cases, the last segment of the package path should match the package name as declared in package clause



* Source files of a package

A package is composed of one to several source files.

All of a package's source files must be placed in the same folder.

Source files from different packages cannot be in the same folder!

All package members are accessible to all of the package's source files.

Each source file must import the packages that it needs.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _



* Namecheck project: create a cmd folder

1. Create a folder named "cmd" at the root of your project.

2. Create a subfolder named "cli".

3. Move your `main.go` file to `cmd/cli/`:

  namecheck
  └── cmd
      └── cli
           └── main.go

4. From the root of your project, check that `main.go` still compiles:

  go run cmd/cli/main.go

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _




* Designing a package

*Naming*a*package*

[[https://www.youtube.com/watch?v=zzAdEt3xZ1M&t=5m45s][A well-designed package starts with its name]]. The name of a package should be

- lowercase alphanumeric (no underscores!),
- concise ("net", not "network") but descriptive (avoid "util", "helpers", "common"),
- a noun rather than a verb,
- a clue to its purpose (rather than its content).

*Strive*for*cohesion*

A package should provide a focused set of related features. Let the name guide you!

*Keep*the*conceptual*surface*area*small*

Don't export identifiers by default; be deliberate about what you export.

: concise: fmt, not format; strconv, not stringconversion



* Good naming practices for package identifiers

Remember: exported identifiers will be prefixed by their package name in client code.

Avoid _stutter_, if possible. (Any counterexamples in the core library?)

  log.LogInfo // not great
  log.Info  // much better

Avoid redundancy in factory functions:

  twitter.NewTwitter // redundant
  twitter.New        // much better

Only choose more specific factory-function names if the package exports multiple types,
such as `Encoder` and `Decoder` in the `encoding/json` package:

  json.NewEncoder
  json.NewDecoder

: exceptions: regexp.Regexp, time.Time



* Subpackages

Subpackages of a package are simply packages located in subfolders of that package.

They allow grouping of functionalities related to but more specific than those provided by their superpackage.

.image img/encoding_core_lib.png 150 _

A package doesn't have any special relationship with its subpackages:

- if package `foo/bar` depends on package `foo`, `foo/bar` must import `foo`;
- `foo/bar` does not have access to identifiers not exported by `foo`;
- `foo` does not have access to identifiers not exported by `foo/bar`.



* No dependency cycles allowed by the compiler

For example, package `foo` cannot import package `bar` if `bar` itself imports `foo`.

.image img/dependency_cycle.svg 150 _

Imports form a _directed_acyclic_graph_, like the graph of commits in a Git repository.

This design decision by the Go team is a key enabler of fast compilation.

.image https://miro.medium.com/max/4800/1*-bo7H329eM0O1eL_ASBVOA.jpeg 200 _

: ex: the core library can be compiled in 10s on a modern machine



* Avoiding dependency cycles with subpackages

A rule of thumb is that a superpackage doesn't depend on any of its subpackages.

For example, here is a partial view of the `encoding` package and its subpackages:

.image img/dep_arrows_dont_point_down.svg _ 1000

Note that no dependency arrows points down.


* Flat is better

To a deep and narrow package hierarchy, prefer a shallow and possibly wide one:

.image img/pkg_shallow_and_wide.svg 400 _



* Keep cool: don't panic

Good library packages do not panic, at least not

- after proper initialization, and
- if they're used as was intended by the package author(s).

Exported functions should communicate anticipated failures to client code as values of the `error` type, not as panics.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/dandy/umbrella.svg 200 _



* Namecheck project: twitter package

1. Create a folder named "twitter" at the root of your project.

2. Create a "twitter.go" file in there:

  namecheck
  ├── cmd
  │   └── cli
  │        └── main.go
  └── twitter
      └── twitter.go

3. Add the appropriate package clause in `twitter.go`.

4. Move all the Twitter-specific stuff from `main.go` to `twitter.go`.

5. Try importing package `twitter` in your `main` package. Any issues?



* Testing



* First-party support for testing

Testing plays a key role in the Go ecosystem, and is supported out of the box.

The [[https://pkg.go.dev/testing/][`testing` package]] allows you to test your packages through

- unit tests or integration tests
- example tests (executable examples that end up in the package's documentation),
- micro-benchmarks (laser-focused performance tests for CPU-bound functions).

You can run tests by invoking the `go`test` subcommand.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _

: batteries included: compare to other languages, where testing is an afterthought



* Test files

In Go, a package's test files

- are placed in the same folder as the package's production source files,
- must be suffixed with `_test`.

For instance, to write tests for your package `foo`, composed here of a single source file named `foo.go`, you would create a file named `foo_test.go` in the `foo` folder alongside the `foo.go` file:

  foo
  ├── foo.go
  └── foo_test.go

Respect these location and naming conventions, or you won't be able to run your tests.

Test files are otherwise regular source files in which you write _test_functions_.

: differs from other languages, where tests are located in a mirrored structure of the production code



* White-box testing and black-box testing

You have two options in the name used in the package clause of your test files for package `foo`: `foo` or `foo_test`. This choice determines your testing approach.

*White-box*testing*

You can declare file `foo_test.go` to be part of package `foo`:

  // foo_test.go
  package foo

Your tests then have access to all members (incl. unexported ones) of package `foo`.

*Black-box*testing*

Alternatively, you can declare file `foo_test.go` to be part of package `foo_test`:

  // foo_test.go
  package foo_test

Your tests then only have access to the exported members of package `foo`.



* White or black box?

White-box testing is the approach favored in the core library. It is convenient,
but can lead to prohibitive coupling between tests and implementation details.

.image https://pbs.twimg.com/media/EzrMZe6X0AMSozD?format=jpg&name=900x900 300 _

Black-box testing is an approach favored by [[https://changelog.com/gotime/173#transcript-153][many Gophers]]: it keeps you honest,
as a package author, by forcing you to test your packages through their public API.
It can also be useful to avoid dependency cycles.



* Test functions

A test function is a regular Go function, but its name and signature must adhere
to a strict convention:

- It must be prefixed by `Test` and the following character must be uppercase.
- It takes a single parameter of type `*testing.T` and returns no results.

Respect this convention, or your test functions will be ignored by `go`test`.

The `testing.T` type provides methods (such as `Errorf`) that allow you to indicate that a test is failing, via an informative message.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _



* Test functions: an example for the twitter package

The following example uses black-box testing:

  package twitter_test

  // omitted import declaration of your twitter package

  func TestUsernameContainsTwitter(t *testing.T) {
    const (
      username = "jub0bsOnTwitter"
      want     = false
    )
    got := twitter.IsValid(username)
    if got != want {
      t.Errorf("twitter.IsValid(%q): got %t; want %t", username, got, want)
    }
  }

The message format used here ("got ...; want ...") is widely used.



* Namecheck project: test twitter's IsValid function

Create a file named `twitter_test.go` in the `twitter` folder.

  namecheck
  ├── cmd
  │   └── cli
  │       └── main.go
  ├── go.mod
  └── twitter
      ├── twitter.go
      └── twitter_test.go

Follow the black-box approach (use `twitter_test` as the package name)
and write the test function shown on the previous slide.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _



* Running tests

From within a package's folder, you can execute its tests by running

 go test

Passing tests are not mentioned in the output; use the `-v` flag to change that:

  go test -v

To execute the tests for a package and all of its subpackages, run

  go test ./...

You can also selectively run some test functions by specifying a regexp, e.g.:

  go test -run='TestUsernameToo*' ./...



* Code coverage

To determine how much of your package's production code is covered by its tests, run

  go test -cover ./...

To generate a more detailed (machine-readable) coverage report, first run

  go test -coverprofile="coverage.out" ./...

Then, for a shell-based breakdown of the coverage by package function, run

  go tool cover --func="coverage.out"

Alternatively, for a browser-based breakdown of the coverage by statement, run

  go tool cover --html="coverage.out"

What would a low coverage say about your tests? What about a high coverage? Discuss.



* Namecheck project: code coverage of twitter package

Inspect the code coverage of your `twitter` package.

Write enough good test cases to reach a code coverage that satisfies you.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/standing.svg 200 _



* Namecheck project: validation of GitHub usernames

Create a `github` package (you can copy the `twitter` package to get started quickly):

  namecheck
  ├── cmd
  │   └── cli
  │       └── main.go
  ├── github
  │   ├── github.go
  │   └── github_test.go
  ├── go.mod
  └── twitter
      ├── twitter.go
      └── twitter_test.go

A prospective username is valid on GitHub if it

- contains between 3 and 39 alphanumeric or hyphen characters,
- doesn't start or end (or both) with a hyphen,
- doesn't contain two hyphens in a row.



* Namecheck project: validation of GitHub usernames

Write a function named `IsValid` that returns true if its parameter is a valid username on GitHub, and false otherwise:

  func IsValid(username string) bool {
    // returns true if username is valid on GitHub
  }

Adapt the test cases in `github_test.go` and make them pass.

Keep writing test cases until you're satisfied with the overall code coverage.

.image https://go.dev/blog/store/gophers.jpg 300 _



* Namecheck project: availability on GitHub

Let's write a function that checks the availability of a username on GitHub.

1. Study the second code snippet in [[https://pkg.go.dev/net/http/#pkg-overview][the Overview section of the `net/http` package]].

2. In the `github` package, add the following stub:

  func IsAvailable(username string) (bool, error) {
    return false, nil
  }

3. Now implement it for real. It should send a `GET` request to `https://github.com/USERNAME`, where USERNAME is a placeholder for the username whose availability we'd like to check.

- If the response's status code is `404`, `IsAvailable` should return `true` and `nil`.
- If the response's status code is `200`, `IsAvailable` should return `false` and `nil`.
- For any other status code or in case an error occurs, `IsAvailable` should return `false` and a non-nil error.



* defer

[[https://pkg.go.dev/net/http/#pkg-overview][The documentation of the `net/http` package]] warns that the client must close the response body when finished with it. Note that the defer keyword is used:

  defer resp.Body.Close()

`defer` is useful for reclaiming resources (like the body of a `http.Response`), and generally cleaning stuff up when you're done with it.

It's similar in spirit to the `finally` keyword from other languages, but it's much more convenient to use. You'll grow to love it!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 200 _

: Along with concurrency primitives and interfaces, this keyword is a highlight of Go!



* Mechanics of the defer keyword

`defer` causes the function call to which it's applied to unconditionnaly execute when the enclosing function terminates (whether normally or because of a panic).

.play -edit src/defer_unconditional.go /^//START/,/^//END/



* Mechanics of the defer keyword (cont'd)

Deferred function calls are executed in reverse order in which they occur in the enclosing function.

.play -edit src/defer_reverse.go /^//START/,/^//END/

Note also that the arguments of a deferred function call are evaluated, not when the function call executes, but when the `defer` statement is reached.



* Why is defer useful?

Here is a version of `IsAvailable` that doesn't use `defer` to close the response body:

  func IsAvailable(username string) (bool, error) {
    resp, err := http.Get("https://github.com/" + username)
    if err != nil {
      return false, errors.New("unknown availability")
    }
    switch resp.StatusCode {
    case http.StatusNotFound:
      resp.Body.Close()
      return true, nil
    case http.StatusOK:
      resp.Body.Close()
      return false, nil
    default:
      resp.Body.Close()
      return false, errors.New("unknown availability")
    }
  }

Notice how we need to call `resp.Body.Close` at each possible exit point.



* Why is defer useful? (cont'd)

And now with `defer`:

  func IsAvailable(username string) (bool, error) {
    resp, err := http.Get("https://github.com/" + username)
    if err != nil {
      return false, errors.New("unknown availability")
    }
    defer resp.Body.Close() // once and for all
    switch resp.StatusCode {
    case http.StatusNotFound:
      return true, nil
    case http.StatusOK:
      return false, nil
    default:
      return false, errors.New("unknown availability")
    }
  }

As soon as we know the HTTP request succeeded, we can program the closure of the response body and forget about it!



* A defer pitfall

`defer` is unreasonably convenient and powerful, but must be used with caution.

Consider the following function. What's a potential issue, here?

  func processFiles(paths ...string) {
    for _, path := range paths {
      file, err := os.Open(path)
      if err != nil {
        // deal with error
        continue
      }
      defer file.Close()
      // do something interesting with file...
    }
  }



* A defer pitfall (cont'd)

Remember that deferred function calls are executed only when the enclosing function terminates, not at the end of the loop iteration that they appear in. Here, the files will all be closed _only_ when the function terminates!

One solution is to enclose the defer statement in a smaller function:

  func processFiles(paths ...string) {
    for _, path := range paths {
      if err := processFile(path); err != nil {
        // deal with error
      }
    }
  }
  func processFile(path string) error {
      file, err := os.Open(path)
      if err != nil {
        // deal with error
      }
      defer file.Close()
      // do something interesting with file...
  }

: If we pass a large number of files to the `processFiles` function, we could run out of file descriptors.
: ulimit -n



* Namecheck project: availability on Twitter

We cannot take the same shortcut for Twitter as we did for GitHub, because

  https://twitter.com/FOO

returns a `200` response regardless of whether the user `FOO` actually exists. We'll need to do things properly and call the Twitter API. For now, just stub `IsAvailable` in Twitter:

  func IsAvailable(username string) (bool, error) {
    return false, nil
  }



* Namecheck project: missing abstraction

Our project is starting to take shape, but it still suffers from limitations.

In particular, the `twitter` and `github` packages both export `IsValid` and `IsAvailable` functions with identical signatures, but nothing relates them. It would be nice to have a common abstration to manipulate one or the other indiscriminately...

Also, at this stage, `IsAvalailable` unconditionally sends a HTTP request. How are we going to write unit tests for it? We'd need a way of somehow mocking the HTTP client...

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _



* Structs

[[https://go.dev/play/p/axkpaElUyHI][Live demo in Playground]]



* Namecheck project: availability on Twitter

Implement `IsAvailable` in the `twitter` package:

  func IsAvailable(username string) (bool, error) {
    const tmpl = "https://europe-west6-namechecker-api.cloudfunctions.net/userlookup?username=%s"
    endpoint := fmt.Sprintf(tmpl, username)
    resp, err := http.Get(endpoint)
    if err != nil {
      return false, errors.New("unknown availability")
    }
    defer resp.Body.Close()
    if resp.StatusCode != http.StatusOK {
      return false, errors.New("unknown availability")
    }
    var dto struct {
      Data interface{} `json:"data"`
    }
    dec := json.NewDecoder(resp.Body)
    if err := dec.Decode(&dto); err != nil {
      return false, err
    }
    return dto.Data == nil, nil
  }

: the absence of a data field in the response body indicates the username's availability
: anonymous struct



* Namecheck project: custom Twitter & GitHub types

1. In `twitter` package, declare a `Twitter` type based on an empty struct. We'll add fields to it later.

  type Twitter struct{}

2. Similarly, in the `github` package, declare a `GitHub` struct type.

Now let's talk about methods in Go, so we can turn the `IsValid` and `IsAvailable` functions into methods on the two types we've just declared.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Methods

Live demo in Playground



* Namecheck project: turn IsValid and IsAvailalble into methods

1. In the `twitter` package, turn `IsValid` and `IsAvailable` into methods on the `Twitter` type (use a pointer receiver).

2. Declare a third method named `String` on the `Twitter` type; it should take no parameter and return a string corresponding to the name of the platform: `"Twitter"`.

3. Adjust your tests in `twitter_test.go` and `main.go`.

4. Repeat steps 1-3 for the `github` package.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Interfaces



* Interfaces in a nutshell

Interface are _the_ mechanism for polymorphism in Go.

Contrary to the other types that we've covered, interfaces are abstract types. They're defined by the method(s) that they require:

  type Climber interface {
    Climb(int) error
  }

Convention dictates that single-method interfaces be named by appending "er" to the name of their method, even if it yields a weird name (e.g. `fmt.Stringer`).



* Interface satisfaction in other languages

In many other languages, interface satisfaction is specified on the type declaration of the implementor:

  class PokerHand implements Comparable<? super PokerHand>  // Java
  class Template implements iTemplate                       // PHP
  class BoomerangCollection : IEnumerable                   // C#

Not so in Go!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/liberty.svg 300 _



* Interface satisfaction in Go is implicit

If a concrete type has _all_ the methods required by the interface, it automatically satisfies that interface:

.play -edit src/interface_sat.go /^//START/,/^//END/

Interface satisfaction is verified at compile time (similar to structural typing).



* Tip: keep interfaces small

In a similar spirit as the [[https://en.wikipedia.org/wiki/Interface_segregation_principle][Interface-Segregation principle]] (the "I" in SOLID), you should favor one-method interfaces.

Interfaces that require only one methods are easier to satisfy and more composable (more about that later).
Go's standard library contains many examples of single-method interfaces.

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _



* Notable interfaces

- the empty interface
- `error`
- `fmt.Stringer`
- `io.Writer`
- `io.Reader`
- `http.Handler`

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/arts/ballet.svg 200 _



* Namecheck project: declare a Validator interface

1. At the root of your project, in a file named `namecheck.go`,
declare the following interface:

  type Validator interface {
    IsValid(username string) bool
  }

2. Do `twitter.Twitter` and `github.GitHub` satisfy it? If not, make it so!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: declare an Availabler interface

1. Still in `namecheck.go`,  declare the following interface:

  type Availabler interface {
    IsAvailable(username string) (bool, error)
  }

2. Do `twitter.Twitter` and `github.GitHub` satisfy it? If not, make it so!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: satisfy the fmt.Stringer

1. Study the [[https://pkg.go.dev/fmt#Stringer][documentation]] of the `fmt.Stringer` interface type.

  type Stringer interface {
    String() string
  }

That interface governs how `fmt` functions represent values.

2. Do `twitter.Twitter` and `github.GitHub` satisfy it? If not, make it so!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Interface composition

You can declare an interface type by listing more elementary interfaces:

  type Reader interface {
    Read(p []byte) (n int, err error)
  }

  type Closer interface {
    Close() error
  }

  type ReadCloser interface { // both a Reader and a Closer
    Reader
    Closer
  }

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _



* Namecheck project: declare a Checker interface

1. Still in `namecheck.go`, declare an interface type named `Checker` by composition of

- a `Validator`
- an `Availabler`
- a `fmt.Stringer`

2. Do `twitter.Twitter` and `github.GitHub` satisfy it?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: use a slice of Checkers

1. In your `main` function, create a slice of `Checker` with two elements:

- a pointer to a `twitter.Twitter`
- a pointer to a `github.GitHub`

2. Simplify the existing code by ranging over the slice of `Checker` values.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Favor interface parameters

If possible, take interface types as function parameters, rather than concrete types.

Don't do this:

  type Tree struct {...}
  func (t *Tree) Save(f *os.File) error

Instead, do this:

  type Tree struct {...}
  func (t *Tree) Save(w io.Writer) error

More flexible and easier to test!


* Require no more, promise no less

Only ask for the required behaviour from interface parameters; accept as small an interface as possible.

Don't do this:

  func (t *Tree) Load(rw io.ReadWriter) error

Instead, do this:

  func (t *Tree) Load(r io.Reader) error

This is similar in spirit to the Domain Driven Domain's principle known as
"keeping ports small".



* Using interfaces for test doubles

Interfaces are great for mocking, stubbing, faking, etc.

Ponder this: in Go, you can define an interface for a concrete type you don't own!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/lifting-1TB.svg 300 _



* Namecheck project: mocking the HTTP client

1. Inspect the source code for `http.Get`.

2. In `namecheck.go`, judiciously declare a useful `Getter` interface that `*http.Client` already satisfies.

3. Create a `stub` package and, in `stub.go`, declare the following struct type:

  type SuccessfulGetter struct {
    StatusCode int
  }

4. Make `stub.SuccessfulGetter` satisfy your `namecheck.Getter` interface; its `Get` method should always succeed and return the specified status code

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Namecheck project: mocking the HTTP client (cont'd)

5. Add a field of type `namecheck.Getter` to your `Twitter` and `GitHub` struct types.

6. Adjust your `main.go`.

7. Write a few test cases for the `IsAvailable` method of the `twitter.Twitter` type.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: simulating support for many platforms

1. In `main.go`, populate your `[]Checker` slice with twenty pointers to the same `twitter.Twitter` instance.

2. Repeat step 1 for `github.GitHub`.

3. Run your executable.

4. Comment on user experience (UX). How could we improve things?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/stovepipe-hat-front.svg 200 _



* Concurrency



* What do we mean by "concurrency"?

The art of composing a programme in terms of independent computations

Go has native support (i.e. in the language and runtime) for concurrency.

Go's concurrency model arguably is one of the language's most attractive features,
but can be difficult to learn and master.

.image https://i.stack.imgur.com/QjsGt.png 200 _

: hence being relegated to the end of many learning resources



* Concurrency metaphors

Disclaimer: many cooking metaphors ahead!

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 400 _



* Concurrency is not parallelism

*Concurrency*

- the art of structuring a programme in terms of independenly executing computations
- a property of the programme's code

*Parallelism*

- the simultaneous execution of multiple things on multiple cores
- a property of the running program



* Parallelism is not the goal of concurrency

Concurrency _enables_ parallelism, but parallelism isn't the goal.

Writing concurrent code is valuable regardless of whether that code will run in parallel.

And if good concurrent code _does_ run in parallel, we should get graceful performance improvement for free as the number of cores increase.

See also

- [[https://www.youtube.com/watch?v=oV9rvDllKEg][Rob Pike - Concurrency is not Parallelism (2012)]].
- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=3m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]

: metaphor: cooking recipe typically has a concurrent component, but whether you can prepare it in parallel depends on the number of cooks/hobs you have!



* Go's concurrency model

Largely inspired by [[https://dl.acm.org/doi/10.1145/359576.359585][Tony Hoare's  _Communicating_Sequential_Processes_ (1978)]]

Two fundamental mechanisms:

- goroutines: lightweight threads
- channels: typed pipes used to communicate and synchronize between goroutines

.image https://i.stack.imgur.com/QjsGt.png 200 _



* Goroutines

A goroutine is a concurrent function execution.

It can be thought of as a very lightweight thread: it's common for programmes to have 1000s of goroutines, even on a single core.

The `main` function is itself a goroutine that is created when the programme starts.

Each goroutine gets its own stack, which starts small and grows/shrinks as required.

.image https://go.dev/blog/store/gophers.jpg 300 _



* Goroutines execute in the same address space

For example, a goroutine can pass a pointer to another goroutine, and the latter can dereference that pointer without causing an access violation.

[[https://golang.org/doc/effective_go.html#goroutines][The onus is on you to be careful]] in order to avoid _data_races_!

A [[https://en.wikipedia.org/wiki/Race_condition#Data_race][data race]] occurs when multiple goroutines write to and read from the same memory location in a concurrent fashion (i.e. at the "same" time).

.image http://alinken.people.ua.edu/uploads/8/7/9/2/87929690/published/ghostbusters.jpg


* The Go scheduler

The _Go_scheduler_ is a part of the Go runtime that automatically multiplexes goroutines onto operating-system threads and manages their scheduling for us.

It continually observes the run-time behavior of goroutines and decides to suspends them when they block and then resumes them when they become unblocked.

No need for you to think about it yet; for now, simply picture the Go scheduler and goroutines as a chef and his/her kitchen assistants.

.image https://rrsg.s3.amazonaws.com/wp-content/uploads/2020/03/25180622/90517519_1171371749860657_3506201698723816143_n.jpg 250 _

: scheduler mechanics discussed in the advanced course



* The go keyword

The `go` keyword spawns a new goroutine: it causes the function call that follows it to get executed "in the background".

  go grindCoffeeBeans()
  go frothMilk()

`go` statements return _immediately_.

The result(s) of the function call to which the `go` keyword is applied are lost.

Launching an anonymous function as a goroutine is sometimes convenient for wrapping statements that should be executed in the background:

  go func() {
    fmt.Println("Don't mind me!")
    fmt.Println("I'm just running in the background...")
  }()

: just don't forget to invoke it!
: goroutine terminology: spawning/spawned, parent/child



* Goroutines vs. Unix processes

It's useful to compare goroutines to Unix processes...

The `go` keyword is reminiscent of the ampersand operator (`&`) in Unix shells.

  #!/usr/bin/env sh

  grindCoffeeBeans &
  frothMilk &

However, unlike a Unix process, a goroutine has no concept of an ID (see why [[https://talks.golang.org/2014/go4gophers.slide#38][here]]).

Therefore, a goroutine cannot readily be _killed_.



* The golden rule

Before spawning a new goroutine, you must understand exactly under what conditions it will terminate.

If you're careless and spawn goroutines willy-nilly, you expose yourself to correctness and performance bugs (_goroutine_leaks_).

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Exercise: concurrent coffee making

Write two functions, `grindCoffeeBeans` and `frothMilk`, that

- take no parameters and return no results,
- simply write an informative message to stdout.

Call them concurrently in the `main` function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _

: Q: Which message will be printed first? We can't tell. Up to the scheduler.



* Exercise: concurrent coffee making (first attempt)

.play -edit src/goroutines_without_waitgroup.go /^//START/,/^//END/

Does the programme behave as you expected? Why or why not?



* main does not wait!

Nothing gets written to stdout because

- the two `go` statements _immediately_ transfer control back to `main`, and
- `main` terminates _before_ your two goroutines themselves terminate!

We need a way to tell `main` to "wait" until the two goroutines terminate.

Any ideas?



* Exercise: concurrent coffee making (with sleep)

Sleep a bit at the end?

.play -edit src/goroutines_with_sleep.go /^//START/,/^//END/

However, this solution is not entirely satisfactory. Why?

: inefficient at best, nondeterministic at worst



* Sleeping is not the answer

How long should the sleep be, exactly? Impossible to know in advance.

- Wait too little: `main` terminates too quickly for all the other goroutines to terminate.
- Wait too long: `main` ends up needlessly spinning and wasting time.

.image https://drek4537l1klr.cloudfront.net/youngman/Figures/f0255-01.jpg 200 _

Sleeping is simply not a reliable and efficient way of coordinating goroutines!

We need another mechanism...

: there are legitimate use cases for `time.Sleep` in a Go programme, but...



* Wait groups

The [[https://pkg.go.dev/sync/#WaitGroup][`sync` package]] provides a mechanism for orchestrating goroutines: _wait_groups_.

Wait groups are particularly useful when the number of goroutines to spawn is not known in advance.

: e.g. if you're spawning a goroutine for each line of a file that you're reading, or for each element received from a channel



* Declaring a wait group

Because the zero value of `sync.WaitGroup` is readily usable, you can simply write

  var wg sync.WaitGroup

Alternatively, if you want a `*sync.WaitGroup`, write

  wg := new(sync.WaitGroup)     // equivalent to &sync.WaitGroup{}



* Operations on a wait group

A wait group is little more than a glorified counter with _concurrency-safe_ operations.

- `wg.Add(n)` increments the counter by n (>0).
- `wg.Done()` decrements the counter by 1. It's equivalent to `wg.Add(-1)`.
- `wg.Wait()` blocks until the counter goes back to 0; it acts as a [[https://en.wikipedia.org/wiki/Barrier_(computer_science)][_barrier_]].



* How to use a wait group

Call `wg.Add(1)` _just_before_ spawning a goroutine.

Call `wg.Done()` _at_the_very_end_ of each child goroutine (use `defer`!).

Call `wg.Wait()` in the spawning goroutine to wait for all child goroutines to terminate.



* Exercise: concurrent coffee making (using a wait group)

Use a wait group to make `main` wait until both `grindCoffeeBeans` and `frothMilk` have terminated before `main` itself can terminate.

Tip: you can apply the `go` keyword to an anonymous function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _



* Exercise: concurrent coffee making (using a wait group)

(implementations of `grindCoffeeBeans` and `frothMilk` are as before)

.play -edit src/goroutines_with_waitgroup.go /^//START/,/^//END/

: don't forget the pair of parens at the end of each function literal!
: What happens if I remove a wg.Done()? deadlock
: What happens if I remove a wg.Add(1)? only one of the two goroutine will likely have time execute



* How not to misuse wait groups

Calls to `wg.Add` must take place in the spawning goroutine, _not_ within the child goroutine.

The call to `wg.Wait` must happen _after_ all calls to `wg.Add` (otherwise: data race).

If a function needs a wait group declared elsewhere, pass a pointer to it (`*sync.WaitGroup`) as an argument to the function.

.image https://go.dev/blog/gopher/plush.jpg 300 _

: if wg.Add concurrent with wg.Wait, data race: https://go.dev/play/p/PPlY-M7yfYh



* Closures running as goroutines: spot the bug

Can you spot the bug in the following programme?

.play -edit src/goroutine_func_quiz.go /^//START/,/^//END/

: ask them first how they expect the programme to behave
: sometimes prints 10, not 9! because loop variable goes beyond bound before loop can end



* Closures running as goroutines: explanation

There is a _data_race_: a variable is being read and updated by different goroutines in a concurrent fashion!

More specifically, the goroutines spawned by `printTenIntsConcurrently` _capture_ and read loop variable `i` as it's being updated by the loop.

.play -edit src/goroutine_func_answer.go /^//START/,/^//END/

Consequently, the programme is undeterministic: the results are unpredictable.



* Detecting the data race

We've identified the data race by inspection, but some static- and dynamic-analysis tools can help.

*go*vet*

This subcommand analyzes the code and can detect issues that the compiler does not.

Try running `go` `vet` on the programme.

*race*detector*

The Go CLI provides a [[https://go.dev/blog/race-detector][race detector]], i.e. a tool that can detect data races during execution.

Try running the programme with the `-race` flag.

Caution: the race detector is [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][not guaranteed to catch all data races]].



* Fixing the data race

One way to fix the data race consists in shadowing the loop variable inside the loop, before the `go` statement.

.play -edit src/goroutine_func_redecl.go /^//START/,/^//END/

Although the redeclaration looks a bit weird, this solution has merit insofar as the fix is colocated with the start of the `go` statement (reduced cognitive load).

See also the [[https://golang.org/doc/faq#closures_and_goroutines][Golang FAQ about this]].

: kind of awkward to pass them as parameters further down if the anonymous function is long



* Fixing the data race

An alternative solution consists in passing the value of the loop variable as an argument to the anonymous function.

That way, by virtue of Go's call-by-value evaluation strategy, the function only has access to a copy of the loop variable's value at the time of the iteration of interest.

.play -edit src/goroutine_func_arg.go /^//START/,/^//END/


* Be careful when running closures as goroutines

When running a closure as a goroutine, it's very easy to inadvertently capture variables, which may cause data races.

Defining a dedicated named function can help:

.play -edit src/goroutine_func_standalone.go /^//START/,/^//END/



* Namecheck project: check concurrently

Rather than checking the username on each platform sequentially, do so concurrently.

Does the user experience improve?



* Namecheck project: aggregate the results (how?)

What if, instead of printing the results, we wanted to somehow aggregated them?

Remember: the result(s) of the function call to which the `go` keyword is applied are lost.

We need a way to communicate between goroutines...

.image https://go.dev/blog/gopher/plush.jpg 300 _



* Channels



* Sharing is caring

Because goroutines all execute in the same address space, programs that modify data being simultaneously accessed by multiple goroutines [[https://golang.org/ref/mem#tmp_1][*must* serialize such access]].

Programs that ignore this injunction are bound to contain [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][_synchronization_bugs_]], which may manifest as _data_races_...


.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Share memory by communicating

Rather than using locks to synchronize goroutine access to the shared memory, Go encourages an approach in which shared values are passed around on _channels_.

The Go community [[https://golang.org/doc/effective_go#sharing][summarizes this powerful idea]] through a slightly cryptic mantra:
[[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=2m42s][_Do_not_communicate_by_sharing_memory;_instead,_share_memory_by_communicating._]]

Compared to their lower-level alternatives alternatives, channels are indeed often

- more elegant,
- more composable,
- less error-prone.

As Rob Pike puts it: [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=4m20s][channels orchestrate; mutexes serialize]].



* Channels are typed

Channels are typed conduits that allow goroutines to synchronize and exchange information.

The element type of a channel is arbitrary.

A channel whose element type is `T` has type `chan`T`.

  var ch chan string // channel of strings

: channels only exist within the confines of your programme; they can't be used to communicate between different processes, be they written in Go.



* Popular naming choices for channels

"c" or "ch", on its own or as a suffix (with or without camelcase):

  var c chan int
  var ch chan string
  var errc chan error
  var taskCh chan Task

Plural of the channel's element type:

  var tasks chan Task

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _



* Channels are first-class values

You can pass a channel to a function:

  func Aggregate(results chan Result) Result { /* ... */ }

You can return a channel from a function:

  func Generate(upTo int) chan int { /* ... */ }

You can store a channel in a struct type:

  type Request struct {
      fn func() int  // The operation to perform.
      c  chan bool    // The channel to return the result.
  }

Channels are comparable.




* Initializing a channel

Channels are reference types; their zero value is `nil`.

To initialize a channel, use built-in function `make` with two arguments:

- the first argument corresponds to the type of the channel;
- the second argument is an (optional) `int` corresponding to the channel's desired (non-negative) _capacity_.

  c1 := make(chan string) // equivalent to make(chan string, 0)
  c2 := make(chan string, c)

A channel's capacity cannot be changed after initialization.

A freshly initialized channel starts its life in an "open" state, but can later be _closed_.

: The specified capacity (if any) must be non-negative; otherwise, you'll get a compilation error or, worse, a panic.



* Channel capacity

A channel's capacity corresponds to the size of its _buffer_, i.e. the number of elements it can contain at a give time.

Choosing it wisely is important, as it usually affects the correctness and/or the performance of your programme.

Built-in function `cap` can be used to query a channel's capacity:

  c := make(chan string, 20)
  fmt.Println(cap(c)) // 20

Some terminology:

- A channel of zero capacity is said to be _unbuffered_ or _synchronous_.
- A channel of positive capacity is said to be _buffered_.

: The number of elements queued in a channel's buffer can also be queried via built-in function `len`, but is rarely useful. Why?
: if more than one goroutine interact with the channel, len(ch) is stale as soon as queried
: increasing buffer size may help reduce pressure on the Go scheduler



* A kitchen serving-hatch as a metaphor

Think of goroutines as cooks and waiters on either side of a serving hatch,
which represents a channel.

The channel's capacity corresponds to the number of plates that can fit
on the serving hatch's platform at any one time.

.image https://josephdmcnamee.files.wordpress.com/2012/01/serving-hatch1.jpg 350 _

: what does a channel of capacity 0 correspond to?
: the analogy is imperfect because channels are FIFO and waiters don't necessarily pick up plates in the order in which they arrived



* Choose the capacity of your channels wisely

Choosing the capacity of a channel can be delicate!

In some cases, that choice directly impacts program correctness. If you choose unwisely, the program will typically deadlock or won't produce the correct results.

In other cases, it has no impact on correctness, but an unwise choice causes some _goroutine_leaks_, which in turn can cause performance degradation and even crashes.

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Choose the capacity of your channels wisely (cont'd)

In yet other cases, that choice has no impact on correctness or on the occurence of goroutine leaks, but it affects performance.

In such cases, you should profile your program under realistic load in order to determine a good value to use.

Such performance optimization is covered in [[https://www.humancoders.com/formations/go-avance#outline][the next course]].

.image https://go.dev/blog/5years/gophers5th.jpg 300 _




* Operations on a channel

Channels support the following operations:

- _sending_ a value to a channel,
- _receiving_ a value from a channel,
- _closing_ a channel (that hasn't been closed yet).

You can also _range_ over a channel, which consists in continually receiving values from it.

All those operations are *concurrency-safe*.

: _Channel_communications_ is a general term for describing both channel sends and receives.
: we'll see why closing a channel is useful soon



* Sending to a channel

The syntax of a _channel_send_ consists in the name of the channel in question
followed by a left-pointing arrow (`<-`) followed by the value to send.

  ch := make(chan string)
  // ...
  v := "superimportant message"
  ch <- v

The `gofmt` tool will adds a space on either side of the arrow; don't fight it.

A channel send is a statement, not an expression.



* Semantics of a channel send

.image img/send_semantics.svg _ 900

Note: buffered channels accept a limited number of values without a corresponding receive for those values.



* Receiving from a channel

The syntax of a _channel_receive_ consists in a left-pointing arrow (`<-`) followed by the channel in question.

  ch := make(chan string)
  // ...
  <-ch

The `gofmt` tool removes any whitespace between the arrow the channel; don't fight it.

A channel receive is an expression: you can store the received value in a variable,
or pass it to a function.

  v := <-ch
  fmt.Println(v)

The value received is only a copy of the value that was sent to the channel.



* Semantics of a channel receive

.image img/receive_semantics.svg 450 _

Note: the value received from a channel by a goroutine is only accessible to that goroutine; it is removed from the channel for all the other goroutines.



* Exercise: fixing a deadlock

.play -edit src/deadlock_example.go /^//START/,/^//END/

This programme deadlocks. Can you guess why? How would you fix it?

Add sends and receives to fix ideas. Discuss.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: ask them what happens for go fmt.Println(<-ch)



* Receive ambiguity

As shown by the diagram on the previous slide, when a channel is closed and empty, receiving from that channel yields the zero value of the channel's element type...

How can we tell whether the value we're receiving is from a closed channel or whether someone really sent a zero value of the element's type to the channel?

.image https://go.dev/blog/gopher/plush.jpg 300 _



* Dispelling the ambiguity

There is a special form of channel receive that yields an additional boolean value (named "ok", by convention):

   v, ok := <-ch


The value of variable `ok` is

- `true` if the value received was delivered by a send operation to the channel, or
- `false` if it is a zero value generated because the channel is closed and empty.

Note: variable `ok` is assigned the value `false`, not as soon as the channel gets closed, but only when the channel has been drained.



* Closing a channel

A freshly initialized channel starts its life in an "open" state.

  ch := make(chan string) // ch is open (until closed)

You can close a channel to indicate that no more values are to be added to it:

  close(ch)

Closing a channel is definitive; a closed channel cannot be "re-opened".



* Semantics of close

.image img/close_semantics.svg _ 800

Note:

- Closing the nil channel causes a panic.
- Closing an already closed channel causes a panic.



* How is closing a channel useful?

*Terminating*a*range*operation*

If you range over a channel and no additional values get sent to it, the range expression will block until you close the channel.

*Broadcasting*a*signal*

Because closing a channel unblocks all receives from that channel, it can be used to broadcast a signal to multiple goroutines!

In fact, the [[https://pkg.go.dev/context/][`context` package]] is [[https://vimeo.com/115309491#t=10m][based on this idea]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/projects/go-grpc-web.svg 200 _

: you could use break to terminate the loop during an iteration, though



* Do not systematically close channels

Channels are not resources; closing a channel is not a way to reclaim or clean up resources (memory, etc.).

Channels will get garbage-collected like any other variable once they become unreachable.

You only need to close a channel if the semantics of your programme demand it.




* Closing a channel doesn't drain it

Think of a restaurant as a channel.

- Announcing the end of service doesn't mean pushing all the patrons out; they can finish their meal before leaving.
- Similarly, closing a channel doesn't amount to flushing it out; some goroutine(s) can still consume those elements.

.image https://rew-online.com/wp-content/uploads/2019/10/restaurantCLOSED.jpg 300 _



* Ranging over a channel

Ranging over a channel amounts to iteratively receiving from it:

  for v := range ch {
    // do something with v
  }

Variable `v` takes the successive values sent on the channel until the channel is both closed and empty.

The code above is an exact equivalent to the following:

  for {
    v, ok := <-ch
    if !ok {
      break
    }
    // do something with v
  }



* Ranging over a channel blocks until the channel is closed

A for-range loop on a channel will only terminate if and after the channel gets closed!

.play -edit src/range_blocks_until_channel_closed.go /^//START/,/^//END/



* Reminder: channels are reference types

Operating on a copy `cb` of a channel `ca` affects the same underlying data structure as if you operated on channel `ca` directly.

.play -edit src/channels_are_references.go /^//START/,/^//END/

(If that weren't the case, channel function parameters wouldn't be very useful;
those parameters would instead need to be pointers to channels.)



* Namecheck project: gather the results via a channel

1. At the top of `main.go`, declare the following `Result` type:

  type Result struct {
    Username  string
    Platform  string
    Valid     bool
    Available bool
    Err       error
  }

2. In `main`, initialize a `chan`Result`; make sure it's accessible to the child goroutines.

3. In each child goroutine, create a `Result` value and send it to the channel.

4. In `main`, range over that channel and store the results in a slice, then print it.

.image https://go.dev/blog/store/gophers.jpg 150 _

: the channel allows us to serialize access to the slice (local mutable state)



* Channel directions

You can mark a channel as _send-only_ or _receive-only_ by adding the optional `<-` operator on the right or left (respectively) of the `chan` keyword.

This is particularly useful for locally restricting the operations possible on a channel parameter within a function:

  func produce(c chan<- string) {} // c is send-only within produce
  func consume(c <-chan string) {} // c is receive-only within consume

You can pass a bidirectional channel wherever a unidirectional channel is expected.

The compiler disallows

- receiving from a send-only channel, and
- sending to or closing a receive-only channel.



* Channel directions: example

.play -edit src/channel_dir.go /^//START/,/^//END/



* Why use unidirectional channels

Unidirectional channels are great for

- clarifying the role of a channel within a function,
- increasing your confidence in the correctness of your code.

Use them liberally, wherever possible.

However, in cases where a function [[https://talks.golang.org/2012/10things.slide#10][legitimately needs to both send to and receive from a channel]], a bidirectional channel is needed.



* Namecheck project: use unidirectional channels

Review the functions that accept a channel parameter, and determine whether a channel direction could have been specified.

.image https://go.dev/blog/gopher/plush.jpg 400 _



* Select statement

The `select` keyword forms a trifecta with goroutines and channels!

A `select` statement is a multiway concurrent control switch: it allows you to select one of several channel communications (send or receive).

.image https://pbs.twimg.com/media/DDWqkrFUMAAbIyL?format=png&name=large 300 _



* Mechanics of select

  select {
  case v, ok:= <-ch1:
    // do something with v and ok
  case ch2 <- 42:
    // ...
  default:
    // ...
  }

- Each of the "normal" (non-default) cases correspond to a channel communication (send or receive).
- The first normal case that can proceed gets selected.
- If more than one normal cases can proceed, one of them is chosen in a uniform pseudo-random fashion.
- If no normal case can proceed, the default case (if any) gets selected; otherwise, the `select` statement blocks.



* For-select loop

`select` is often used in conjunction with `for` to form an "event loop":

  for someCondition {
    select {
    case v, ok := <-results:
      // ...
    case  err, ok := <-errc:
      // ...
    }
  }



* Namecheck project: fail early

1. Remove the `Err` field from your `Result` type

2. Modify your code to report normal results and errors through separate channels.

3. Use a `select` statement to receive from both channels.

4. Terminate the programme as soon as one error is received

Hint: choose channel capacity wisely.

.image https://go.dev/blog/gopher/plush.jpg 250 _



* Canceling goroutines

Spawning goroutines is easy, but making sure they terminate sometimes requires more effort. One common recipe for canceling a goroutine consists of

- a `select` statement
- a channel of type `<-chan`struct{}` (commonly named "quit" or "done")

  func cancellable(quit <-chan struct{}) {
    for {
        select {
        case <-quit:
          return
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

If function `cancellable` is launched as a goroutine, another goroutine can get it to terminate by sending to or closing the `quit` channel. Why?



* Exercise: render a function cancellable

.play -edit src/uncancellable.go /^//START/,/^//END/

Function `printInts` never terminates! Modify the program to make `printInts` cancellable from `main`. Cancel the goroutine after one second.

You can do this exercise in the [[https://go.dev/play/p/uNLmiVb_1rY][Go Playground]].



* Exercise: render a function cancellable (solution)

The solution is available on the [[https://go.dev/play/p/RBbA2DCWmu2][Go Playground]].

: mention that closing the channel broadcasts a signal to all goroutines that receive from it



* Canceling goroutines with context

The `context` package formalizes this idea of broadcasting a signal by closing a channel.

It exports an interface type named `Context` that is convenient for terminating goroutines via cancellation and/or timeouts.

`Context`'s cancellation mechanism is based on the same quit-channel trick; the channel is accessible via `Context`'s `Done` method:

  func cancellable(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
          return
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

By convention, the `context.Context` parameter (if any) is always first.



* Exercise: cancelling a goroutine with context.Context

Browse the documentation of [[https://pkg.go.dev/context/][the `context` package]], and modify the solution to the previous exercise to use a `context.Context` rather than a `quit` channel.

You can do this exercise in the [[https://go.dev/play/p/RBbA2DCWmu2][Go Playground]].

: extra exercise: make IsAvailable cancellable



* Exercise: cancelling a goroutine with context.Context (solution)

The solution is available on the [[https://go.dev/play/p/XXH76YKz_Oj][Go Playground]].



* Exercise: debug this ping-pong game

1. Open [[https://go.dev/play/p/n7XQ_TdOY4t][this Playground]] (adapted from [[https://talks.golang.org/2013/advconc.slide#6][a talk by Sameer Ajmani]]). The program models a simple ping-pong game.

2. The game ends with a deadlock. Can you see why?

3. Discuss and fix the programme.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: two goroutines exchanging one value over and over
: pointer element to reduce memory footprint
: show that deadlock if you never throw the ball on the table
: one player terminates while the other is left holding the ball
: one possibility: buffer size of 1, but no guarantee that the same player will play twice in a row
: non-blocking send by adding a select statement



* Exercise: debug this ping-pong game (solution)

The solution is available on the [[https://go.dev/play/p/RVdBZVVbkj3][Go Playground]].



* HTTP server



* Namecheck project: turn your CLI tool into a Web server

Create a `server` folder under `cmd` and copy `cmd/cli/main.go` to `cmd/server/main.go`.

  namecheck
  ├── cmd
  │   ├── cli
  │   │   └── main.go
  │   └── server
  │       └── main.go
  ├── github
  │   ├── github.go
  │   └── github_test.go
  ├── go.mod
  ├── namecheck.go
  └── twitter
      ├── twitter.go
      └── twitter_test.go



* Namecheck project: turn your CLI tool into a Web server

1. Start from [[https://pkg.go.dev/net/http#example-ListenAndServe][https://pkg.go.dev/net/http#example-ListenAndServe]].

2. Adapt the code from the CLI executable to your server

3. Define a `/check` route that accepts a username to test as a query parameter.

4. Return JSON in the response (see [[https://pkg.go.dev/encoding/json/][encoding/json]]), with the correct content type.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: http.HandleFunc registers the handler on the DefaultServeMux (package-level variable)
: ListenAndServe: it last arg is nil, serves the DefaultServeMux
: important to capture error from http.ListenAndServe, because otherwise fails silently if port collision (e.g. ":80")



* Namecheck project: use a third-party package for routing

We'll use [[https://github.com/gorilla/mux][gorilla/mux]], a popular alternative to `net/http` for defining routes.

To download the dependency, run the following command at the root of your project:

  go get github.com/gorilla/mux

Doing so will also update your `go.mod` file and create a `go.sum` file.

Import `gorilla/mux` in your server's `main.go` and redefine your route with it.

: we don't really need mux here; nothing fancy; just for practice



* Maps

A map is a built-in type that represent a unordered collection of key-value pairs.

The type of a map of keys of type `K` and values of type `V` is denoted by `map[K]V`.

The key type *must* be comparable:

.play -edit src/incomparable_key_type.go /^//START/,/^//END/

.image https://golangforall.com/assets/dvoe.svg 150 _

: implemented as a hash table



* Maps are reference types

A function that takes a parameter of some map type only gets a copy of a reference
to the underlying data structure (hash table).

The zero value of map types is `nil`.

Map types are *not* comparable.

.play -edit src/map_reference.go /^//START/,/^//END/



* Creating map values

Invoke built-in function `make` with the desired map type to initialize an empty map:

.play -edit src/map_make.go /^//START/,/^//END/

Alternatively, you can create and populate a map with a _map_literal_:

.play -edit src/map_literal.go /^//START/,/^//END/

The trailing comma is mandatory, here.



* Accessing a value associated with a key in a map

`m[k]` yields the value corresponding to a key `k` in a map `m`.

`m[k]` is *not* addressable!

If the key is absent from the map or if the map is `nil`, the zero value of the map's value type is returned.

To determine whether the key is value is present in the map, you can declare an additional variable (commonly named "ok" or "exists") of boolean type.

.play -edit src/map_access.go /^//START/,/^//END/

: yields the actual value: you can operate on m[k] directly (e.g. m[k]++ if map value type is integer)



* Storing a key-value pair in a map

Associating a key `k` with a value `v` in a map `m` is simple:

  m[k] = v

If the key was already present in the map, the value associated with it prior is lost.

Attempts to store a value in a `nil` map cause a panic!

.play -edit src/map_store.go /^//START/,/^//END/



* Removing a key-value pair from a map

To remove a key `k` and its value from a map `m`, use built-in function `delete`:

  delete(m, k)

If the map is `nil` or if the key is already absent from the map, deleting the key from the map is a no-op.

.play -edit src/map_delete.go /^//START/,/^//END/



* Ranging over a map

You can iterate over a map using `for` and `range`:

.play -edit src/map_range.go /^//START/,/^//END/

At each iteration, the variables yielded by the `range` expression hold copies of
the key and value.

Maps are unordered collections. Not only is the iteration order unspecified, but it is also undeterministic! Try running the code snippet above a few times: the iteration order will typically change from one program execution to the next.



* Ranging over a map in a deterministic order

To range over a map in a certain order, you must

- collect all map keys in a slice,
- sort the slice as desired,
- access the map values as you range over the sorted slice of keys.

.play -edit src/map_range_deterministic.go /^//START/,/^//END/



* Implementing a set using a map

Go provides no native set types, but.. maps to the rescue!

You can implement a set of `string` simply as a map[string]bool:

.play -edit src/map_set_bool.go /^//START/,/^//END/

A more memory-efficient alternative is to use a `map[string]struct{}`:

.play -edit src/map_set_nothing.go /^//START/,/^//END/

Pick whichever of the two approaches you prefer.



* Don't insert entries in a map while ranging over it

You can of course mutate values associated to a key that is already present in the map.

However, inserting new keys in a map while ranging over it yields [[https://golang.org/ref/spec#For_range][undefined behavior]]!

.play -edit src/map_insert_while_ranging.go /^//START/,/^//END/

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 200 _

: If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped.
: The choice may vary for each entry created and from one iteration to the next.



* Don't remove entries unrelated to the current iteration

If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced.

Because of [[https://golang.org/ref/spec#For_range][this documented behavior]] and because iteration order on maps is random,
removing entries unrelated to the current iteration causes undesired *undeterminism*.

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Don't remove entries unrelated to the current iteration (cont'd)

Consider the following program:

.play -edit src/map_delete_while_ranging.go /^//START/,/^//END/

From one execution to the next, the output may be either

  map[baz:3 foo:1]

or

  map[bar:2 baz:3]



* Namecheck project: count of checks per username

Keep track (in memory) of how many times each username has been checked.

- What data structure seems appropriate?
- Create an additional `/stats` route that returns a JSON representation of the data structure in question.

Discuss.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Maps are not concurrency-safe!

The HTTP server provided by `net/http` is concurrent: it handles each incoming request in a separate goroutine.

However maps are *not* concurrency-safe: carelessly updating a map from multiple goroutines yields unpredictable results!

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Maps are not concurrency-safe! (cont'd)

.play -edit src/map_not_concurrency_safe.go /^//START/,/^//END/



* Communicating by sharing memory

Go encourages you to use channels to communicate between goroutines.

However, sometimes, sharing memory is simpler and/or performant.

We'll cover two facilities for sharing memory:

- [[https://en.wikipedia.org/wiki/Mutual_exclusion][mutual exclusions]], provided by [[https://pkg.go.dev/sync/][the `sync` package]],
- synchronized operations on fixed-sized integers from [[https://pkg.go.dev/sync/atomic/][the `sync/atomic` package]].



* Namecheck project: count of checks per username

1. Study the documentation of `sync.Mutex`.

2. Guard reads and writes to the map with a mutex.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Conclusion



* What we haven't covered

We're nearing the end of the course.

You've learned a lot, but there is [[https://www.humancoders.com/formations/go-avance][more]]!

.image https://go.dev/blog/store/gophers.jpg 400 _



* Open discussion


* Image credits

TODO



* Appendix A: Strings



* Bytes, code points, characters

Three distinct concepts are at play with strings in Go: _bytes_, _code_points_, and _characters_.

*Bytes*

- A byte is made up of 8 bits. Duh!

*Code*points*

- Also known as "runes" in the Go world.
- A code point simply corresponds to a place in the Unicode alphabet.

*Characters*

- Also known as "glyphs".
- A character is made up of one or mode code points.

See [[https://go.dev/blog/strings][Rob Pike - Strings, bytes, runes and characters in Go (Golang blog)]]



* Runes

The predeclared `rune` type is a 32-bit integer type that represents a Unicode code point.
Unsurprisingly, its zero value is `0`.

Rune literals are delimited by single quotes. Escape sequences (`'\u00e9'`) are possible.

In UTF-8, a rune is encoded as a sequence of 1 to 4 bytes.

.play -edit src/rune_bytes.go /^//START/,/^//END/

The `rune` type is an alias of type `int32`. The two types are interchangeable.



* Characters

You're used to reading characters on a computer screen, but the Unicode concept of _character_ is harder to grasp than you might think!

Note in particular that

- a character can be made up of more than one code points, and
- a given character can have multiple representations.

For instance, the character `é` can be represented either by

- a single code point named [[https://unicode-table.com/en/00E9/][_Latin_Small_Letter_E_with_Acute_]], or by
- the combination of a [[https://unicode-table.com/en/0065/][_Latin_Small_Letter_E_]] and an [[https://unicode-table.com/en/00B4/][_Acute_Accent_]] (a _combining_code_point_):

.play -edit src/characters.go /^//START/,/^//END/



* The string type: zero value and literals

The `string` type's zero value is simply the empty string.

String literals come in two forms:

*Interpreted*string*literals*

- delimited by double quotes (`"`)
- the most common form
- guaranteed to contain valid UTF-8 (if they do no contain byte-level escapes)

*Raw*string*literals*

- delimited by backticks (```)
- escape sequences are not applied
- can be multiline
- guaranteed to contain valid UTF-8


: string literals always contain UTF-8 text as long as they have no byte-level escapes
: Go source code is UTF-8, so the source code for the string literal is UTF-8 text
: useful for regexp, templates, multiline strings



* The string type's zero value and string literals

.play -edit src/string_literals.go /^//START/,/^//END/



* The string type: under the hood

A string is _not_ stored in memory as a sequence of runes, but as a more compact sequence of bytes that (usually) represent valid UTF-8 text.

More specifically, a string is a two-word immutable data structure made up of

- a pointer to a byte array,
- an integer corresponding to the number of bytes that make up the string.

For instance, the string `"Hello,`World!"` is represented in memory as follows:

.image img/strings_two_words.svg 200 _



* String indexing

`s[i]` returns the `i`-th *byte* (not rune or character!) using 0-based indexing in string `s`.

If `i` is either negative or larger than `len(s)-1`, then `s[i]` causes a _panic_!

Overwriting `s[i]` or taking its address is illegal and will cause a compilation error.

.play -edit src/string_indexing.go /^//START/,/^//END/



: panic is a runtime error
: also substring operator, but similar to slicing operator which we'll see later



* Ranging over a string

A for-range loop decodes one UTF-8-encoded *rune* (not character!) on each iteration:

.play -edit src/string_range.go /^//START/,/^//END/

In the code above, during each iteration of the loop,

- `i` corresponds to the starting position of the current rune (measured in bytes),
- `r` corresponds to the current rune.



* Other operations on strings

As in many other languages, the plus sign is used for string concatenation.

Built-in function `len` returns the number of *bytes* in a string, whereas
function `utf8.RuneCountInString` returns the number of *runes* in a string.

.play -edit src/strings_etc.go /^//START/,/^//END/

Other useful functions for manipulating strings are can be found in packages `unicode/utf8`, `strings`, `strconv`, `fmt`, and `regexp`.



