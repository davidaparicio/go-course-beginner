Formation Go
10 November 2023

Julien Cretel

jcretel-infosec@protonmail.com

https://jub0bs.com

@jub0bs.bsky.social
https://infosec.exchange/@jub0bs



* About this slidedeck

*Licence*

These slides are freely available at [[https://github.com/jub0bs/go-course-beginner]] and are subject to a [[https://creativecommons.org/licenses/by-nc-sa/3.0/][CC BY-NC-SA 4.0 licence]].

*Why*English*rather*than*French?*

The French terminology about Go concepts isn't firmly established yet; for instance, some people translate _slice_ (which is a Go data structure) to _coupe_ and others to _tranche_.

Moreover, most of the Go learning resources available online are in English.

*How*to*run*these*slides*locally*

[[https://github.com/jub0bs/go-course-beginner/blob/main/README.md][The README]] constains instructions for running the slides with [[https://pkg.go.dev/golang.org/x/tools/cmd/present][a Go-specific tool]].

Some of these slides contain editable and executable code snippets. If you need to add a line break somewhere in a code snippet, make sure [[https://github.com/golang/go/issues/9011][to type Shift + Enter]].



* About me

- known as @jub0bs on the Web
- self-employed since 2019
- Go developer since 2017
- Web-security researcher & consultant
- occasional bug-bounty hunter
- trainer on topics such as [[https://www.humancoders.com/formations/go][Go]] and [[https://www.humancoders.com/formations/securite-des-applications-web][Web security]]
- blogger (at [[https://jub0bs.com][jub0bs.com]])

.image https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png 200 _

: pentests, vulnerability evaluation, code audits
: present yourselves!



* Setup

If you haven't already, install Go by following the guidance from [[https://go.dev/dl]].

You can check which version of Go is installed by running the following shell command:

  $ go version
  go version go1.21.4 darwin/amd64

To cut your teeth on Go, I recommend [[https://code.visualstudio.com/][Visual Studio Code]] and its [[https://code.visualstudio.com/docs/languages/go][Go extension]], which embarks a number of utilities such as `goimports` and `gofmt`.

Also, make sure you have Git installed.



* Rough course outline & expected difficulty curve

.image img/difficulty_vs_time.svg 400 _



* Namecheck project

You'll develop a small command-line tool (and later a HTTP API) for checking the *validity* and *availability* of a username on multiple social networks: GitHub, etc.

Over the years, I have found this project to be a good forcing function for learning Go.

Moreover, there is a [[https://twitter.com/marckohlbrugge/status/1682064001331609615][business case]] for such a tool, as it would allow organizations and even individuals to choose a brand name consistent across multiple platforms.

: see Poppulo's case on X/Twitter: https://twitter.com/poppulo

.image https://go.dev/blog/gophergala/fancygopher.jpg 200 _

Besides, if you're ðŸ˜ˆ, you may find this tool useful for [[https://en.wikipedia.org/wiki/Cybersquatting#Social_media][name squatting]]. Be aware that this practice is [[https://docs.github.com/en/site-policy/other-site-policies/github-username-policy][prohibited by GitHub]] and most of the other social networks, though.

: discover a coveted username that's available on some platform, claim it for yourself and later sell it to an interested party



* Genesis of the language

Go was created in 2007 at Google by

- *Robert*Griesemer* (worked on [[https://en.wikipedia.org/wiki/V8_(JavaScript_engine)][V8]] and [[https://en.wikipedia.org/wiki/HotSpot_(virtual_machine)][the HotSpot JVM]], studied with [[https://en.wikipedia.org/wiki/Niklaus_Wirth][Niklaus Wirth]]),
- *Rob*Pike* (worked on [[https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs][Plan 9]], [[https://en.wikipedia.org/wiki/UTF-8][UTF-8]], and experimental predecessors to Go), and
- *Ken*Thompson* (worked on [[https://en.wikipedia.org/wiki/Unix][UNIX]], [[https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs][Plan 9]], [[https://en.wikipedia.org/wiki/UTF-8][UTF-8]], [[https://en.wikipedia.org/wiki/Turing_Award][Turing Award]] recipient)

.image https://miro.medium.com/max/1256/0*pCC5UI7QqThjdBvm.png _ 600

: Pike/Thompson: former Bell Labs employees
: Pike: predecessors to Go (Newsqueak, Alef, Limbo)
: Thompson: invented increment/decrement operators; see https://en.wikipedia.org/wiki/B_(programming_language)#History



* Genesis of the language (cont'd)

Back in 2007, C++'s increasing complexity, slow compilation, and poor support for concurrency were [[https://www.youtube.com/watch?v=i0zzChzk8KE&t=545s][recurring sources of frustration]] for the two Roberts at Google,
where C++ is heavily used for implementing distributed systems.

.image https://imgs.xkcd.com/comics/compiling.png 180 _

They enlisted the help of Ken Thompson and started working on a new language, which ultimately became Go... For more on the origins of Go, see

- [[https://www.youtube.com/watch?v=YXV7sa4oM4I][Rob Pike - The Go Programming Language and Environment]]
- [[https://www.youtube.com/watch?v=6oF0UblqkGs&t=465s][Carmen Andoh - 10 Years of Go (GopherConAU 2019)]]
- [[https://www.youtube.com/watch?v=igFz-5rdn2Y&t=85s][Cameron Balahan - Keynote: The State Of Go (GopherCon Europe 2023)]].




* A brief history of Go

- 2007: Griesemer, Pike & Thompson start working on Go.
- ----: Ian Lance Taylor & Russ Cox (both from Google) join the Go team.
- 2009: Go is open-sourced.
- 2012: Go 1.0 is released. The language becomes stable. Adoption rises sharply.
- 2013: Docker
- 2014: Kubernetes; first GopherCon conference
- 2015: The go compiler (`gc`) becomes self-hosted.
- 2022: Go 1.18 adds generics to the language.
- 2023: Go 1.21 (the latest version) is released.

: Russ joined the Go Team between 2007 and 2009: https://research.swtch.com/back


* Logo & mascot

Go's logo may strike you as rather uninspired and unremarkable:

.image https://go.dev/blog/go-brand/logos.jpg 150 _

However, [[https://go.dev/blog/gopher][Go's mascot]], a [[https://en.wikipedia.org/wiki/Gopher][gopher]], enjoys worldwide recognition:

.image https://go.dev/blog/gopher/gopher.png 150 _

In fact, Go programmers are affectionately known as "Gophers".

: Lapins CrÃ©tins vibe!



* What kind of language is Go?

: Although Go has its roots in C, it is in many ways a more powerful language.

*Concurrent*programming*

Go's [[https://en.wikipedia.org/wiki/Concurrent_computing][concurrency]] features let you cleanly delineate independent tasks in your code.

*Object*orientation*

The ability to define custom types (and methods on them) promote [[https://en.wikipedia.org/wiki/Abstraction_(computer_science)#Abstraction_in_object_oriented_programming][_abstraction_]].

Go's interfaces (and generics) enable [[https://en.wikipedia.org/wiki/Polymorphism_(computer_science)][_polymorphism_]].

Go's packages enable [[https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)][_encapsulation_]].

Go has no concept of [[https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)][_inheritance_]], but facilitates [[https://en.wikipedia.org/wiki/Object_composition][_composition_]] instead. For more on the topic, see [[https://go.dev/doc/faq#Is_Go_an_object-oriented_language][Is Go an object-oriented language? (FAQ)]]

*Functional*aspects*

Go supports [[https://en.wikipedia.org/wiki/First-class_function][first-class functions]], multiple function results, [[https://en.wikipedia.org/wiki/Recursion#In_computer_science][recursion]], and [[https://en.wikipedia.org/wiki/Closure_(computer_programming)][closures]].

: Can a language without inheritance be described as object-oriented? Sure!
: [[https://www.infoworld.com/article/2073649/why-extends-is-evil.html][Allen Holub - Why extends is evil (InfoWorld 2003)]]
: [[https://www.quora.com/What-does-Alan-Kay-think-about-inheritance-in-object-oriented-programming][What does Alan Kay think about inheritance in object-oriented programming? (Quora)]]
: James Gosling (Java): "I'd leave classes out."
: No concept of inheritance in Alan Kay's Simula... a Web of objects
: no classes
: no constructors
: no operator overloading
: no method overloading
: subtyping, but no covariance/contravariance
: encapsulation at the package level rather than at the type/class level

: packages: no ifdef guards, no required ordering of package-level declarations, encapsulation
: Brian Kernighan (popularized C): I think that the real problem with C is that it doesn't give you enough mechanisms for structuring really big programs, for creating ``firewalls'' within programs so you can keep the various pieces apart. https://www.cs.cmu.edu/~mihaib/kernighan-interview/



* Go's rich toolchain

- [[https://pkg.go.dev/cmd/go][cross-compilation]]
- [[https://pkg.go.dev/cmd/gofmt][code formatting]] & [[https://pkg.go.dev/golang.org/x/tools/cmd/goimports][automatic package imports]]
- [[https://pkg.go.dev/golang.org/x/pkgsite/cmd/pkgsite][documentation generation]]
- [[https://pkg.go.dev/testing][testing]] & [[https://pkg.go.dev/cmd/cover][code coverage]]
- [[https://pkg.go.dev/cmd/pprof][profiling]] & [[https://pkg.go.dev/cmd/trace][tracing]]
- [[https://go.dev/doc/articles/race_detector][race detector]]
- extensive [[https://pkg.go.dev/std][standard library]]

.image https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png 200 _


: typically run on save
: gofmt: enforced specific style. flattens learning curve and reduces friction for code reviews
: goimports: imports in canonical order and in alphabetical order per section



* Go development pays well

See the results of the Stack Overflow developer survey ([[https://survey.stackoverflow.co/2023/#top-paying-technologies][2023]], [[https://survey.stackoverflow.co/2022/#technology-top-paying-technologies][2022]], [[https://insights.stackoverflow.com/survey/2021#technology-top-paying-technologies][2021]], [[https://insights.stackoverflow.com/survey/2020#technology-what-languages-are-associated-with-the-highest-salaries-worldwide-global][2020]]).

Even if don't stay at your current job for much longer, learning Go is not a waste of time!

: https://insights.stackoverflow.com/survey/2021#technology-top-paying-technologies

.image https://go.dev/blog/gophergala/fancygopher.jpg 300 _



* The Go Playground

The Go Playground (available at [[https://go.dev/play]]) is a Web app that lets you write and run
a small Go program from your browser. Features include:

- code formatting & automatic package imports
- basic static analysis
- [[https://go.dev/play/p/lEDjyvhttIB][limited support for modules and multiple packages]]
- permalinks
- downloading of the program source (^S or âŒ˜+S)

: static analysis: go vet
: permalinks: convenient for sharing code snippets

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/computer/gamer.svg 150 _

: It's a good place to experiment and fix ideas about the language and its standard library.



* Some limitations of the Go Playground

As its name suggests, the Go Playground isn't meant for projects. Limitations include:

- single executable
- no networking (no HTTP requests, etc.)
- no way of specifying command-line arguments
- limited support for third-party packages

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _

: In this course, we'll only use the Playground to solve simple exercises.
: An alternative with more features, incl. syntax highlighting: https://goplay.space/
: support for 3rd-party libraries added in May 2019: https://www.youtube.com/watch?v=6oF0UblqkGs&t=36m50s



* Hello, World!

You can play with the following program [[https://go.dev/play/p/7vin2BK8_A6][in the Go Playground]].

.play -edit src/helloworld.go

.image https://go.dev/blog/gopher/plush.jpg 300 _



* Some lessons from the Hello World program

All source file starts with a _package_clause_, which consists of the `package` keyword followed by the name of the package:

  package main

A package named `main` produces a _command_ or _executable_program_. In contrast, other packages correspond to _libraries_, which are meant to be imported in other programs.

_Import_declarations_ specify _package_paths_ in double quotes:

: import paths require quotes like in Ruby: require 'json'

  import "fmt"

The `main` function is a program's entrypoint; it has no parameters and no results:

  func main()

Command-line arguments can be retrieved via [[https://pkg.go.dev/os#Args][a variable named `os.Args`]].



* Semicolons

Go's formal grammar [[https://go.dev/ref/spec#Semicolons][uses semicolons as statement terminators]] but, in contrast to C languages, semicolons do not appear in the source and are [[https://go.dev/doc/effective_go#semicolons][added by the compiler]].

As a result, line breaks can only occur in limited places. Consider this program:

  package main

  import "fmt"

  func main()
  {
      fmt.Println("Hello, ä¸–ç•Œ")
  }

Attempts to compile it fail with the following error message:

  syntax error: unexpected semicolon or newline before {

The closing parenthesis and the opening brace must indeed appear on the same line.



* Formatting and file encoding

Go [[https://www.youtube.com/watch?v=sln-gJaURzk&t=28m55s][uses tabs (not spaces) for indentation]]. You'll never need to worry about indenting your code yourself, because Go provides a formatting tool: `gofmt`.

You can trigger `gofmt` by pressing the _Format_ button in the Go Playground:

.image img/go_playground_format.png 150 _

Moreover, if you've properly set up your IDE for Go, it will run `gofmt` upon file save.

`gofmt` is [[https://www.youtube.com/watch?v=sln-gJaURzk&t=30m58s][a huge time saver]], both for writing and reading code. Before contributing changes to a Go project, make sure you format your code with `gofmt`!

Finally, be aware that Go source files [[https://go.dev/ref/spec#Source_code_representation][*must* be encoded in UTF-8]], or compilation will fail.



* Modules

Go's solution to dependency management is known as the [[https://go.dev/doc/modules/managing-dependencies][_modules_system_]].

The terms _package_ and _module_ are confusingly similar, but don't conflate the two!

- A _package_ is a unit of code composed of one or more source files.
- A _module_ is a collection of packages versioned together using [[https://semver.org/][semantic versioning]] (and stored in a file tree with a `go.mod` file at its root).

.image img/modules_vs_packages.svg 250 _

: https://go.dev/blog/using-go-modules
: https://excalidraw.com/#json=buuEXMFgpGowzDhZMWzi7,5QOjQiY9GoMUNHGHCGL5_w



* The path of a module

A module is identified by its _path_, which takes the form of a domain followed by a path where you will release its source code. A module's path should be globally unique.

For instance, if you intend to publish your code on GitHub, the path of your module should have the following format:

  github.com/YOUR_GITHUB_USERNAME/REPO_NAME

A module's path acts as the import path for the module's root directory. It prefixes the import paths of all the packages contained within the module:

  import "github.com/YOUR_GITHUB_USERNAME/REPO_NAME/SOME_PACKAGE_NAME"

Note the absence of a central server (like [[https://npmjs.com]]) where modules ought to be published! As the Go team [[https://cacm.acm.org/magazines/2022/5/260357-the-go-programming-language-and-environment/fulltext#body-11][puts it]]: "Relying on domain names avoided a rush to claim valuable entries in a flat [namespace]."



* Initializing a module

When starting a project, you should initialize a module in the project's root folder.

: (Multi-module projects do exist but are rare and invite complication.)

To do so, `cd` to the root of your project and run a command of the following form:

  $ go mod init <your-module-path>

Initializing a module creates a text file named `go.mod` in the current directory.

Don't forget to track this file in your version-control system, as it contains vital information about your project!

Resist the temptation to edit that file manually. Instead, you can interact with it solely through the use of the `mod` subcommand. For help, run

  $ go help mod



* Namecheck project: initialize a module

1. Create a root folder named `namecheck` for your project and `cd` into it.

2. At the root of your project, initialize a module by running a command of this form:

  $ go mod init github.com/YOUR_GITHUB_USERNAME/namecheck

A `go.mod` file will be created at the root of your project:

  namecheck
  â””â”€â”€ go.mod

3. Inspect the contents of the `go.mod` file. It should look something like this:

  module github.com/jub0bs/namecheck

  go 1.21.4

- The [[https://go.dev/ref/mod#go-mod-file-module][`module` directive]] defines the module's path.
- The [[https://go.dev/ref/mod#go-mod-file-go][`go` directive]] specifies the minimum required version of the Go toolchain.



* Compiling a program

To compile a main package, run the following command in your shell:

  $ go build [path-to-package-folder]

The current working directory is assumed if you omit the path argument.

A self-contained (statically linked) native executable will be created in the current working directory.

The name of the executable is inferred from the name of the directory that contains the main package in question (but with a `.exe` suffix on Windows).

.image https://go.dev/blog/5years/gophers5th.jpg 200 _



* Namecheck project: Hello World

1. Create, at the root of your project, a file named `main.go`:

  namecheck
  â”œâ”€â”€ go.mod
  â””â”€â”€ main.go

2. Write a "Hello World" program in `main.go`; you can get it from the [[https://go.dev/play/p/S8HfNUCy13U][Go Playground]].

3. Compile the program.

4. Inspect the resulting executable with the `file` shell command.

5. Run the executable, and then delete it.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _

: for now, we'll code in this source file, but we'll reorganize our code later
: multiple compilers: gc (canonical one), gogcc, gollvm



* Compiling and executing a program in one fell swoop

If you just want to quickly execute the program without retaining an executable, run

  $ go run main.go

which is roughly equivalent (on *nix systems) to

  $ go build main.go
  $ ./main
  $ rm main

For various reasons, the `run` subcommand isn't appropriate for production, though.

.image https://miro.medium.com/max/4800/1*-bo7H329eM0O1eL_ASBVOA.jpeg 200 _



* Cross-compilation

By default, the compiler will produce an executable that targets your operating system and architecture, which are given by the following shell command:

  $ go env GOOS GOARCH
  darwin
  amd64

However, you can cross-compile to a different operating system and architecture using the `GOOS` and `GOARCH` environment variables:

  $ GOOS=windows GOARCH=amd64 go build main.go

The following command lists all the supported OS/architecture combinations:

  $ go tool dist list


.image https://go.dev/blog/store/gophers.jpg 150 _



* Namecheck project: cross-compiled Hello World

1. Pick a supported OS/architecture combination other than yours.

2. Compile your Hello World program for that target.

3. Inspect the resulting executable with the `file` shell command.

4. Delete the resulting executable.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Keywords

Below is an exhaustive list of Go's keywords. Which ones are mysterious to you?

  break           default           func          interface       select
  case            defer             go            map             struct
  chan            else              goto          package         switch
  const           fallthrough       if            range           type
  continue        for               import        return          var

Note the absence of a `while` keyword; all loops are introduced by the `for` keyword.

Go also lacks keywords like `try`, `catch`, and `finally`: this should be no surprise if you know that Go has no exception system.



* Keywords

*defer* allows you to unconditionally execute some code at the end of a function.
It's useful for cleanup tasks, such as releasing resources.

*range*, used in conjunction with `for`, allows you to iterate over various data structures.

*go* is used to spawn goroutines, which you can think of as lightweight threads.

*chan* and *select* are related to _channels_, which allow you to synchronize and communicate between goroutines.

*fallthrough* is a seldom useful keyword that lets you override the normal "breaking" behavior of Go's `switch` statement.

*goto* [[https://cs.opensource.google/go/go/+/refs/tags/go1.21.4:src/strings/strings.go;drc=132fae93b789ce512068ff4300c665b40635b74e;l=1118][has its uses]], but it's not for the average Go developer. Avoid it.



* Predeclared names

Go comes with several predeclared names accessible from anywhere in your code. We will cover some of them, but only as needed.

*Constants*

  false true nil iota

*Built-in*types*

  bool int rune uint byte float64 string
  struct map chan
  interface error

*Built-in*functions*

  min     max
  make    len     cap     new
  append  copy    delete  clear
  panic   recover



* Comments

[[https://go.dev/ref/spec#Comments][_Line_comments_]] start with a double slash and extend to the end of the line:

  var foo = "foo" // this is a comment

[[https://go.dev/ref/spec#Comments][_General_comments_]] are delimited by `/*` and `*/`; they can be multiline and do not nest:

  /*
    this is
    a general comment
  */

The documentation of a package is written as comments in the package's source file(s). For an example, see [[https://github.com/jub0bs/fcors/blob/main/fcors.go]].

: won't talk too much about documentation in this first course



* A package's path and default name

A package is identified by its _path_, which must be globally unique.

Standard-library packages have paths that are composed of one or more components delimited by slashes:

  fmt
  net/http

Other packages have paths that take the form of a domain followed by one or more components:

  github.com/jub0bs/missilelauncher

The _default_name_ of a package corresponds to the last component of its path:

  fmt
  http
  missilelauncher

: "usually": the exception is for a package whose enclosing folder doesn't mach the package name; best avoided
: also, with versions of modules after v1, it's the second last path component: "rsc.io/quote/v3" => quote



* Package: the unit of compilation

A package is composed of one or more source files that are compiled together.

Packages are indivisible: the smallest thing you can compile in Go is a whole package.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 250 _



* Package: the unit of compilation (cont'd)

All of a package's source files

- start with the same _package_clause_, and
- are located in the same folder on the disk.

`fmt` is an example of a multi-file package. All its source files start with

  package fmt

and are located in a folder named `fmt` somewhere within your Go installation:

  fmt
  â”œâ”€â”€ doc.go
  â”œâ”€â”€ errors.go
  â”œâ”€â”€ format.go
  â”œâ”€â”€ print.go
  â””â”€â”€ scan.go



* Package documentation

The documentation of a locally installed package can be consulted at the command line with the `doc` subcommand, e.g.

  $ go doc fmt
  package fmt // import "fmt"

  Package fmt implements formatted I/O with functions analogous to C's printf and
  scanf. The format 'verbs' are derived from C's but are simpler.
  -snip-

You can also ask for the documentation of a specific symbol, such as `Println`:

  $ go doc fmt Println

The documentation for standard-library packages is available online at [[https://pkg.go.dev/std]]. This website also allows you to discover useful third-party libraries and commands.

The documentation of some packages ([[https://pkg.go.dev/fmt#pkg-examples][`fmt`, for instance]]) features executable examples.




* Package: the unit of encapsulation

In Go, packages (as opposed to types) act as units of encapsulation.

There are only two access levels: a _symbol_ (i.e. a package-level identifier) is either

- _exported_ (i.e. accessible from another package), or
- _unexported_ (i.e. only accessible within its own package).

Whether a symbol is exported depends on the case of its first letter:

  package foo

  var Bar = "Bar"                   // starts with an uppercase B:   exported by package foo
  type Baz struct { /* ... */ }     // starts with an uppercase B:   exported by package foo
  const qux = 42                    // starts with a lowercase q:  unexported by package foo
  func quux() { /* ... */ }         // starts with a lowercase q:  unexported by package foo

: you can tell just by looking at a package-level identifier whether it's public or private



* Importing packages

We'll cover two ways of importing packages: normal imports and named imports.
(For other import syntaxes, see Appendix A.)

The [[https://pkg.go.dev/golang.org/x/tools/cmd/goimports][`goimports`]] utility takes care of adding missing imports, removing unreferenced imports, and organizes imports in a canonical way:

  import (
    // standard-library packages

    // other packages
  )

.image https://go.dev/blog/store/gophers.jpg 200 _

: goimports should run every time you save a file in VS Code



* Normal imports

This is the most common form of import.

You used a normal import in your Hello-World program:

.play -edit src/helloworld.go

To access an identifier exported by a different package (`fmt`, here), you must qualify it using the default package name as prefix (`fmt.Println`).

Importing a package without using it causes a compilation error! This was [[https://go.dev/talks/2016/refactor.article#TOC_2.][a conscious design decision]] to prevent code bloat.



* Named imports

Named imports allows you to use the imported package under a different name.

A named import is convenient when you perceive the default name as inappropriate:

  import ml "github.com/jub0bs/missilelauncher"

Moreover, named imports are especially useful when your code imports multiple packages whose default names conflict,

  import "math/rand"
  import crand "crypto/rand"

or when one of your source files uses multiple major versions of a _module_:

  import "github.com/jub0bs/foo"
  import foov2 "github.com/jub0bs/foo/v2"

: more on this later



* Basic types

*Booleans*

The type is named `bool` and comes with the usual operators: `&&` (AND), `||` (OR), `!` (NOT).

*Numeric*Types*

- signed integers: `int8`, `int16`, `int32`, `int64`, `int`
- unsigned integers: `uint8`, `uint16`, `uint32`, `uint64`, `uint`, `uintptr`
- floating-point numbers: `float32`, `float64`
- complex numbers: `complex64`, `complex128`

Integer types support the increment & decrement operators but only in suffix form: `i++`

*Strings*

A `string` is a sequence of bytes usually representing a valid UTF-8 string.

Strings literals are delimited either by double quotes (`"`) or backticks (```).

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _

: fixed-size integers
: the size of int, uint, and uintptr is either 32 or 64 bits: it depends on the compiler and the target architecture.



* Composites types

Go also provides composite types, which are composed of other existing types.
Here are some examples:

    *int                              // pointer
    func (string) bool                // function
    [7]int                            // array
    []int                             // slice
    map[string]string                 // map
    struct {Lat string; Long string}  // struct
    interface{ String() string }      // interface
    chan error                        // channel

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _



* Every type has a zero value

In Go, [[https://twitter.com/dildog/status/1390848784918327298][unlike in C]], there is no such thing as an uninitialized variable.

Every type, whether built-in or user-defined, has a default value called its _zero_value_.

When you declare a variable without initializing it, its value is the zero value of the variable's type:

  var i int    // the value of i is 0
  var s string // the value of s is the empty string ""

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/zorro.svg 150 _

Types whose zero value is `nil` are sometimes called "reference types": pointers, functions, channels, interfaces, slices, and maps.

: in French: valeur vierge



* Comparability

A type is said to be _comparable_ if arbitrary values of that type can be compared
for equality (with operator `==`) or inequality (with operator `!=`).

All types do allow comparison between a value and the type's zero value, though.

All basic types are comparable, but not all composite types are comparable;
for instance, functions, slices, and maps are not.

In some places (map keys, switch expressions, etc.), only comparable types can be used.

.image https://golangforall.com/assets/kanat.svg 200 _



* Type definitions

The `type` keyword lets you define a type based on some existing [[https://go.dev/ref/spec#Underlying_types][_underlying_type_]]:

  type Celsius float64
  type Fahrenheit float64
  type Kelvin float64

`Celsius`, `Fahrenheit`, and `Kelvin` are _named_types_ all based on type `float64`.

The four types share the same zero value (`0`, in this case).

However, they are distinct types and are *not* interchangeable.

.image https://go.dev/blog/gopher/header.jpg 150 _

: You can only declare methods on defined types that you own.
: you can have type definitions anywhere, incl. inside functions
:   - struct types useful for JSON encoding/decoding
:   - interface types useful for asserting on behaviour
: few restrictions on the underlying type



* Type conversion

If two types are "compatible", an expression of one type can be [[https://go.dev/ref/spec#Conversions][converted]] to the other, either implicitly or explicitly.

However, Go requires many conversions from one type to another to be explicit.

.play -edit src/type_conversion.go /^//START/,/^//END/



* Memory safety TODO

No dangling pointers

Automatic memory management: The Go runtime includes a memory allocator and a garbage collector.
no need to explicitly allocate memory (Go's runtime includes a memory allocator) or free memory (Go's runtime also includes a Garbage collector)

variables not referenced anywhere in the program get eligible to garbage collection.

not a nightmare like in Java

This and the absence of pointer arithmetic makes the language memory-safe and eliminates a whole class of memory-related bugs.

- no dangling pointers
	- : mention heap-overflow vuln discovered in curl

TODO: add love



* Variable declaration

You can declare variables at the package level or locally within a function:

.play -edit src/variables.go

A _local_variable_ *must* be used, or compilation will fail.

Go's declaration syntax departs from C's in many ways. Rob Pike clarified the motivations behind this departure in [[https://go.dev/blog/declaration-syntax][a post entitled _Go's_Declaration_Syntax_]].

Two alternative declaration syntaxes exist: the `var` keyword and the `:=` operator.



* Variable declaration with var

The `var` keyword affords maximum flexibility for declaring variables:

  var s1 string = "Hello, World!"

If the variable's type can be inferred from the right-hand side, you can omit the type:

  var s1 = "Hello, World!"

If the variable's initial value doesn't matter or should be the type's zero value, you can simply omit the equal sign and right-hand-side expression:

  var s1 string

However, you cannot omit both the type and the right-hand-side expression, because the compiler doesn't have enough information to determine the variable's type:

  var s1 // compilation error



* Short variable declaration with :=

The `:=` operator allows you to declare a variable by specifying only its initial value and letting the compiler infer the type from the right-hand-side expression:

  msg := "Hello, World"

This [[https://go.dev/ref/spec#Short_variable_declarations][short-variable-declaration syntax]] makes Go feel a bit like a dynamic language!

If the expression is compatible with multiple types, the compiler uses a default type.
For instance, the default type for integer constants is `int`:

.play -edit src/integer_default_type.go /^//START/,/^//END/



* Short variable declaration with := (cont'd)

The `:=` operator is convenient for assigning the results of a function to variables:

  i, err := strconv.Atoi("42") // declares i and err

The `:=` operator allows you to perform [[https://go.dev/doc/effective_go#redeclaration][a mixture of declaration and assignment]]:

  i, err := strconv.Atoi("42") // declares i and err
  j, err := strconv.Atoi("96") // declares j, but only updates err

However, the `:=` operator must introduce at least one new variable:

  i, err := strconv.Atoi("42")
  i, err := strconv.Atoi("96") // compilation error: no new variables on left side of :=

If you only care about some of the results, assign the others to the _blank_identifier_:

  _, err := strconv.Atoi(s) // declares err, but discards the first result



* Variable naming

Identifiers in Go [[https://go.dev/ref/spec#Identifiers][must]] start with a Unicode letter followed by an arbitrary number of Unicode letters and Unicode digits:

  identifier = letter { letter | unicode_digit } .

You should [[https://github.com/golang/go/wiki/CodeReviewComments#variable-names][strive for conciseness]]; [[https://go.dev/talks/2014/names.slide#4][the smaller the scope, the shorter the name]].

  var index int // too verbose?
  var i int     // likely preferable

Use lower camel case for local variables and unexported package-level variables:

  var maxOutstanding int
  var nbOfVisits uint

Use upper camel case (a.k.a. Pascal case) for exported package-level variables:

  var UnknownAvailabilityError = errors.new("namecheck: unknown availability")

Aside from the _blank_identifier_, don't use underscores in variable names.

: same conventions with constants
: Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters
: ...and those in the Number category Nd as Unicode digits.
: _ is considered a letter


* Favor the := operator in most cases

Because Go has two syntaxes for declaring variables, you may be wondering which one to use in a given situation...

Convention dictactes that the `:=` operator be used whenever possible, *except* when the variable's initial value doesn't matter or should be the variable type's zero value:

  finished := false // not great
  var finished bool // better

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Resort to the var keyword if needed

In many cases, you have no option but to use the `var` keyword...

*To*declare*a*package-level*variable*

  package main

  maxConcurrent := 16    // syntax error: non-declaration statement outside function body
  var maxConcurrent = 16 // works fine

*To*declare*a*variable*whose*type*cannot*be*inferred*by*the*initializing*expression*

  userptr := nil    // compilation error: untyped nil
  var userptr *user // works fine

*To*declare*a*variable*whose*inferred*type*doesn't*suit*you*

  type Fahrenheit float64

  freezing := 32                // type int :(
  var freezing Fahrenheit = 32 // type Fahrenheit :)

: a nil value carries no type information (could be a map, a function, a slice, a pointer)
: more idiomatic than freezing := Fahrenheit(32)



* Namecheck project: validation of GitHub usernames

In your `main` function, do the following:

1. Assign your prospective username to a string variable named `username`.

2. Which variable declaration syntax did you choose? Justify your choice.

3. Print the username variable to the screen.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* If statements

Unlike in C, the condition must be of type `bool` and needs not be enclosed in parens.
However, braces around the "if" branch are mandatory.

.play -edit src/if_simple.go /^//START/,/^//END/

A [[https://go.dev/ref/spec#Statements][_simple_statement_]] (usually a short variable declaration) can precede the condition:

.play -edit src/if_short_variable_decl.go /^//START/,/^//END/

Because the scope of such variables is restricted to the if(-else) statement, this syntax frees you to reuse the same variable name ("err", in this case).

: mandatory braces: no dangling-else problem like in C, JS, etc.
: short-var-decl: useful for error handling



* If-else statements

Braces around the body of an "else" branch are also mandatory.

.play -edit src/if_else.go /^//START/,/^//END/

Long if-else chains are considered non-idiomatic, and can often be advantageously replaced by a switch statement. Surprisingly, the `else` keyword is rarely used in Go.

Go has no conditional ternary operator.



* Switch statement

The switch expression, whose type must be comparable, is evaluated once.

The case expressions (not necessarily constants), are evaluated left-to-right and top-to-bottom and tested for equality against the switch expression until a match is found.

The case clause of the first match gets executed. If no match is found, the default case clause (if any) gets executed.

.play -edit src/switch.go /^//START/,/^//END/

Unlike in C and other languages, no `break` keyword is required at the end of case clauses. Use the `fallthrough` keyword if needed (which is rare).

: A short-variable-declaration statement can precede the switch condition.
: The default clause can occur at any place among the the normal cases.



* Tagless switch

You can omit the switch expression, which is equivalent to switching on `true`:

.play -edit src/tagless_switch.go /^//START/,/^//END/

This form of `switch` statement is preferred to a long if-else chain.

There is another form of switch known as _type_switch_, which you can ignore for now.



* Namecheck project: validation of GitHub usernames

A username is deemed [[https://docs.github.com/en/site-policy/other-site-policies/github-username-policy][acceptable by GitHub]] if

- it does not start/end with a hyphen and does not contain two consecutive hyphens;
- it contains between 3 and 39 alphanumeric or hyphen characters.

In your `main` function, do the following:

1. Using functions from the [[https://pkg.go.dev/strings][strings]] and [[https://pkg.go.dev/regexp][regexp]] packages, check whether your username follows both rules. Ignore any error for the time being; more about error handling later.

2. Only if your username follows both rules, print that username to the screen.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Namecheck project: validation of GitHub usernames (cont'd)

Implementing this kind of validation logic in the `main` function is awkward.

We should learn how to declare functions, so we can extract this logic out.

But first, let's learn about pointers in Go.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Pointers

A [[https://en.wikipedia.org/wiki/Pointer_(computer_programming)][_pointer_]] is a type of value that stores a memory address.

Like C, Go has pointers. Although Go pointers are less powerful, they are also much simpler and safer than C pointers.

Compared to other languages like Javaâ€”where almost everything is a [[https://en.wikipedia.org/wiki/Reference_(computer_science)][_reference_]] and you possibly get more [[https://en.wikipedia.org/wiki/Indirection][indirection]] than you'd ideally likeâ€”Go allows you to keep more control over memory layout and the amount of garbage generated.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-hug.svg 200 _



* Addressability and & operator

If a value of type `T` is [[https://go.dev/ref/spec#Address_operators][_addressable_]], you can obtain its address using the `&` operator.
The result is a _pointer_ of type `*T` that contains the address of the value in question.

.play -edit src/pointers_address.go /^//START/,/^//END/

Go doesn't support [[https://go.dev/doc/faq#no_pointer_arithmetic][_pointer_arithmetic_]]:

  p++ // invalid operation: p++ (non-numeric type *int)

All variables are addressable, but not all values are addressable:

  &42 // invalid operation: cannot take address of 42 (untyped int constant)

However, the `&` operator can be applied to [[https://go.dev/ref/spec#Composite_literals][_composite_literals_]] (structs, maps, slices, etc.):

  pu := &User{name: "jub0bs"}
  fmt.Println(pu)

: for convenience



* Pointers' zero value

The zero value of all pointer types is `nil`. A `nil` pointer points to nothing.

.play -edit src/pointers_zero.go /^//START/,/^//END/

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/zorro.svg 200 _



* Pointers are comparable

Pointer types are comparable, i.e. two pointers of the same type can be compared:

.play -edit src/pointers_comparable.go /^//START/,/^//END/

Two pointers that point to the same variable are equal:

.play -edit src/pointers_equal.go /^//START/,/^//END/



* Pointer dereference

You can _dereference_ a pointer (i.e. obtain the value it points to) using the `*` operator:

.play -edit src/pointers_dereference.go /^//START/,/^//END/

A common source of confusion is that the asterisk is used both in the name of pointer types (e.g. `*int`) and as the pointer-dereference operator (e.g. `*p`).

Assigning a value to a dereferenced pointer changes the value at that address:

.play -edit src/pointers_assign.go /^//START/,/^//END/

Dereferencing a nil pointer causes a panic!

.play -edit src/pointers_nil_dereference.go /^//START/,/^//END/



* The "new" built-in function

Go provides a built-in function named "`new`", which has nothing to do with the "`new`" keyword from object-oriented languages like C# and Java!

`new(T)` allocates a value equal to type `T`'s zero value and returns that value's address.

It can spare you the declaration of an intermediate variable. For example, Compare

.play -edit src/pointers_new_before.go /^//START/,/^//END/

to

.play -edit src/pointers_new.go /^//START/,/^//END/

The `new` function is somewhat controversial; many members of the Go community, [[https://www.youtube.com/watch?v=5DVV36uqQ4E&t=8m10s][including some influential ones]], openly disparage it. Use it sparingly.

ðŸ‘‰ That's all you need to know about pointers for now. Let's talk about functions.



* Calling a function

To call a function, you must specify one argument for each of the function's positional parameters, in the expected order, and using commas as separators:

.play -edit src/function_call.go /^//START/,/^//END/

Unlike languages like [[https://docs.python.org/3/glossary.html#term-argument][Python]], Go doesn't allow you to

- specify arguments by name, or
- omit an argument and rely on some default value for the corresponding parameter.



* Evaluation strategy: call by value

Go's [[https://en.wikipedia.org/wiki/Evaluation_strategy][evaluation strategy]] is [[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value][_call_by_value_]], without any exception.

Each argument expression is eagerly evaluated, and the result is bound to the corresponding parameter variable within the function.

In other words, functions operate only on *copies* of their arguments.

.play -edit src/call_by_value.go /^//START/,/^//END/

In the example above, the incrementation performed by function `incr` on its argument is *not* visible in the caller (the `main` function). Can you explain why?



* Evaluation strategy: call by value (cont'd)

Contrast the previous program to the following one:

.play -edit src/call_by_value_ptr.go /^//START/,/^//END/

In the example above, function `incr` takes, not an `int`, but a `*int`.

It operates on a copy (`p`) of its pointer argument (`&i`), and that copy also points to `i`. Therefore, the incrementation performed by function `incr` on `*p` _is_ visible in the caller.



* Evaluation strategy: call by sharing?

Some types (most notably slices, maps, and channels) can be thought of as "reference types": they're designed in such a way as to behave "like" pointers.

[[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing][_Call_by_sharing_]] is perhaps a more appropriate term than _call_by_value_ to describe
what happens when values of such types are passed to a function.

.play -edit src/call_by_sharing.go /^//START/,/^//END/

In this example, the changes made by the `add` function to its `map[string]string` argument (which behaves "like" a pointer) are visible in the caller (the `main` function).



* Function declaration & multiple results

Here is a simple example of a named function:

  func CountWords(s string) int {
    return len(strings.Fields(s))
  }

A function can return multiple results, whose types must be specified within parens:

: multiple results: contrary to languages like C

  func CountWordsInFile(path string) (int, error) {
    var count int
    // omitted implementation
    return count, nil
  }

Go's support for multiple function results [[https://go.dev/doc/effective_go#multiple-returns][is key to error reporting]]!

: Bonus question: can you explain why function `CountWordsInFile` returns an error whereas function `CountWords` does not?

Contrary to more traditional object-oriented languages, Go doesn't allow [[https://go.dev/doc/faq#overloading][function overloading]]: no two functions within the same scope can have the same name but different signatures.

: however, no tuples in Go!



* Namecheck project: validation of GitHub usernames

1. Extract the validation logic to a function named `IsValid`; it should return `true` if its string argument is a valid GitHub username, and `false` otherwise:

  func IsValid(username string) bool

2. Write a few "tests" for `IsValid` in the `main` function.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

If you're still ignoring errors, do you think that's judicious? You'll eventually need to learn how to properly handle errors.

ðŸ‘‰ For now, let's keep learning about functions.



* Named results

You can name (either all or none of) your function's results:

  func CountWordsInFile(path string) (count int, err error) {
    // ...
    return
  }

Note the use of a "naked" return, which yields the current values of the result variables.

The code above is roughly equivalent to the following:

  func CountWordsInFile(path string) (int, error) {
    var count int
    var err error
    // ...
    return count, err
  }

Named results can [[https://cs.opensource.google/go/go/+/refs/tags/go1.21.4:src/context/context.go;l=179][save you a few lines of code]] but also harm readability. Use named results sparingly for your exported functions, preferably [[https://go.dev/talks/2014/names.slide#10][only when they contribute to the function's documentation]].



* Variadic functions

A variadic parameter (denoted by `...T`) indicates an arbitrary number (zero or more) of parameters of type `T`:

.play -edit src/function_variadic.go /^//START/,/^//END/

The variadic parameter (if any) is a _slice_ and can only appear last in the function's parameter list.

You've already used a variadic function... Which one? Inspect its signature in the doc.



* Type factorization in parameter and result lists

The type of identically typed consecutive parameters can be factored out:

.play -edit src/function_factored_type_in_param_list.go /^//START/,/^//END/

Consult the documentation of `strings.Trim` for an example of this syntax.

Similarly, the type of identically typed consecutive results can be factored out:

.play -edit src/function_factored_type_in_result_list.go /^//START/,/^//END/



* Functions are first-class values

Functions can [[https://pkg.go.dev/net/http/#HandleFunc][take other functions as parameters]], [[https://go.dev/play/p/LfT4e0lPmNV][return functions as results]],
be stored in variables, etc.

.play -edit src/function_value.go /^//START/,/^//END/

Function types are *not* comparable:

.play -edit src/function_uncomparable.go /^//START/,/^//END/

The zero value of function types is `nil`. Calling a `nil` function causes a panic!

.play -edit src/function_nil.go /^//START/,/^//END/

: how is a function-valued parameter
: functions as parameters: useful for decorators/middleware
: function-typed results can also be useful for cleaning up; see Mat Ryer's talk



* Anonymous functions and lexical closures

Go supports anonymous functions but lacks a concise "lambda" notation:

  incr := func(i int) int { return i + 1 }

A [[https://en.wikipedia.org/wiki/Closure_(computer_programming)][_closure_]] is an anonymous function that references (or "captures" or "closes over") variables from its lexical scope:

.play -edit src/function_closure.go /^//START/,/^//END/



* Recursion

Go supports [[https://en.wikipedia.org/wiki/Recursion#In_computer_science][recursion]]: a function can call itself, either directly or indirectly.

Recursion may seem a bit tricky and academic at first, but it's particularly useful for traversing recursive data structures, such as linked lists and binary trees.

Here is a recursive implementation of the [[https://en.wikipedia.org/wiki/Factorial][factorial function]] from mathematics:

.play -edit src/recursion.go /^//START/,/^//END/

Because Go's call stacks are elastic (they grow and shrink as needed), recursion is less likely (unless there is a bug!) to cause a stack overflow than in other languages.

: another example: https://go.dev/play/p/0S57WLB0YRv
: Closures can also be recursive, but this requires the closure to be declared with a typed var explicitly before itâ€™s defined.



* Methods

Methods are functions that are attached to a specific type.

Methods distinguish themselves from _package-level_functions_ by the presence (in a pair of parentheses between the keyword `func` and the method's name) of an extra parameter called the _method's_receiver_:

  func MatchString(pattern string, s string) (matched bool, err error) // package-level function
  func (re *Regexp) MatchString(s string) bool                         // method on the *Regexp type

Methods are tightly related to _interfaces_, which are the primary mechanism for polymorphism. More about that later in the course.

ðŸ‘‰ Now let's learn how to handle and report errors!



* Errors are values

There are no exceptions in Go! Anticipated failures are reported as [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=16m13s]["normal" values]] of the [[https://pkg.go.dev/builtin#error][built-in interface type `error`]].

A function that can fail typically returns an additional `error` result; by convention, this result is the function's last:

  func Fetch(uri string) ([]Item, time.Time, error)

A non-`nil` `error` result indicates to the caller that the function call failed in some way and that the other results are unusable. Conversely, a `nil` error indicates that the function call succeeded.

"err" is a conventional name for error values and the following nil-check idiom is typical:

  items, _, err := http.Fetch("https://api.jub0bs.com/status")
  if err != nil {
    // failure (items is unusable): handle err and perhaps return early
  }
  // success: do something interesting with items

: mention that a boolean result can be used if the function can fails for a single unambiguous cause

: compare with other languages
:   C: error codes, in-band, no multiple return values; write more to a volatile location in memory
:   Java/Scala: exceptions, or Option, Either or some Result type (more functional)



* Don't ignore errors

Few errors should be ignored. You can deviate from this general rule in some cases,
particularly with `fmt.Println` and friends.

You simply cannot assume success of a fallible function and the soundness of its other results (if any) if you don't check the error it returns!

Go forces you to think about failure cases. Error handling in Go can be perceived as repetitive and tedious, but that's actually [[https://changelog.com/gotime/16#transcript-68][a strength of the language]]. Many software outages [[https://yonglezh-purdue.github.io/files/osdi14-simpletesting.pdf][can indeed be attributed]] to improper error handling.

You may hate Go's stance on error handling but, in time, you will grow to love it!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-hug.svg 200 _

: for some functions, a non-nil error may indicate only a partial failure (e.g. Read)
: just restart the container? what if you have long-running jobs (e.g. billing)? that would add latency to your system




  v, err := fallibleFunction()
  if err == nil {
    // success; do something interesting with v
  } else {
    // failure: handle error
  }

* Line of sight

Don't confine the happy path of your functions to nested "if" branches, or you'll end up with deeply nested code (a so-called "[[https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)][pyramid of doom]]"), which is hard to read:

  v, err := fallibleFunction()
  if err == nil {
          v2, err := faillibleFunction2()
          if err == nil {
                  v3, err := fallibleFunction3()
                  if err == nil {
                          // happy path <--------------
                  } else {
                            // failure: handle 3rd error
                  }
          } else {
                    // failure: handle 2nd error
          }
  } else {
            // failure: handle 1st error
  }



* Line of sight (cont'd)

Instead, invert the conditions and deal with failure cases first:

  v, err := fallibleFunction()
  if err != nil {
          // failure: handle 2nd error
  }
  v2, err := faillibleFunction2()
  if err == nil {
          // failure: handle 2nd error
  }
  v3, err := faillibleFunction3()
  if err == nil {
          // failure: handle 2nd error
  }
  // happy path <--------------

This idiom (applicable to other languages) greatly contributes to the code readability.

By avoiding the `else` keyword and eliminating failure cases as they arise, you [[https://go.dev/doc/effective_go#if][keep the happy path on the left]], you [[https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting][minimize nesting]], you [[https://www.youtube.com/watch?v=yd_rtwYaXps&t=33m30s][reduce the cognitive load]] required to read and understand your code.



* Line of sight (cont'd)

For more about this idiom and its relevance in Go, consult the following resources:

- [[https://github.com/golang/go/wiki/CodeReviewComments#indent-error-flow][Go Code Review Comments - Indent Error Flow]]
- [[https://go.dev/talks/2013/bestpractices.slide#3][Francesc Campoy Flores - Twelve Go Best Practices]]
- [[https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88][Mat Ryer - Code: Align the happy path to the left edge]]
- [[https://dave.cheney.net/2019/07/09/clear-is-better-than-clever][Dave Cheney - Clear is better than clever]]
- [[https://www.youtube.com/watch?v=ltqV6pDKZD8&t=1426s][Edward Muller - Go Anti-Patterns (GopherCon 2017)]]

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _

: also about cognitive load: https://go.dev/talks/2013/bestpractices.slide#3



* Handling a non-nil error value

What should you do when a function call returns a non-`nil` error?

  func YourFunction(username string) bool {
    v, err := foo(username)
    if err != nil {
      // ???
    }
    // ...
  }

The best course of action depends on the context...

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _



* Bubbling a non-nil error up to the caller

If your function cannot handle a non-`nil` error value, simply bubble it up to the caller:

  func YourFunction(username string) (bool, error) {
    v, err := foo(username)
    if err != nil {
      return false, err
    }
    // ...
  }

Additionally, you can add some contextual information about the failure by wrapping the error value into a higher-level one, thereby building a chain of errors. In particular, see the documentation of [[https://pkg.go.dev/fmt#Errorf][the `fmt.Errorf` function]] about the `%w` formatting directive.

  func YourFunction(username string) (bool, error) {
    v, err := foo(username)
    if err != nil {
      return false, fmt.Errorf("failure to check %q: %w", username, err)
    }
    // ...
  }



* Consuming a non-nil error

In other cases, you may not want to expose the error to the caller and instead absorb/consume it, perhaps by logging it or printing it to stderr:

  func YourFunction(username string) bool {
    v, err := foo(username)
    if err != nil {
      log.Println(err)
    }
    // ...
  }

This approach is best reserved to the `main` function (or, at least, high in the call stack).

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _




* Bubbling up or consuming a non-nil error? Don't do both!

However you choose to handle a non-`nil` error, do _not_ both report it and consume it!

  func YourFunction(username string) (bool, error) {
    v, err := foo(username)
    if err != nil {
      log.Println(err)
      return false, err
    }
    // ...
  }

If the caller does the same, and the caller's caller does the same, etc., you will end up with multiple entries for the same error in your logs.


.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 150 _

: I've seen people logging the error at every stage of the call stack! => duplicate entries in logs, confusing



* Beyond if err != nil

When you get a non-`nil` error, you can also ask programmatic questions about the nature of that error or the contents of its error chain.

For instance, to find out whether the error chain contains some sentinel error value (such as [[https://pkg.go.dev/context#DeadlineExceeded][`context.DeadlineExceeded`]]), you can use [[https://pkg.go.dev/errors#Is][the `errors.Is` function]]:

  if errors.Is(err, context.DeadlineExceeded) {
    // err (or a node in its error chain) is context.DeadlineExceeded
  }

[[https://pkg.go.dev/errors][The `errors` package]] allows you to ask more sophisticated questions, such as whether an error chain contains an error of some concrete type (see [[https://pkg.go.dev/errors#As][the `errors.As` function]]) , but this is an advanced topic that requires a preliminary understanding of interfaces.



* Creating error values

In some situations, you'll need to create an error value from scratch.

[[https://pkg.go.dev/errors#New][`errors.New`]] allows you to create a simple error value with the desired error message:

  err := errors.New("namecheck: failure to check availability of 'jub0bs' on GitHub")

However, [[https://pkg.go.dev/fmt#Errorf][`fmt.Errorf`]] is more flexible, as it accepts a format string:

  username := "jub0bs"
  platform := "GitHub"
  err := fmt.Errorf("namecheck: failure to check availability of %q on %s", username, platform)

Note the parallel between these two couples of functions:

- `fmt.Println` and `fmt.Printf`
- `errors.New` and `fmt.Errorf`



* Good practices about error messages

Convention dictates that error messages

- [[https://github.com/golang/go/wiki/CodeReviewComments#error-strings][be lowercase]],
- not contain line breaks,
- be of the form "<package-name>: <human-readable-error-message>".

Here is a typical example:

  namecheck: failure to check availability of 'jub0bs' on GitHub

Also, remember that error messages are for humans, not machines!

If you want to provide programmatic access to contextual information about the failure, don't simply bury that information in an error message, because that would force your users to parse the message in order to extract that information... ðŸ˜–

Instead, declare your own type and make it behave like an error. More about that later.



* Panic

A panic is a run-time event that indicates an exceptional and irrecoverable failure. Panics can (but rarely should) be [[https://go.dev/blog/defer-panic-and-recover][_recovered_]].

A panic can be triggered by a run-time error or by some direct or indirect call to [[https://pkg.go.dev/builtin#panic][the built-in `panic` function]].

.play -edit src/panic.go /^//START/,/^//END/

When a panic occurs anywhere in your program,

- the program's normal execution stops,
- deferred function calls are executed as it the stack is unwound,
- an error message and goroutine traces are printed to stderr, and
- the program exits with a non-zero status.

: recover: if you consume a third-party package that panic willy-nilly
: Panics may be reminiscent of Java's run-time exceptions, but the two cultures are radically different!



* Naming convention for functions designed to panic

For convenience, some functions are designed to panic. The name of such functions typically start with "Must".

For example, [[https://pkg.go.dev/regexp][the `regexp` package]] provides [[https://pkg.go.dev/regexp#MustCompile][a function named `Compile`]] for parsing a pattern and creating a `*regexp.Regexp` value out of it. If the pattern isn't a valid regular expression, `Compile` returns a non-`nil` error.

  func Compile(pattern string) (*regexp.Regexp, error)

However, you sometimes want to declare a `*regexp.Regexp` as the package level or, if the pattern isn't valid, simply fail package initialization. Therefore, the `regexp` package also provides [[https://pkg.go.dev/regexp#MustCompile][a panicking wrapper, named `MustCompile`]], around `Compile`:

  func MustCompile(pattern string) *Regexp {
    re, err := Compile(pattern)
    if err != nil {
      panic(`regexp: Compile(` + quote(pattern) + `): ` + err.Error())
    }
    return re
  }



* Don't panic for no good reason

Resist the temptation to make your functions panic for anticipated and mundane failures, such as

- a file that couldn't be opened,
- the database server closing the connection,
- a HTTP request that never reached the target Web server, etc.

In idiomatic Go, such failures are instead reported to the caller as `error` values.

However, panicking during the initialization of your package is legitimate, if some programming error renders the package unusable... Does that give you and idea?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 150 _

: examples: invalid regexp pattern, template compilation failure



* Namecheck project: properly handle errors (cont'd)

1. Use `regexp.MustCompile` to declare a variable of type `*regexp.Regexp` at the package level.

2. Refactor your `IsValid` function to make use of that variable.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: if the regexp is invalid, the package is unusable => communicate that by panicking at initialisation
: more efficient: regexp compiled at most once
: the package-level var cannot be a const



* Namecheck project: creating a dedicated package per supported platform

All the code we've written in `main.go` so far is specific to GitHub, which is a bit messy.

It would be preferable to create a dedicated library package for each of the social media we wish to support.

ðŸ‘‰ Let's learn how to create a library package and how to use it in our `main` package.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _



* Main packages

A package named "main" is called a _main_package_ and produces a standalone program.

The package *must* declare a `main` function that has no params and returns no results.

The name of the enclosing folder is arbitrary.

A main package produces a single executable. If your project produces several executables, put each of the main packages in a subfolder of a parent folder named "cmd" located at the root of your project:

  namecheck
  â””â”€â”€ cmd
   Â Â  â”œâ”€â”€ cli
   Â Â  â”‚Â Â  â””â”€â”€ main.go
   Â Â  â””â”€â”€ server
   Â Â      â””â”€â”€ main.go




* Library packages

Any package not named "main" is a _library_package_, i.e. a package meant to be imported in other programs.

The name of the enclosing folder must (in general) match the package's default name. For instance, all the source files constituting the `fmt` package are stored on the disk in a folder named "fmt":

  fmt
  â”œâ”€â”€ doc.go
  â”œâ”€â”€ errors.go
  â”œâ”€â”€ format.go
  â”œâ”€â”€ print.go
  â””â”€â”€ scan.go

There's one exception to this rule that relates to testing. More on that later.

: only should, because _test package exception and also not enforced by tooling, but otherwise confusing
: in most cases, the last segment of the package path should match the package name as declared in package clause
: Two kinds of packages



* Source files of a package

A package is composed of one to several source files.

All of a package's source files must be placed in the same folder. In general (there's one exception), source files from different packages cannot be in the same folder.

All of the members of a package are accessible to all of the package's source files.

Each source file must import the packages that it needs.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _

: package-level elements are visible in all source files that make up the package, not just in the source file that contains their declaration



* Naming a package

Convention dictates that package names be lowercase alphanumeric (no underscores) and nouns rather than verbs (usually).

[[https://www.youtube.com/watch?v=zzAdEt3xZ1M&t=5m45s][A well-designed package starts with its name]]! Because the name will appear in qualified identifiers in your users' code, choosing a good name is important. A good name is

- *concise* (_net_ rather not _network_, _strconv_ rather than _stringconversion_, etc.)
- yet *descriptive* (avoid painfully generic names like "util", "helpers", or "common").

The name should be [[https://www.youtube.com/watch?v=ltqV6pDKZD8&t=734s][a clue to the package's purpose rather than to its contents]]. Rob Pike also says: [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=1090s][Design the architecture, name the components, document the details.]]

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 150 _



* Naming a package (cont'd)

Finally, don't prevent the users of your package from choosing a good identifier.

For example, if you choose "cors" for the name of your [[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS][CORS]]-middleware library package, its users cannot declare a variable named "cors" without shadowing the name of your package.

This consideration drove me to name [[https://pkg.go.dev/github.com/jub0bs/fcors][my own library]] "fcors" rather than simply "cors":

  import "github.com/jub0bs/fcors"

  func main() {
    cors, err := fcors.AllowAccess(
      fcors.FromOrigins("https://example.com"),
      fcors.WithMethods(
        http.MethodGet,
        http.MethodPost,
      ),
      fcors.WithRequestHeaders("Authorization"),
    )
    // ...
  }


: concise: fmt, not format; strconv, not stringconversion
: avoid painfully generic (!) names / catchall names



* Designing a package

*Strive*for*cohesion*

- A package should provide a focused set of related features.
- Let the name of the package guide you!

*Keep*the*conceptual*surface*area*small*

- Don't default to exporting everything.
- Be deliberate about what you export.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _



* Good naming practices for package identifiers

Bear in mind that an exported symbol (e.g. `Println`) is [[https://go.dev/ref/spec#Qualified_identifiers][qualified by its package name]] (e.g. `fmt.Println`) in code that imports that package.

[[https://go.dev/talks/2014/names.slide#12][Take advantage of this]] to [[https://www.youtube.com/watch?v=MzTcsI6tn-0&t=23m40s][avoid unnecessary redundancy]] when naming a symbol:

  package coffee

  func RoastCoffee(tempC uint) error // verbose
  func Roast(tempC uint) error       // concise

: example adapted from https://www.youtube.com/watch?v=cAWlv2SeQus&t=18m30s

You will encounter some "stutter" in the standard library, though:

  regexp.Regexp
  time.Time

If a package exports only one type and a factory function for that type, the function is often simply named "New".



* Subpackages

Subpackages of a given package are packages located in subfolders of that package.

Subpackages typically provide functionalities that are related to but more specific than those provided by their parent package.

.image img/encoding_core_lib.png 150 _

Beyond this hierarchy in the directory tree, a package and its subpackage don't have any special relationship:

- If one depends on the other, the former must import the latter.
- One does not have access to the other's unexported symbols.

One special case is [[https://go.dev/doc/go1.4#internalpackages][_internal_packages_]], but this is a more advanced feature.

: encoding defines a general interface that all the subpackages implement



* No import cycles allowed by the compiler

For example, package `foo` cannot import package `bar` if `bar` itself imports `foo`.

.image img/dependency_cycle.svg 150 _

Imports form a _directed_acyclic_graph_, like the graph of commits in a Git repository.

This design decision by the Go team is the kind of [[https://wiki.c2.com/?LiberatingConstraint][liberating constraint]] that enabled fast compilation of Go programs.

.image https://miro.medium.com/max/4800/1*-bo7H329eM0O1eL_ASBVOA.jpeg 200 _

: ex: the standard library can be compiled in 10s on a modern machine



* Avoiding import cycles in your projects

A rule of thumb is that a parent package shouldn't depend on any of its subpackages.

For example, here is a partial view of [[https://pkg.go.dev/encoding][the `encoding` package]] and its subpackages:

.image img/dep_arrows_dont_point_down.svg _ 1000

Note that no dependency arrows points down.

(This rule of thumb doesn't apply to [[https://go.dev/doc/go1.4#internalpackages][internal packages]].)



* Flat is better

To a deep and narrow package hierarchy, prefer a shallow (and possibly wide) one:

.image img/pkg_shallow_and_wide.svg 400 _

Note: at the end of the course, compare the structure of your project to these diagrams.



* Project layout

Under pressure from the community, the Go team recently issued [[https://go.dev/doc/modules/layout][some general guidance about how to structure a module]]; it's a good start.

The best layout very much depends on the problem space of the project considered, but here are a few more useful tips:

âœŒï¸ Avoid analysis paralysis. Simply start with a single package, and create new packages only as structure naturally emerges.

ðŸ˜‡ The layout of your project should tell a story; good package names help.

ðŸ˜µâ€ðŸ’« Remember the constraint that no import cycles can occur; it should inform your layout decisions. Avoid [[https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller][MVC]] layouts at all costs; they're guaranteed to cause cycles.



* Project layout (cont'd)

Here are some additional resources about how to structure projects:

- [[https://www.youtube.com/watch?v=cmkKxNN7cs4&t=564s][Mat Ryer - Writing beautiful packages in Go (2018)]]
- [[https://www.youtube.com/watch?v=oL6JBUk6tj0][Kat Zien - How do you structure your Go apps (GopherCon 2018)]]
- [[https://www.youtube.com/watch?v=MzTcsI6tn-0][Brian Ketelsen - Code like the Go team (GopherCon Russia 2018)]]
- [[https://rakyll.org/style-packages/][Jaana B. Dogan - Style guideline for Go packages (2017)]]
- [[https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1][Ben Jonhson - Standard package layout (2016)]]

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 150 _

: context (twitter, github) ; responsibility (storage)



* Keep cool: don't panic

Good library packages do not panic, at least not

- after proper initialization, and
- if they're used as was intended by the package author(s).

Exported functions should communicate anticipated failures to client code as values of the `error` type, not as panics.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/dandy/umbrella.svg 200 _



* Namecheck project: github package

1. Create a folder named "github" at the root of your project.

2. Create a file named "github.go" in that folder:

  namecheck
  â”œâ”€â”€ github
  â”‚Â Â  â””â”€â”€ github.go
  â”œâ”€â”€ go.mod
  â””â”€â”€ main.go

3. Add the appropriate package clause in `github.go`.

4. Move all the GitHub-specific code from `main.go` to `github.go`.

5. Adjust your `main.go`. You'll need to import your `github` package there.

ðŸ‘‰ Now, let's learn how to write and run tests for the `github` package.



* Go's support for testing

Testing plays a key role in the Go ecosystem, and is supported out of the box.

[[https://pkg.go.dev/testing/][The `testing` package]] allows you to test your packages through

- unit tests or integration tests
- example tests (executable examples that end up in the package's documentation),
- micro-benchmarks (laser-focused performance tests for CPU-bound functions),
- fuzz tests (property-based tests using randomly generated inputs).

You can run tests by invoking the following subcommand: `go`test`

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _

: batteries included: compare to other languages, where testing is an afterthought



* Test files

In Go, a package's test files

- are placed in the same folder as the package's production source files,
- must be suffixed with `_test`.

For instance, to write tests for your package `foo`, composed here of a single source file named `foo.go`, you would create a file named `foo_test.go` in the `foo` folder alongside the `foo.go` file:

  foo
  â”œâ”€â”€ foo.go
  â””â”€â”€ foo_test.go

Respect these location and naming conventions, or you won't be able to run your tests.

Test files are otherwise regular source files in which you write _test_functions_.

: differs from other languages, where tests are located in a mirrored structure of the production code



* White-box testing and black-box testing

You have two options for the name used in the package clause of your test files for package `foo`: `foo` or `foo_test`. This choice determines your testing approach.

*White-box*testing*

You can declare file `foo_test.go` to be part of package `foo`:

  // foo_test.go
  package foo

Your tests then have access to all members (incl. unexported ones) of package `foo`.

*Black-box*testing*

Alternatively, you can declare file `foo_test.go` to be part of package `foo_test`:

  // foo_test.go
  package foo_test

Your tests then only have access to the exported members of package `foo`.



* Should you write white- or black-box tests?

White-box testing is expedient but can lead to prohibitive coupling between tests and implementation details.

Although the standard library heavily relies on white-box testing, many Gophers (such as [[https://changelog.com/gotime/173#transcript-153][Mat]] [[https://www.youtube.com/watch?v=cAWlv2SeQus&t=1125s][Ryer]], I, and others) favor black-box testing, partly because it forces them to test their packages strictly through their public API.

The black-box approach can also be useful to break import cycles in tests.

.image https://pbs.twimg.com/media/EzrMZe6X0AMSozD?format=jpg&name=900x900 250 _

: black-box keeps you honest


* An approach mixing white- or black-box testing is possible

Finally, nothing prevents you from adopting a mixed approach in different test files,

  foo
  â”œâ”€â”€ foo.go
  â”œâ”€â”€ foo1_test.go
  â””â”€â”€ foo2_test.go

with black-box tests in some test files

  // foo1_test.go
  package foo_test

  // ...

and white-box tests in others:

  // foo2_test.go
  package foo

  // ...







* Test functions

A test function is a regular Go function, but its name and signature must adhere
to a strict convention:

- It must be prefixed by `Test` and the following character must be uppercase.
- It has a single parameter of type `*testing.T` and returns no results.

Respect this convention, or your test functions will be ignored by `go`test`.

  func Testfoo(t *testing.T) // bad: the letter following Test is lowercase
  func TestFoo(t *testing.T) // good


.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _



* Example of a test function for the IsValid function

  package github_test // black-box testing

  import "testing"
  // import declaration of your github package (omitted here)

  func TestUsernameContainsTwoConsecutiveHyphens(t *testing.T) {
    const (
      username = "jub0bs--on-GitHub"
      want     = false
    )
    got := github.IsValid(username)
    if got != want {
      t.Errorf("github.IsValid(%q): got %t; want %t", username, got, want)
    }
  }

The `*testing.T` type provides methods (such as `Errorf`) that allow you to indicate that the test has failed via an informative message, which typically adheres to this format:

  <function-call>: got <actual-result>; want <expected-result>

Some assertion libraries (like [[https://github.com/stretchr/testify/][github.com/stretchr/testify]]) exist but are dispensable.



* Running tests

From within a package's folder, you can execute its tests by running

 go test

To execute the tests for a package and all of its subpackages, run

  go test ./...

Passing tests are not mentioned in the output; use the `-v` flag to change that:

  go test -v ./...

You can also selectively run some test functions by specifying a regexp, e.g.:

  go test -run='^TestUsernameToo.*' ./...



* Namecheck project: test github's IsValid function

1. Create a file named `github_test.go` in the `github` folder.

  namecheck
  â”œâ”€â”€ github
  â”‚   â”œâ”€â”€ github.go
  â”‚   â””â”€â”€ github_test.go
  â”œâ”€â”€ go.mod
  â””â”€â”€ main.go

2. Follow the black-box approach (use `github_test` as the package name) and write a test for your `IsValid` function, and then run that test.

3. Momentarily introduce a bug in your `IsValid` function to make the test fail.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Measuring code coverage

To determine how much of your package's production code is covered by its tests, run

  go test -cover ./...

To generate a more detailed (machine-readable) coverage report, first run

  go test -coverprofile="coverage.out" ./...

Then, to see (on the command line) a breakdown of the coverage by function, run

  go tool cover --func="coverage.out"

Alternatively, for a browser-based breakdown of the coverage by statement, run

  go tool cover --html="coverage.out"



* Namecheck project: improve the github package's code coverage

1. Inspect the code coverage of your `github` package.

2. Write enough good test cases to reach a code coverage that satisfies you.

3. What would a low coverage say about your tests? What about a high coverage?

ðŸ‘‰ Now let's write code to check whether a username is available on GitHub.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: a high code coverage doesn't guarantee that the covered code is well-tested
: a low code coverage does tell you that you need to write more tests



* Namecheck project: availability on GitHub

1. In the `github` package, add the following stub:

  func IsAvailable(username string) (bool, error) { return false, nil }

2. Study the second code snippet in [[https://pkg.go.dev/net/http/#pkg-overview][the Overview section of the `net/http` package]].

3. `IsAvailable` should send a `GET` request to `https://github.com/<username>` and,

: where USERNAME stands for the username whose availability we'd like to check.

- if the response's status code is `404`, it should return `true` and `nil`;
- If the response's status code is `200`, it should return `false` and `nil`.
- For any other status code or in case an error occurs, `IsAvailable` should return `false` and a non-nil error.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Introducing the defer keyword

[[https://pkg.go.dev/net/http/#pkg-overview][The documentation of the `net/http` package]] warns that the client must close the response body when finished with it. Otherwise, the client risks *leaking*resources*
(the underlying [[https://en.wikipedia.org/wiki/Transmission_Control_Protocol][TCP connection]], a [[https://en.wikipedia.org/wiki/File_descriptor][file descriptor]], and some goroutines).

Note that, in the example, the `defer` keyword precedes the call to `resp.Body.Close`:

  defer resp.Body.Close()

`defer` is particularly useful for simplifying functions that perform various clean-up actions, such as closing the body of a `http.Response` when you're done with it.

The `defer` keyword is like a `finally` keyword on steroids. You'll grow to love it!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 150 _

: https://github.com/bradfitz/exp-httpclient/blob/master/problems.md#too-easy-to-not-call-responsebodyclose
: Along with concurrency primitives and interfaces, this keyword is a highlight of Go!



* Mechanics of the defer keyword

A defer statement consists of a function call preceded by the `defer` keyword:

  defer foo(username)

That function call gets _unconditionally_ executed _when_the_enclosing_function_terminates_, whether normally or as a result of a panic:

.play -edit src/defer_unconditional.go /^//START/,/^//END/

Remember that a deferred function call is executed, not at the end of the block in which the defer statements occur, but only when the enclosing function terminates.




* Deferred function calls are executed in reverse order

Deferred function calls are executed in reverse order in which they occur in the enclosing function:

.play -edit src/defer_reverse.go /^//START/,/^//END/

This is no accident: you typically want to release resources in reverse order in which you acquire them.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 200 _



* Evaluation of the arguments of a deferred function call

The arguments of a deferred function call are evaluated, not when the function call eventually executes, but when the `defer` statement actually occurs in the code.

.play -edit src/defer_eval.go /^//START/,/^//END/

More about how `defer` works in [[https://go.dev/blog/defer-panic-and-recover][Andrew Gerrand - Defer, Panic, and Recover]].

: incl. the receiver, if the function is a method



* Why is defer useful?

Here is a version of `IsAvailable` that doesn't use `defer` to close the response body:

.code src/defer_IsAvailable_without_defer.go /^//START/,/^//END/

Notice how `resp.Body.Close` must be called at each possible exit point of the function.



* Why is defer useful? (cont'd)

With `defer`, as soon as we know we got a proper HTTP response, we can program the closure of its body ahead of time and then forget about it!

.code src/defer_IsAvailable_with_defer.go /^//START/,/^//END/

The `defer` keyword allows you to [[https://go.dev/doc/effective_go#defer][colocate the acquisition and release of a resource]] in your code, thereby reducing the reader's cognitive load.



* A defer pitfall

`defer` is unreasonably convenient and powerful, but must be used with caution.

Consider the following function.

  func processFiles(paths ...string) error {
    for _, path := range paths {
      file, err := os.Open(path)
      if err != nil {
        return err
      }
      defer file.Close()
      // do something interesting with file...
    }
    return nil
  }

Imagine a case where the function `processFiles` function is called with many paths. What would likely happen? And how would you fix the issue?

: we haven't covered loops yet, but you should be able to understand this program
: eschewing defer is not an answer :)



* A defer pitfall (cont'd)

Remember that `defer` is function-based, not block-based. In our earlier example,
the files will all be closed only when `processFiles` terminates!

One solution is to extract the body of the loop to a smaller function:

  func processFiles(paths ...string) error {
    for _, path := range paths {
      if err := processFile(path); err != nil {
        return err
      }
    }
    return nil
  }

  func processFile(path string) error {
      file, err := os.Open(path)
      if err != nil {
        return err
      }
      defer file.Close()
      // do something interesting with file...
  }

: defer is not block-based but function-based!
: If we pass a large number of files to the `processFiles` function, we could run out of file descriptors.
: ulimit -n



* Namecheck project: IsAvailable lacks testability

`IsAvailable` unconditionally sends a HTTP request to the social network of interest, which considerably hinders its testability:

ðŸ™… Unit tests (in the pure sense of the term) operate only in memory and be fast. In particular, unit tests are not supposed to communicate with the network.

ðŸ«£ Any test case you write will depend on the state of GitHub. If you assert that username "babar" is available on GitHub and someone register an account with that username tomorrow, your test will start failing.

ðŸ˜“ Testing some cases (other status codes, non-nil errors) is currently difficult.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _



* Namecheck project: IsAvailable is unflexible

ðŸ˜– Callers of `IsAvailable` currently have no way of specifying a custom HTTP client, perhaps to configure a request timeout, or [[https://www.youtube.com/watch?v=cAWlv2SeQus&t=1554s][to satisfy a cloud provider's constraints]].

We need a way of somehow injecting

- some real HTTP client in our production code,
- some "fake" HTTP client in our tests.

Interfaces will allow us to resolve these issues. Patience!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/liberty.svg 200 _

: need Internet access to run that unit test
: success/failure of unit test depends on GitHub



* Namecheck project: simulate support for Reddit

We could add support for many other social media, but that would take time and distract us from the main topic of this course. For now, we can simulate support for it.

1. Create a `reddit` package.

2. Simply add a stub implementations of functions `IsValid` and `IsAvailable` in your `reddit` package:

  func IsValid(username string) bool { return false }

  func IsAvailable(username string) (bool, error) { return false, nil }

Actually implementing those functions is left as an exercise for after the course.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Namecheck project: check a username on Github and Reddit

Flesh out your `main` function:

1. Check the validity of the username of interest on GitHub. Print the result.

2. If the username is valid, check its availability on GitHub. Print the error if it's non-`nil` or the boolean result otherwise.

3. Repeat steps 1 & 2 for Reddit.

4. Does the code in your `main` function not suffer from duplication?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: missing abstraction

Our project is starting to take shape, but it still suffers from limitations...

One issue is that, although the `github` and `reddit` packages both export `IsValid` and `IsAvailable` functions with identical signatures, nothing relates them.

We seem to be missing a common abstraction to indiscriminately use the functionalities from the `github` and `reddit` packages...

Again, interfaces will allow us to solve that issue. For now, let's learn about loops.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/liberty.svg 250 _



* Three-clause loop

The familiar loop syntax from the C-family languages is back, with its usual three clauses (initializer, condition, continuation) separated by semicolons:

.play -edit src/forc.go /^//START/,/^//END/

All three of those clauses are optional.

Contrary to C, though, no parentheses are allowed around the three clauses.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/projects/with-C-book.svg 200 _



* "While" loop

Recall that Go has no `while` keyword. All loops are introduced by the `for` keyword:

.play -edit src/while.go /^//START/,/^//END/

The conditional expression

- must be of boolean type,
- needs not be parenthesized,
- can be omitted, in order to obtain an [[https://en.wikipedia.org/wiki/Infinite_loop][infinite loop]].


* break and continue

As in other languages, the `break` keyword terminates the (innermost) loop;

.play -edit src/break.go /^//START/,/^//END/

the `continue` keyword skips to the next iteration of the (innermost) loop.

.play -edit src/continue.go /^//START/,/^//END/

For nested loops, `break` and `continue` can be used in conjunction with [[https://go.dev/ref/spec#Labeled_statements][_labels_]].



* for-range loop

The `range` keyword can be used in conjunction with the `for` keyword to iterate over some data structures, such as arrays, slices, maps, channels, or strings:

.play -edit src/forrange.go /^//START/,/^//END/

In the code snippet above, during each iteration of the loop,

- `r` is the current UTF-8-encoded _rune_ (a.k.a. [[https://en.wikipedia.org/wiki/Code_point#In_Unicode][Unicode code point]]) in the string,
- `i` is the index (in bytes) of the starting position of that rune in the string.

For more about strings, see [[https://go.dev/blog/strings][Rob Pike - Strings, bytes, runes and characters in Go]].



* for-range loop over an int (new in Go 1.22)

You will soon be able to also [[https://github.com/golang/go/issues/61405][range over an int]]. Instead of writing the following three-clause loop,

  for i := range 42 {
    // ...
  }

you'll be able to write the following equivalent (but more concise) loop:

  for i := 0; i < 42; i++ {
    // ...
  }

Try this example on the [[https://go.dev/play/p/2VyjaOK_5pq?v=gotip][Playground]].

ðŸ‘‰ Enough about loops and strings! Let's learn about arrays and slices.



* Arrays

Arrays are fixed-length sequences of elements of the same type.

Contrary to many other languages, Go encodes the length of an array in its type name.

The built-in function `len` yields the length of an array.

You can omit the length in array literals (and replace it with `...`) to let the compiler infer it from the number of elements listed in the literal.

.play -edit src/arrays.go  /^//START/,/^//END/

: the [0]func() trick is actually used to make types non-comparable w/o compromising memory footprint



* Arrays are values

Go arrays [[https://go.dev/doc/effective_go#arrays][differ significantly from C arrays]]. They're _not_ "reference types". An array value is not a pointer to the first element, but denotes the entire collection.

The zero value of an array type is not `nil` (an invalid value for array types), but an array full of zero values of its element type.

.play -edit src/array_zero.go  /^//START/,/^//END/

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/zorro.svg 200 _



* Array comparability

An array type is comparable only if the type of its elements is itself comparable:

.play -edit src/array_comparability.go  /^//START/,/^//END/

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/stovepipe-hat-front.svg 250 _



* Array indexing

Like most languages, Go uses 0-based indexing.

Individual elements of an array can be accessed using the usual square-bracket syntax.

Taking the address of an array element is legal. Elements are contiguous in memory.

Indexing an array outside its bounds causes either a compilation or a panic!

.play -edit src/array_indexing.go  /^//START/,/^//END/



* Ranging over an array

You can iterate over an array using a for-range loop.

The first iteration variable (`i` below) is the index of the current element, whereas the second iteration variable (`role` below) is a _copy_ of the array's current element.

.play -edit src/array_range.go  /^//START/,/^//END/

If you only need one of the iteration variables, you can omit the other:

.play -edit src/array_range2.go  /^//START/,/^//END/



* Direct use of arrays is inflexible

A function taking, as a parameter, an array of a given length cannot accept an array of any other length.

.play -edit src/array_inflexible.go  /^//START/,/^//END/

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _



* Direct use of arrays can be expensive

Remember that Go's evaluation strategy is call by value and that Go arrays are values.

Functions that take an array operate on an entire copy of their array argument!

.play -edit src/array_expensive.go  /^//START/,/^//END/

.image https://go.dev/blog/gophergala/fancygopher.jpg 200 _



* Arrays are seldom used

Legitimate cases for direct use of arrays exist, but are relatively rare.

.code src/sudoku.go  /^//START/,/^//END

This is what [[https://go.dev/doc/effective_go#arrays][Effective Go]] has to say on the topic:

_Arrays_are_useful_when_planning_the_detailed_layout_of_memory_and_sometimes_can_help_avoid_allocation,_but_primarily_they_are_a_building_block_for_slices_ [...]

_Slices_ are an abstraction over arrays. In most situations, the use of slices should be favored over the use of arrays.



* Slices

Slices are arguably the most fundamental and ubiquitous type in Go. As such, they demand a solid understanding of their mechanics from any serious Gopher.

A slice is a variable-length sequential of elements of the same type.

Contrary to arrays, slices do not have have a length specified in their type name,
and they can grow and shrink over the course of their lifetime.

In addition to slice literals, you can use the built-in `make` function to initialize a slice
of a given length.

.play -edit src/slices.go  /^//START/,/^//END

: similar to Java's ArrayList



* A slice's zero value

Slice are "reference types". Their zero value is `nil`.

A `nil` slice is distinct from, but functionally equivalent to, an empty slice. [[https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices][Convention]] dictates that you do not differentiate a `nil` slice from an empty slice in your code.

.play -edit src/slice_zero.go  /^//START/,/^//END/

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/zorro.svg 200 _



* Slices are not comparable

Regardless of their element type, slices are not comparable: the compiler won't allow you to use the `==` operator to test the equality of two arbitrary slice values.

The only legal comparison is to a literal `nil` value.

.play -edit src/slice_incomparable.go  /^//START/,/^//END/

However, you can use [[https://pkg.go.dev/slices#Equal][the `Equal` function]] from [[https://pkg.go.dev/slices][the `slices` package]] to compare two slices whose element type is comparable.

.play -edit src/slice_equal.go  /^//START/,/^//END/



* Slice indexing

Like arrays, slices can be indexed.

Taking the address of a slice element is legal.


.play -edit src/slice_indexing.go  /^//START/,/^//END/

Indexing a slice in the negatives or beyond its _length_ causes a panic:

.play -edit src/slice_indexing_panic.go  /^//START/,/^//END/

So does indexing a `nil` slice:

.play -edit src/slice_indexing_panic_nil.go  /^//START/,/^//END/




* Slices under the hood

A slice is essentially a resizable view (or window) into a backing array.

Under the hood, a slice is a data structure simply composed of three machine words:

- a pointer to the backing array
- an int corresponding to the _length_ of the slice (given by built-in function `len`)
- an int corresponding to the _capacity_ of the slice (given by built-in function `cap`)

  names := []string{"foo", "bar", "baz"}
  fmt.Println(len(roles)) // 3
  fmt.Println(cap(roles)) // 3

.image img/slice_under_hood0.svg 200 _

: https://excalidraw.com/#json=6NCwjZHDM87KQT4ov8FOH,YVzPYpRGuz0wQ2EzslAijA



* Slice length and capacity

A slice is only a window into a backing array. In particular, the backing array may extend past the end of the slice, hence [[https://go.dev/ref/spec#Length_and_capacity][the notion of _capacity_]] in addition to that of _length_.

The capacity of a slice is the maximum length the slice may assume before running out of space in the backing array. For any slice `s`, the following inequality holds at all times:

  0 <= len(s) <= cap(s)

.image img/slice_capacity.svg 200 _

Note that the part of the backing array that extends before the start of the slice doesn't factor in the slice's capacity.

: https://excalidraw.com/#json=GdXPwfEINQppeQbgEeVI0,aLwF22Wr97DQElcExGF_6Q



* Initializing a slice with custom length and capacity

With the `make` built-in function, you can specify the desired length and capacity of your slice independently:

  roles := make([]string, 0, 3)       // note: one more parameter for the slice's capacity
  fmt.Println(len(roles), cap(roles)) // 0 3

.image img/slice_under_hood2.svg 200 _

Doing this is useful as a micro-optimization when you're about to grow a slice and you already know what its final length will be.

Of course, the specified capacity must be greater or equal to the length, or [[https://go.dev/play/p/Igtzx7wAgZz][a compilation error or a panic will occur]].


: https://excalidraw.com/#json=TiMTjJURaNLArsUwaeo3q,sY2pt8gItY8QI4JWhWHkZA



* Slice function parameters are cheap and flexible

Remember: a slice is only a [[https://go.dev/blog/slices-intro#slice-internals][descriptor of an array segment]].

Accordingly, functions that take a slice operate on a copy of their slice argument, but copying the slice doesn't incur any copy of its backing array!

.play -edit src/slice_cheap.go  /^//START/,/^//END

Moreover, a slice parameter is much more flexible than an array parameter because the length of the slice argument can be arbitrary.

: 24 bytes on a 64-bit architecture



* Slice function parameters allow updates to the backing array

Furthermore, updates to elements of a slice argument are visible to the caller:

.play -edit src/slice_update.go  /^//START/,/^//END

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 150 _



* Passing a slice to variadic function

You can "explode" a slice argument into a variadic parameter using a trailing ellipsis:

.play -edit src/slice_explode.go  /^//START/,/^//END/

This functionality is reminiscent of [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax][JavaScript's spread syntax]], [[https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists][Python's]] and [[https://docs.ruby-lang.org/en/2.0.0/syntax/calling_methods_rdoc.html#label-Array+to+Arguments+Conversion][Ruby's]] "splat" (`*`) operator.



* Slicing operator

The _slicing_operator_ can be applied to an array or a slice and produces a slice that focuses on a specific portion of the same backing array:

.play -edit src/slicing_operator.go  /^//START/,/^//END/

.image img/slice_under_hood.svg _ 900



* Slicing operator (cont'd)

The semantics of the slicing operator are that of a [[https://en.wikipedia.org/wiki/Interval_(mathematics)#Definitions][half-open interval]]:

- The first index is inclusive and, if unspecified, defaults to `0`.
- The second index is exclusive and, if unspecified, defaults to the length of the slice.

.play -edit src/slicing_operator2.go  /^//START/,/^//END/

In the slicing expression `s[i:j]`,  indices `i` and `j` must satisfy

  0 <= i <= j <= cap(s)

Otherwise, a compilation error or a panic will occur.

There's also [[https://go.dev/ref/spec#Slice_expressions][a three-index form of the slicing operator]], which is useful for controlling the capacity of the resulting slice, but that is an advanced feature.



* Slicing operator (cont'd)

Note that the slicing operator allows you to retrieve the part of the backing array that extends beyond the length of the slice you're operating on:

.play -edit src/slicing_operator3.go  /^//START/,/^//END/

However, attempts to re-slice a slice beyond its capacity results in either a compilation error or a panic.



* Namecheck project: pass a username as a command-line arg

1. Consult the [[https://pkg.go.dev/os][documentation of the `os` package]].

2. Identify a member of that package that will allow you to get the program's command-line arguments as a slice of strings.

3. Check the length of that slice; terminate the program (with a friendly error message) if no username was specified.

4. If a username was specified, use it as before in the rest of your program.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Ranging over a slice

Just like for arrays, you can iterate over a slice using a for-range loop.

The first iteration variable corresponds to the index of the current element.
The second iteration variable is only a copy of the slice's current element.

.play -edit src/slice_range.go  /^//START/,/^//END/

If you only need one of the iteration variables, you can omit the other:

.play -edit src/slice_range2.go  /^//START/,/^//END/

: iteration happens over the length (not the capacity) of the slice



* Table-driven tests

One use case for slices is [[https://go.dev/blog/subtests#table-driven-tests-using-subtests][_table-driven_tests_]], an approach to writing test cases that drastically reduces test-logic duplication:

  func TestIsValid(t *testing.T) {
    type TestCase struct{
      desc     string
      username string
      want     bool
    }
    testCases := []TestCase {
      {"contains two consecutive hyphens", "jub0bs--on-GitHub", false},
      // other test cases...
    }
    for _, tc := range testCases {
      got := github.IsValid(tc.username)
      if got != tc.want {
        t.Errorf("github.IsValid(%q): got %t; want %t", tc.username, got, tc.want)
      }
    }
  }

: use of anonymous struct for slice of test cases



* Namecheck project: use table-driven tests

1. Write a `TestIsValid` test function that uses table-driven tests. If the anonymous struct confuses you, you can declare a `TestCase` struct type at the top of your function.

2. Move all the test cases for the `IsValid` function inside a slice of test cases within your `TestIsValid` test function.

3. You can now safely remove your original test functions.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: note that the name of the type can be omitted in struct literal



* Table-driven subtests

An improvement over table-driven tests is [[https://go.dev/blog/subtests#table-driven-tests-using-subtests][_table-driven_subtests_]]. This approach consists in passing the test logic (as an anonymous function) to `*testing.T`'s `Run` method:

  // the rest of the testing function is unchanged
  for _, tc := range testCases {
    f := func(t *testing.T) {
      got := github.IsValid(tc.username)
      if got != tc.want {
        t.Errorf("github.IsValid(%q): got %t; want %t", tc.username, got, tc.want)
      }
    }
    t.Run(tc.desc, f)
  }

This approach displays information about the different subtests when you run the tests.

It also allows you to limit which subtests to run within a given test function, e.g. only the subtests in `TestIsValid` whose description starts with "too":

  go test -v -run='^TestIsValid/too.*' ./...

: Run method: results of each subtest detailed in output
: https://github.com/golang/go/wiki/TableDrivenTests



* Namecheck project: use table-driven subtests

1. Turn your table-driven tests into table-driven subtests.

2. Run your tests.

3. Using the `-run` flag, run only a fraction of the test cases.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Appending elements to a slice

  names := []string{"foo"}

.image img/slice_append_before.svg _ 500

: https://excalidraw.com/#json=zmXtzqfMn5wEAJTXOwMbe,P15kQvBq2NqwBCam8chFnw

[[https://pkg.go.dev/builtin#append][A built-in function named "append"]] allows you to add elements to the end of a slice. Its last parameter is variadic, which allows you to add multiple elements in one call:

  names = append(names, "bar", "baz")

.image img/slice_append_after.svg _ 500

: https://excalidraw.com/#json=9qoTSCzImp47KqLXlN3V1,KTBQ_exGPDUsez3PJ20XfQ



* Append: under the hood

When `append` is called and its slice argument's backing array is at capacity, it

1. allocates a new array large enough to accommodate both the old and new elements,
2. copies the elements of the slice's backing array into the new array,
3. adds the new elements to the new backing array,
4. returns a slice that points to the new array.

If the old backing array is no longer referenced anywhere in the program, it becomes eligible for garbage collection:

.image img/slice_append_gc.svg _ 500

: https://excalidraw.com/#json=snAWYDiuwLLRDlArjyLp0,ZVZuFKw9kgpna5-maewrKA



* Append: under the hood (cont'd)

How exactly does `append` choose the size of the new backing array? This detail remains unspecified in the language spec. In practice, the Go runtime does the right thing.

However, if you're curious, the following program allows you to peek under the hood:

.play -edit src/append_grow.go  /^//START/,/^//END/

A change in the slice's capacity indicates that the slice reached capacity and `append` had to allocate a new array and copy the elements of the old array into the new one.

However, in this case (since you know in advance how long the slice will ultimately be), all these intermediate allocations and copies are unnecessary and avoidable. How?



* Aliasing

Bear in mind that multiple slices may share the same backing array. In this case, a change to an element of one such slice will be reflected in the other slices:

.play -edit src/slice_spooky.go  /^//START/,/^//END/

In particular, when you pass a slice to a function, the function operates on a copy of that slice, but both the original slice and its copy uses the same backing array:

.play -edit src/slice_spooky_func.go  /^//START/,/^//END/



* Inadvertent slice decoupling

However, remember that the slice returned by `append` may well have a different backing array from that of the original slice:


.play -edit src/slice_aliasing.go  /^//START/,/^//END/

If you forget this subtlety, you may introduce subtle bugs in your programs.

In particular, taking the address of a slice element as you're about to append to that slice is rarely a good idea!

: quiz: append in function on previous slide and ask them why this change isn't reflected in main



* Other operations on slices

[[https://pkg.go.dev/builtin#copy][The built-in `copy` function]]  allows you to copy elements from one slice into another.

[[https://pkg.go.dev/builtin#clear][The built-in `clear` function]] sets all the elements of its slice argument to the zero value of the slice's element type.

Finally, [[https://pkg.go.dev/slices][the `slices` package]] provides many functions for performing usual operations on slices, such as [[https://pkg.go.dev/slices#Equal][testing for equality]], [[https://pkg.go.dev/slices#Sort][sorting]], [[https://pkg.go.dev/slices#BinarySearch][running a binary search]], etc.

ðŸ‘‰ Enough about slices. Let's talk about maps.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Maps

A map is a built-in type that represent an unordered collection of key-value pairs. Names from other languages include _dictionary_ (Python) and _associative_array_ (PHP).

The type of a map of keys of type `K` and values of type `V` is denoted by

  map[K]V

The key type *must* be comparable:

.play -edit src/incomparable_key_type.go /^//START/,/^//END/

Internally, a map stores its key-value pairs in a [[https://en.wikipedia.org/wiki/Hash_table][hash table]].

.image https://golangforall.com/assets/dvoe.svg 100 _



* Initializing a map

You can create and populate a map with a _map_literal_:

.play -edit src/map_literal.go /^//START/,/^//END/

Alternatively, you can use the built-in function `make` to initialize an empty map of the desired type:

.play -edit src/map_make.go /^//START/,/^//END/

As an optional second argument to `make`, you can specify a _size_hint_ as a non-negative integer. The resulting map will be large enough to accommodate that many key-value pairs before requiring [[https://en.wikipedia.org/wiki/Hash_table#Dynamic_resizing][internal resizing]].



* Maps are reference types

The zero value of map types is `nil`.

.play -edit src/map_zero.go /^//START/,/^//END/

Under the hood, a map is simply a pointer to a [[https://en.wikipedia.org/wiki/Hash_table][hash table]]. Therefore, maps [[https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it][can be thought of as "reference types"]].

A function that takes a map operates on a copy of a pointer to the same underlying hash table, and any changes the function makes to the contents of the map will be visible to the caller.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/zorro.svg 200 _

: Under the hood, maps are implemented as a hash tables.



* Map are not comparable

Regardless of their key and value types, maps are not comparable: the compiler won't allow you to use the `==` operator to test the equality of two arbitrary map values.

The only legal comparison is to a literal nil value.

.play -edit src/map_incomparable.go /^//START/,/^//END/

However, you can use [[https://pkg.go.dev/maps#Equal][the `Equal` function]] from [[https://pkg.go.dev/maps][the `maps` package]] to compare two maps whose key type and value type are comparable.

.play -edit src/map_equal.go /^//START/,/^//END/



* Retrieving a value associated to a map key

`m[k]` yields the value associated with a key `k` in a map `m`:

.play -edit src/map_access.go /^//START/,/^//END/

`m[k]` is *not* addressable:

.play -edit src/map_value_not_addressable.go /^//START/,/^//END/

If `k` is absent from `m`, then `m[k]` yields the zero value of `m`'s value type. To distinguish an absent key from a key present in the map but associated to the zero value, you can declare an additional variable of boolean type:

.play -edit src/map_access_comma_ok.go /^//START/,/^//END/

This syntax, known as the "comma-ok idiom", is also useful for other operations.

: yields the actual value: you can operate on m[k] directly (e.g. m[k]++ if map value type is integer)



* Storing a key-value pair in a map

Adding a new key-value pair in a map is straightforward:

.play -edit src/map_store.go /^//START/,/^//END/

If the key was already present in the map, the value associated with it in the map is simply updated:

.play -edit src/map_update.go /^//START/,/^//END/

Be careful: attempts to store a value in a `nil` map cause a panic!

.play -edit src/map_store_panic.go /^//START/,/^//END/



* Removing a key-value pair from a map

To remove a key `k` and its value from a map `m`, use built-in function `delete`:

  delete(m, k)

If the map is `nil` or if the key is already absent from the map, deleting the key from the map is a no-op.

.play -edit src/map_delete.go /^//START/,/^//END/



* Implementing a set using a map

A mathematical set is an unordered collection of unique elements.

Unlike Python, Go doesn't yet provide a native set type, but... maps to the rescue!

You can implement a set of `string` simply as a `map[string]struct{}`:

.play -edit src/map_set_nothing.go /^//START/,/^//END/

: amortized O(1) insertion/deletion/membership



* Ranging over a map

You can iterate over a map using `for` and `range`:

.play -edit src/map_range.go /^//START/,/^//END/

At each iteration, the variables yielded by the `range` expression hold copies of
the key and value.

Maps are unordered collections. Surprisingly, perhaps, the iteration order is [[https://cacm.acm.org/magazines/2022/5/260357-the-go-programming-language-and-environment/fulltext#body-9][specified as nondeterministic]]! Try running the code snippet above a few times: the iteration order will typically change from one program execution to the next. See [[https://www.hyrumslaw.com/][Hyrum's Law]].



* Namecheck project: table-driven subtests using a map

1. Remove the field named `desc` from the declaration of your `TestCase` struct type.

2. In your `TestIsValid` function, range over a `map[string]TestCase` instead of a `[]TestCase`.

3. Run your tests.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Ranging over a map in a deterministic order

To range over a map in a certain order, you must

- collect all of the map's keys in a slice,
- sort the slice of keys as desired (e.g. in lexicographical order),
- access the map values as you range over the sorted slice of keys.

.code -edit src/map_range_deterministic.go /^//START/,/^//END/

See [[https://go.dev/play/p/UwzU1ZKpVNP][this Playground]].

The `Keys` function (and other useful generic functions that operate on maps) are provided by [[https://pkg.go.dev/golang.org/x/exp/maps][the `golang.org/x/exp/maps` package]].



* Other operations on maps

[[https://pkg.go.dev/builtin#clear][The built-in `clear` function]] deletes all the elements of its map argument, leaving the map empty.

Also, [[https://pkg.go.dev/maps][the `maps` package]] provides functions for performing usual operations on maps, such as [[https://pkg.go.dev/maps#Equal][testing two maps for equality]], [[https://pkg.go.dev/maps#Clone][copying a map]], [[https://pkg.go.dev/maps#Copy][merging two maps]], etc.

ðŸ‘‰ We'll use maps again later in our project. Let's learn about structs.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Declaring a named struct type

A [[https://go.dev/ref/spec#Struct_types][struct type]] is a sequence of _fields_. Each field typically has both a name and a type:


  type User struct {
    firstName string
    lastName  string
    isAdmin   bool
  }

_Embedded_fields_ are fields that have a type but no explicit name; their effective name is derived from the name of their type. Embedding is useful (though not necessary) for [[https://en.wikipedia.org/wiki/Object_composition][composition]].

  type Manager struct {
    *User
    title string
  }

All fields of a struct value are laid out in a contiguous fashion in memory; the compiler may add some padding between fields to respect [[https://en.wikipedia.org/wiki/Data_structure_alignment][alignment rules]], though.

: compare to Java classes, where everything but primitive types is a reference (not memory/cache efficient)



* Limitation on recursive struct types

A struct type `T` cannot have a field of type `T`:

  type User struct {
    firstName string
    lastName  string
    spouse    User   // compilation error
  }

However, it can have fields of type `*T` and `[]T`, etc.

  type User struct {
    firstName string
    lastName  string
    spouse    *User
    friends   []User
  }


* A struct type's zero value

The zero value of a struct types has all its fields set to their types' zero values:

.play -edit src/struct_zero.go  /^//START/,/^//END/

Struct types are not "reference types". They cannot take the value `nil`.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/zorro.svg 200 _



* Constructing a struct value

Given the following type declaration,

  type User struct {
    firstName string
    lastName  string
    isAdmin   bool
  }

you can construct a value of this type via a *struct*literal*,

  u := User{
    firstName: "Julien",
    lastName: "Cretel",
  }

Fields omitted from the struct literal are zero-valued. In the example above, the `isAdmin` field of `u` is `false`.



* Avoid unkeyed literals

Consider the following struct type and unkeyed and keyed literals of it:

.play -edit src/unkeyed_literals.go /^//START/,/^//END/

[[https://go.dev/doc/go1compat#expectations][You should avoid unkeyed literals]] (esp. of cross-package struct types); in fact, the `vet` subcommand warns you about them.

Their reliance on the order of the fields in the struct-type declaration makes them less expressive (harder to write and read) and brittle to changes in the declaration ([[https://www.youtube.com/watch?v=v24wrd3RwGo&t=5m2s][addition of a field]], or re-ordering of the fields).

Support for unkeyed struct literals [[https://www.youtube.com/watch?v=v24wrd3RwGo&t=19m28s][may be removed in a future version of Go]].

: error-prone
: In struct literals, you can either specify all the...
: why error prone: easier to swap the fields,
: won't be affected by reordering of the fields in the type declaration
: unkeyed literal acceptable for anonymous structs (e.g. in table-driven subtests)
: legitimate reason to change order of fields: minimize footprint or fit snuggly in cache line
: the compiler emits no warnings, but go vet does



* The empty struct

A remarkable struct type is the empty struct, i.e. a struct type that contains no fields:

  struct{}

This type can take only one value:

  struct{}{}

The memory footprint of this value is zero.

Contrary to what you may believe, the empty struct is often useful.

: conveys intent that data doesn't matter
: sets
: signalling with channels



* Field access

Field access uses the usual dot syntax present in many languages:

  type User struct {
    firstName string
    lastName  string
    isAdmin   bool
  }


  func main() {
    u := User{Name: "Julien"}
    fmt.Println(u.Name) // Julien
  }

Struct fields are addressable:

  fmt.Println(&u.Name) // some address in hexadecimal



* Field access via pointer

Struct fields are also conveniently accessible through a pointer to the struct value in question:

  type User struct {
    Name    string
    IsAdmin bool
  }

  func main() {
    u := &User{Name: "Julien"}
    fmt.Println((*u).Name) // ok but unnecessary
    fmt.Println(u.Name)    // syntactic sugar!
  }



* Promoted fields

A field of an embedded field is promoted to the embedding field.

In the example below, the `firstName` field of struct type `User` is a promoted field of struct type `Manager`:

  type User struct {
    firstName string
    lastName  string
    isAdmin   bool
  }

  type Manager struct {
    *User
    title string
  }

  func main() {
    j := User{Name: "Julien"}
    m := Manager{User: j, title: "Big Boss"}
    fmt.Println(m.firstName) // Julien
  }



* Exported or unexported fields

The case of a struct field's first letter dictates whether that field is exported.

  type User struct {
    FirstName string
    LastName  string
    isAdmin   bool
  }

Keeping struct fields unexported is the primary mechanism for encapsulation in Go.

Don't export the fields of your package-level struct types (unless you have to, e.g. for JSON decoding).

Completely encapsulated struct types are _opaque_: they export none of their fields. For example, see `time.Time` or `regexp.Regexp`.

To allow clients of your package to manipulate values of such types, provide functions and methods.



* Struct as function parameters

Functions that have a struct as parameter operate on a entire copy of that struct!

.play -edit src/struct_func_param.go /^//START/,/^//END/



* Struct as function parameters (cont'd)

Use pointers if you want changes to be reflected outside of the function.

.play -edit src/struct_func_param_pointer.go /^//START/,/^//END/

Or return the updated value as a result of the function.



* Struct field tags

The declaration of a struct type may specify a _tag_ for each of the fields. A field tag is a string value that follows the field's type in the struct type's declaration.

A field tag is typically used for mapping the correspondance between names in Go and JSON for encoding/decoding purposes:

  type User struct {
    FirstName string `json:"first_name"`
    LastName  string `json:"last_name"`
    IsAdmin   bool   `json:"is_admin"`
  }

For JSON decoding to work properly, fields *must* be exported.



* Struct comparability

A struct type is comparable only if the types of all its fields are themselves comparable:

.play -edit src/struct_comparability.go  /^//START/,/^//END/

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/stovepipe-hat-front.svg 200 _

[[https://go.dev/play/p/axkpaElUyHI][Live demo in Playground]]



* Exercise: design a binary tree

A [[https://en.wikipedia.org/wiki/Binary_tree][binary tree]] is made up of nodes that each contain a value and references to up to two children nodes. Here is an example of a binary tree whose values are integers:

.image img/binary_tree.svg 250 _

1. Open the Go Playground.

2. Declare a type named `Tree` for representing one node of this kind of binary tree.

3. In your `main` function, declare a `Tree` value that corresponds to the tree shown above, then print that value.


: https://excalidraw.com/#json=b_AryM5iFA9oUa2kMT6sd,saZDan7wON3vgjTYRDYsgQ


* Exercise: design a binary tree (cont'd)

4. Implement the following function:

  func Size(t *Tree) int

It should return the number of nodes in its argument.

5. Implement the following function:

  func Sum(t *Tree) int

It should return the sum of the values of all the nodes in its argument.

A solution is available on the [[https://go.dev/play/p/Wwy4gr9Az1_W][Go Playground]]. Is it satisfactory? What if we wanted to use another type for node values? Discuss.



* A glimpse of generics in Go

Go 1.18 added _generics_ to the language.

Types and functions can now be parameterized by types (see [[https://go.dev/play/p/CqiNm5rn6Ie][this Playground]]):

  type Tree[E any] struct {
    Left  *Tree[E]
    Elem  E
    Right *Tree[E]
  }

  func Size(t *Tree[E]) int
  func Sum(t *Tree[E]) E

Type parameter `T` is constrained by `any` ([[https://pkg.go.dev/builtin#any][a predeclared alias for `interface{}`]]).
In other words, `T` can be any type: `bool`, `int`, `string`, etc.


* A glimpse of generics in Go (cont'd)

You don't need to master generics at this stage of your Go learning, but a basic understanding of generic syntax will benefit you.

Generics promote code reusability while providing some compile-time guarantees.

You may never write generic code yourself, but you will likely use some of the standard-library packages that provide generic functions, such as `slices`, `maps`, and `cmp`.

For more details about generics, see [[https://go.dev/doc/tutorial/generics][Tutorial: Getting started with generics]].

ðŸ‘‰ Now, let's learn about methods, which are the key to interfaces.



* Methods

Methods are functions that are attached to a specific type.

They distinguish themselves from _package-level_functions_, e.g.

  func MatchString(pattern string, s string) (matched bool, err error) // package-level function

by the presence (in a pair of parentheses between the keyword `func` and the method's name) of an extra parameter called the _method's_receiver_:

  func (re *Regexp) MatchString(s string) bool // method on the *Regexp type

Methods are tightly related to _interfaces_, which are the primary mechanism for polymorphism.

Live demo on [[https://go.dev/play/p/axkpaElUyHI][the Playground]].

: Now let's talk about methods in Go, so we can turn the `IsValid` and `IsAvailable` functions into methods.
: * Value receiver vs. pointer receiver

: A method can have either a value receiver or a pointer receiver.



* Namecheck project: turn IsValid and IsAvailable into methods

To pave the way for the introduction of useful interface types in our project, let's create some types that allows users to check the validity and availability of usernames on each platform and turn our two functions into methods.

1. In the `github` package, declare a `GitHub` type based on an empty struct.

2. Turn `IsValid` and `IsAvailable` into methods on that type (use a pointer receiver).

3. Adjust your tests in `github_test.go` and `main.go`.

4. Repeat steps 1-4 for the `reddit` package.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _




* Interfaces



* Interfaces in a nutshell

Interfaces (and now also generics) enable [[https://en.wikipedia.org/wiki/Polymorphism_(computer_science)][_polymorphism_]] in Go:
they allow you to manipulate different concrete type that provide the same behavior(s).

Contrary to all the types that we've covered so far, interfaces are abstract types. An interface defines a set of types that provide some (zero or more) specific operations:

  type Climber interface {
    Climb(int) error
  }

Interfaces, by focusing on _behavior_ rather than _implementation_, promote decoupling!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/arts/ballet.svg 200 _

: The names of method parameters are inconsequential and can be omitted
: what matters are the names and signatures of the methods required by the interface.



* Naming convention for interface types

Resist the temptation to name your interface types with an "I" prefix, as you would in other languages (e.g. `IEnumerable` in C#)!

Also, in Go, the names of interface types are typically nouns rather than adjectives.

For a single-method interface types, convention dictates that its name be derived by appending "er" to the name of its method, even if doing so yields a weird name:

  type Stringer interface {
    String() string
  }

For interfaces types that require multiple methods or are composed of multiple smaller interfaces, naming conventions are not as firmly established. Pick something sensible.



* Interface satisfaction in other languages

In many other languages, interface satisfaction is specified on the type declaration of the implementor:

  class PokerHand implements Comparable<? super PokerHand>  // Java
  class Template implements iTemplate                       // PHP
  class BoomerangCollection : IEnumerable                   // C#

Not so in Go, and that's one reason why interfaces are one of the most fascinating and liberating aspect of the language!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/liberty.svg 250 _



* Interface satisfaction in Go is implicit

If a concrete type has _all_ the methods required by the interface, the concrete type automatically satisfies the interface!

.play -edit src/interface_sat.go /^//START/,/^//END/

Important: `*Mountaineer` satisfies the `Climber` interface, but `Mountaineer` doesn't.

: A value of that concrete type can then be used wherever an interface value is expected.
: structural typing as opposed to nominal subtyping



* Interface satisfaction: the fine print

Some interface types require implementors to follow additional rules. For instance,

- [[https://pkg.go.dev/io/#Reader][the `io.Reader` interface]] places restrictions on what can be done with the parameter and results of its `Read` method, and
- [[https://pkg.go.dev/net/http#RoundTripper][the `http.RoundTripper` interface]] requires that implementors be safe for concurrent use by multiple goroutines.

Bear in mind that such rules are not enforcible by the compiler, and that the onus is on you to respect them in your implementations.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _

: If you don't, your code may not work as expected.



* Keep interfaces small

The [[https://en.wikipedia.org/wiki/Interface_segregation_principle][Interface-Segregation principle]] states that clients should not be forced to depend on methods that they do not use. See [[https://www.youtube.com/watch?v=zzAdEt3xZ1M&t=12m49s][Dave Cheney - SOLID Go Design]].

Accordingly, refrain from _interface_pollution_, i.e. declaring interface types with many methods. Smaller interfaces are comparatively easier to satisfy and more composable.

[[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=5m18s][As Rob Pike puts it]]: _the_bigger_the_interface,_the_weaker_the_abstraction_.

Many of the interface types provided by Go's standard library are single-method:
`error`, `fmt.Stringer`, `io.Writer`, `io.Reader`, `http.Handler`, etc.

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _

: small interfaces are also easier to redeclare locally, in order to promote source decoupling
: could redeclare Stringer locally to avoid namecheck having to depend on fmt



* Namecheck project: declare a Validator interface

1. In `main.go`, declare the following interface type:

  type Validator interface {
    IsValid(string) bool
  }

2. Do `*github.GitHub` and `*reddit.Reddit` satisfy that interface? Explain.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: mention that we're defining Validator after the fact!



* Namecheck project: declare an Availabler interface

1. Still in `main.go`,  declare the following interface type:

  type Availabler interface {
    IsAvailable(string) (bool, error)
  }

2. Do `*github.GitHub` and `*reddit.Reddit` satisfy that interface? Explain.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Interface composition

Consider these two interfaces:

  type Reader interface {
    Read([]byte) (n int, err error)
  }

  type Closer interface {
    Close() error
  }

To declare an interface type that is both a `Reader` a `Closer`, you could of course just list the required methods:

  type ReadCloser interface {
    Read([]byte) (n int, err error)
    Close() error
  }

But no need to repeat yourself! Interface composition is easier than this in Go...



* Interface composition (cont'd)

You can declare a larger interface type by simply listing the more elementary interfaces it's made of:

  type ReadCloser interface {
    Reader
    Closer
  }

The declaration above is equivalent to the one below but requires no code duplication:

  type ReadCloser interface {
    Read([]byte) (n int, err error)
    Close() error
  }

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 150 _

: A mix of methods and interface names is also allowed:



* Namecheck project: declare a Checker interface

1. Still in `main.go`, declare an interface type named `Checker` by composition of the following interface types:

- `Validator`
- `Availabler`

2. Do `*github.GitHub` and `*reddit.Reddit` satisfy that interface? Explain.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: use a slice of Checkers

1. In your `main` function, create a slice of `Checker` with two elements:

- a pointer to a `github.GitHub`
- a pointer to a `reddit.Reddit`

2. Simplify the existing code by ranging over the slice of `Checker` values.

3. There currently is no way to ask a `Checker` to which platform (GitHub or Reddit) it's dedicated. Any idea?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* fmt.Stringer

[[https://pkg.go.dev/fmt#Stringer][`fmt.Stringer`]] is an interface type that requires a single method:

  type Stringer interface {
    String() string
  }

If a type satisfies `fmt.Stringer`, its `String` method governs the textual representation that functions from the `fmt` package use for that type.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _



* fmt.Stringer

.play -edit src/stringer.go /^//START/,/^//END/



* Namecheck project: satisfy the fmt.Stringer

1. Modify the declaration of the `Checker` interface so that the latter also be an `fmt.Stringer`.

2. Do `*github.GitHub` and `*reddit.Reddit` still satisfy the `Checker` interface? If not, fix that.

3. Make good use of `Checker`'s new `String` method in your `main` function.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Other notable interfaces: the empty interface

The empty interface is an interface that requires no method:

  interface{}

Therefore, it is automatically satisfied by _all_ types (no exception) in Go.

Go 1.18 [[https://go.dev/doc/go1.18#generics][introduced]] `any` as a [[https://pkg.go.dev/builtin#any][predeclared alias for `interface{}`]]:

  type any = interface{}

The empty interface is useful for maximum flexibility in functions that require it:

  func Println(a ...any) (int, error)



* Other notable interfaces: the empty interface (cont'd)

Because the empty interface is the least specific type in Go, you should use it sparingly.

[[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=7m36s][As Rob Pike puts it]], the empty interface says nothing.

If you declare a function that has a parameter of type `any`, Go's type checker can't provide any compile-time guarantees about the nature of that parameter.

Therefore, peppering empty interfaces all over the business layer of your application (where being very specific pays off) is a bad idea!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _

: a bit like *void in C



* Other notable interfaces: error

`error` is a interface type predeclared by the language:

  type error interface {
    Error() string
  }

You can declare your own types and make them satisfy the `error` interface.

  type UnkownAvailabilityError struct {
    Username string
    Platform string
    Cause    error
  }

  func (e *UnkownAvailabilityError) Error() string {
    const tmpl = "unknown availability of %q on %s: %v"
    return fmt.Sprintf(tmpl, e.Username, e.Platform, e.Cause)
  }



* Other notable interfaces: io.Reader and io.Writer

The `io` package provides two complementary interface types: `Reader` and `Writer`.

`io.Reader` represents a _source_ of bytes; it's satisfied by `os.Stdin`, `*os.File`, etc.

  type Reader interface {
    Read(dst []byte) (int, error)
  }

`io.Writer` represents a _sink_ of bytes: it's satisfied by `os.Stdout`, `*os.File`, etc.

  type Writer interface {
    Write(src []byte) (int, error)
  }

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/projects/network-side.svg 200 _



* Favor interface parameters when all you care about is behavior

If a given function parameter is supposed to provide _behavior_ (rather than data), you should strive to use an interface type (rather than a concrete type) for that parameter.

This principle isn't specific to Go and is known as [[https://blog.ndepend.com/programming-interface-simple-explanation/][_programming_to_an_interface_]].

For example, don't do this:

  type Tree struct {...}
  func (t *Tree) WriteTo(f *os.File) error

Instead, do this:

  type Tree struct {...}
  func (t *Tree) WriteTo(w io.Writer) error

The latter is more flexible, easier to test, promotes decoupling, and guides you towards the correct implementation.

: os.File has a lot of methods that are not relevant to what Tree's WriteTo is supposed to do



* Require no more, promise no less

If what's of interest is behavior rather than implementation, your functions shouldn't ask for behaviors that they don't need.

In other words, if a function has an interface parameter, that interface type should be as "small" as possible.

Don't do this:

  func (t *Tree) ReadFrom(rw io.ReadWriter) error

Instead, do this:

  func (t *Tree) ReadFrom(r io.Reader) error

Again, this is more flexible, testable, and promotes correctness of implementation.

See [[https://www.youtube.com/watch?v=zzAdEt3xZ1M&t=12m36s][Dave Cheney - SOLID Go Design]].

: a reason to keep interfaces small
: This principle is similar in spirit to the Domain Driven Domain's principle known as "keeping ports small".



* Avoid premature abstraction

An aphorism attributed to Rob Pike is: donâ€™t design with interfaces, discover them.
See [[https://www.youtube.com/watch?v=YXV7sa4oM4I&t=14m][Rob Pike - The Go Programming Language and Environment]].

In other words, you should resist the temptation to declare interface types upfront.

Instead, start with concrete types and let interfaces emerge organically, as needed
(e.g. for abstraction purposes).

Note that we declared the `github.GitHub` and `reddit.Reddit` struct types first,
and only then did we declare the interface types that pointers to those types satisfy.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Namecheck project: how to swap a fake HTTP client for the real one?

The `IsAvailable` method still isn't easily testable...

It unconditionally sends a HTTP request to the social network of interest, which means we cannot write unit tests (in the strict sense of the term) for it.

For instance, we'd like to check that, if the response from GitHub has status code `200`, then `github.Github`'s `IsAvailable` method returns `false,`nil`.

We'd need some way of injecting the real HTTP client in our production code and injecting some fake HTTP client in our test code... Any ideas?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _

: test behaviour of IsAvailable given behaviour of its Client
: system under test: github.GitHub
: the HTTP client is a collaborator with side effects => good candidate for mocking



* Diving into the source code of the net/http package

Function `http.Get` delegates to a `Get` method on something named `DefaultClient`:

  package http
  // -snip-
  func Get(url string) (resp *Response, err error) {
    return DefaultClient.Get(url)
  }

`DefaultClient` simply is a package-level variable of type `*http.Client`:

  package http
  // -snip-
  var DefaultClient = &Client{}

Since we want to mock/stub the `*http.Client` type, we need an interface type that `*http.Client` implements...

Does the `net/http` package provide such an interface? If not, is that a problem? ðŸ˜

What about in languages other than Go, such as Java, C#, or PHP?



* Implicit satisfaction makes "stubbing" easy!

You can declare an interface type that will be satisfied by your own existing types.

But you can even create your own interface type for concrete types that you do not own and for which no useful interface is readily provided!

Therefore, you can "create a placeholder" to be filled by...

- ... the real thing in your production code, and
- ... some [[https://www.martinfowler.com/bliki/TestDouble.html][_test_double_]] (mock, stub, fake, etc.) in your test code!

See [[https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742#e976][Mat Ryer's - 5 simple tips and tricks for writing unit tests in #golang]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/lifting-1TB.svg 200 _

: definition of test double at https://www.martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs



* Namecheck project: move your main.go to a cmd folder

1. Create a folder named `cmd`; move your `main.go` file to `cmd/`.

2. Create a file `namecheck.go` that belongs to a new package itself named `namecheck`.

  namecheck
  â”œâ”€â”€ cmd
  â”‚Â   â””â”€â”€ main.go
  â”œâ”€â”€ github
  â”‚Â Â  â”œâ”€â”€ github.go
  â”‚Â Â  â””â”€â”€ github_test.go
  â”œâ”€â”€ go.mod
  â”œâ”€â”€ namecheck.go
  â””â”€â”€ reddit
      â””â”€â”€ reddit.go

3. From the root of your project, check that `main.go` still compiles:

  go run cmd/main.go



* Namecheck project: declare an interface for *http.Client

1. In `namecheck.go`, judiciously declare a useful interface named "Getter" that type `*http.Client` already satisfies.

2. In your `GitHub` and `Reddit` struct types, add a field of type `namecheck.Getter`:

  type GitHub struct {
    Getter namecheck.Getter
  }

5. In your `IsAvailable` methods, call the `Getter`'s method instead of `http.Get`.

6. In your `main` function, _inject_ the actual HTTP client when you instantiate the `GitHub` and `Reddit` struct types.

: Now you have everything you need to create a "fake" Getter for testing purposes!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _

: unit test: no I/O, limit site effects
: email sender: you don't want to send an email every time
: payment system: unless e2e tests, don't want to trigger a real payment in unit tests



* Single-method adapter

: Remember that you can add methods to any of your named types, regardless of their underlying types.

Consider the following single-method interface type:

  type Climber interface {
    Climb(meters uint) error
  }

A [[https://pkg.go.dev/net/http#HandlerFunc][frequently useful trick]] to implement such an interface is the following. First, declare a type based on a function whose signature matches that of the interface's method:

  type ClimberFunc func(uint) error

Then, declare a method that simply delegates to the underlying function! ðŸ¤¯

  func (f ClimberFunc) Climb(meters uint) error {
    return f(meters)
  }

: Note that the method's implementation simply delegates to the underlying function.

Such an [[https://en.wikipedia.org/wiki/Adapter_pattern][_adapter_]] allows easy conversion of ordinary functions to the interface type:

  climber := Climber(func(meters uint) {return nil})



* Namecheck project: "stub" the HTTP client

1. Create a package named `namechecktest`. In it, declare the following struct type:

  type SuccessfulGetter struct {
    StatusCode int
  }

2. Make `namechecktest.SuccessfulGetter` satisfy your `namecheck.Getter` interface (hint: make use of `http.NoBody`). Its `Get` method should unconditionally succeed and return the specified status code.

3. Now write a few unit tests for `github.GitHub`'s `IsAvailable` method and run them.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 150 _

: https://www.martinfowler.com/articles/mocksArentStubs.html
: rationale for the package name: https://www.youtube.com/watch?v=cAWlv2SeQus&t=1685s



* Namecheck project: simulate support for many platforms

1. In `main.go`, judiciously populate your `[]Checker` slice with twenty pointers to the same `github.GitHub` variable.

2. Similarly, populate your slice of checkers with twenty pointers to the same `github.GitHub` instance.

3. Run your executable.

4. Comment on user experience. Is it fast? How could you improve things?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/stovepipe-hat-front.svg 250 _



* Concurrency



* What do we mean by "concurrency"?

Concurrency is the art of composing a program in terms of independent computations.

Go has native support (i.e. in the language and runtime) for concurrency.

Go's concurrency model arguably is one of the language's most attractive features,
but can be difficult to learn and master.

.image https://i.stack.imgur.com/QjsGt.png 200 _

: hence being relegated to the end of many learning resources



* Concurrency metaphors

Disclaimer: many cooking metaphors ahead!

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 400 _



* Metaphor: a cheeseburger recipe

You can describe a recipe in a sequential manner or in a _concurrent_ manner.

.image img/burger.svg _ 700

If you've got help in the kitchen, you can _parallelize_ and finish the dish faster.



* Concurrency is not parallelism

*Concurrency*

- the art of structuring a program in terms of *independent* computations
- a property of the program's *code*

*Parallelism*

- the *simultaneous* execution of multiple computations on multiple cores
- a property of a program's *execution*

.image https://go.dev/blog/store/gophers.jpg 150 _



* Parallelism is not the goal of concurrency

Concurrency enables scalability through parallelism, but [[https://www.youtube.com/watch?v=jgVhBThJdXc&t=1925s][parallelism isn't the goal]].

[[https://www.youtube.com/watch?v=jgVhBThJdXc&t=1278s][Writing concurrent code is a valuable act of design]] regardless of whether the program will eventually be run in parallel.

And if well-designed concurrent code _does_ run in parallel, we can reasonably expect performance to scale gracefully as the number of cores increase.

See also

- [[https://www.youtube.com/watch?v=oV9rvDllKEg][Rob Pike - Concurrency is not Parallelism (2012)]].
- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=3m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]

: metaphor: cooking recipe typically has a concurrent component, but whether you can prepare it in parallel depends on the number of cooks/hobs you have!



* Go's concurrency model

Go's approach to concurrent programming is largely inspired by [[https://dl.acm.org/doi/10.1145/359576.359585][Tony Hoare's  _Communicating_Sequential_Processes_ (1978)]], a paper that was decades ahead of its time.

In CSP, concurrent programs are structured as independent processes that execute sequentially and communicate by passing messages.

.image https://i.stack.imgur.com/QjsGt.png 200 _

Two fundamental mechanisms for concurrency in Go are

- goroutines: lightweight threads managed by the Go runtime
- channels: typed pipes used to communicate and synchronize between goroutines




* Goroutines

A goroutine is a concurrent function execution.

It can be thought of as a very lightweight thread: it's common for programs to have 1000s of goroutines, even on a single core.

The `main` function is itself a goroutine that is created when the program starts.

Each goroutine gets its own stack, which starts small and grows/shrinks as required.

.image https://go.dev/blog/store/gophers.jpg 300 _

: goroutines != futures/promises/async
: doesn't return anything that will eventually contain the results



* The Go scheduler

The _Go_scheduler_ is a part of the Go runtime that automatically multiplexes goroutines onto operating-system threads and manages their scheduling for us.

It continually observes the run-time behavior of goroutines and decides to suspends them when they block and then resumes them when they become unblocked.

No need for you to think about it yet; for now, simply picture the Go scheduler and goroutines as a chef and his/her kitchen assistants.

.image https://rrsg.s3.amazonaws.com/wp-content/uploads/2020/03/25180622/90517519_1171371749860657_3506201698723816143_n.jpg 250 _

: goroutines are non-preemptive: they cannot be interrupted
: switching goroutines is much cheaper than switching OS threads
: also OS threads typically take 1Mo of memory compared to 2kb



* The go keyword

The `go` keyword spawns a new goroutine: it causes the function call to which it applies to get executed "in the background":

  go grindCoffeeBeans(nbBeans)
  go frothMilk()

`go` statements do not block; they _immediately_ yield control to the next instruction.

The function's arguments (if any) are evaluated _before_ the goroutine starts.

The function's results (if any) are lost, but channels can be used to communicate values between goroutines.



* go keyword applied to an anonymous function

Launching an anonymous function as a goroutine is sometimes convenient for grouping statements that should be executed in the background:

  go func() {
    fmt.Println("Don't mind me!")
    fmt.Println("I'm just running in the background...")
  }()

Just don't forget to invoke it!

  go func() {
    fmt.Println("Don't mind me!")
    fmt.Println("I'm just running in the background...")
  } // missing parentheses

: goroutine terminology: spawning/spawned, parent/child



* Goroutines vs. Unix processes

It's useful to compare goroutines to Unix processes...

The `go` keyword is [[https://www.youtube.com/watch?v=oV9rvDllKEg&t=14m45s][conceptually similar]] to the ampersand operator (`&`) in Unix shells.

  #!/usr/bin/env sh

  grindCoffeeBeans &
  frothMilk &

However, unlike a Unix process, a goroutine has no concept of an ID (see why [[https://go.dev/talks/2014/go4gophers.slide#38][here]]).

Therefore, a goroutine cannot readily be _killed_.



* Beware goroutine leaks

Before spawning a new goroutine, you must understand exactly under what conditions it will terminate. See [[https://github.com/golang/go/wiki/CodeReviewComments#goroutine-lifetimes][CodeReviewComments - Goroutine lifetimes]].

Goroutines may be cheap, but they're not free. If your program carelessly spawns goroutines, it is at risk of _leaking_goroutines_, i.e. accumulating "zombie" goroutines that are unable to do any meaningful work and that never terminate!

Symptoms of a goroutine leak include memory leaks and program crashes! ðŸ˜±

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 200 _



* Namecheck project: make room for another main.go

We'll experiment with concurrency inside another `main.go`. Later, we'll write a server in that file. Let's set things up!

1. Create a folder named "cli" within the `cmd` folder. Move your `main.go` to `cmd/cli/`.

2. Create a folder named "server" within the `cmd` folder. Create a new `main.go` there.

  namecheck
  â”œâ”€â”€ cmd
  â”‚Â Â  â”œâ”€â”€ cli
  â”‚Â Â  â”‚Â Â  â””â”€â”€ main.go
  â”‚Â Â  â””â”€â”€ server
  â”‚Â Â      â””â”€â”€ main.go
  â”œâ”€â”€ github
  â”‚Â Â  â”œâ”€â”€ github.go
  â”‚Â Â  â””â”€â”€ github_test.go
  â”œâ”€â”€ go.mod
  â”œâ”€â”€ namecheck.go
  â””â”€â”€ reddit
      â”œâ”€â”€ reddit.go
      â””â”€â”€ reddit_test.go



* Exercise: concurrent coffee making

Write two functions, `grindCoffeeBeans` and `frothMilk`, that

- have no parameters and return no results,
- simply write an informative message to stdout.

Call them concurrently in the `main` function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _

: Q: Which message will be printed first? We can't tell. in an indeterminate order. Up to the scheduler.



* Exercise: concurrent coffee making (first attempt)

.play -edit src/goroutines_without_waitgroup.go /^//START/,/^//END/

Does the program behave as you expected? Why or why not?



* main does not wait!

In general, nothing gets written to stdout because

- the two `go` statements _immediately_ transfer control back to `main`,
- `main` terminates _before_ your two goroutines can terminate normally,
- and when `main` terminates, all goroutines are killed and the program ends.

We must tell `main` to "wait" until the two goroutines terminate normally. Any ideas?

.image https://go.dev/blog/store/gophers.jpg 300 _



* Exercise: concurrent coffee making (with sleep)

Sleep a bit at the end?

.play -edit src/goroutines_with_sleep.go /^//START/,/^//END/

However, this solution is not entirely satisfactory. Why?

: inefficient at best, nondeterministic at worst



* Sprinkling sleeps on your code is no way to coordinate goroutines

How long should the sleep be, exactly? Impossible to know in advance.

- Wait too little: `main` terminates too quickly for all the other goroutines to terminate.
- Wait too long: `main` ends up needlessly spinning and wasting time.

.image https://drek4537l1klr.cloudfront.net/youngman/Figures/f0255-01.jpg 200 _

Sleeping is simply not a reliable and efficient way of coordinating goroutines!

To properly tell the `main` function to wait, we need another mechanism...

: there are legitimate use cases for `time.Sleep` in a Go program, but...



* Wait groups

The [[https://pkg.go.dev/sync][`sync` package]] provides a useful mechanism: _wait_groups_.

A wait group implements something like a [[https://en.wikipedia.org/wiki/Barrier_(computer_science)][_barrier_]]: it allows you to wait for a group of goroutines to terminate before moving on.

Wait groups are particularly useful when the number of goroutines to spawn is not known in advance.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/arts/upright.svg 200 _

: Java equivalent: CountDownLatch: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CountDownLatch.html
: e.g. if you're spawning a goroutine for each line of a file that you're reading, or for each element received from a channel
: wait groups not needed in fan-out/fan-in if number of tasks known in advance
: compare https://go.dev/play/p/cnXXJFTUPO1 to https://go.dev/play/p/MHjuGwsP_hJ



* Declaring a wait group

The zero value of type [[https://pkg.go.dev/sync#WaitGroup][`sync.WaitGroup`]] is readily usable:

  var wg sync.WaitGroup

A `sync.WaitGroup` is typically declared within a function. Declaring one at the top level is rarely (if ever) useful.

  var wg sync.WaitGroup // bad

  func main() {
    // ...
    var wg sync.WaitGroup // good
    // ...
  }



* How to use a wait group

A wait group is little more than a counter safely usable from multiple goroutines.

A wait group has three methods:

  func (wg *WaitGroup) Add(delta int)
  func (wg *WaitGroup) Done()
  func (wg *WaitGroup) Wait()

- `Add` increments the counter by `delta`. Call it _just_before_ spawning a goroutine.
- `Done` decrements the counter by 1. Call it _at_the_very_end_ of each spawned goroutine, typically via a `defer` statement.
- `Wait` blocks until the counter goes back to 0. Call it at the point of the spawning goroutine where you need to wait for the spawned goroutines to terminate.



* How not to misuse wait groups

Calls to `Add` must take place in the spawning goroutine, _not_ within the child goroutine.

Calls to `Add` with a positive delta that occur when the counter is zero must happen before the call to `Wait`.

Finally, a `sync.WaitGroup` must not be copied after first use. `go`vet` [[https://go.dev/play/p/2KzpEuzFO-j][alerts you about such programming mistakes]].

Therefore, if a function needs to operate on a wait group that was declared elsewhere, pass a *pointer* to it (`*sync.WaitGroup`) as an parameter.

.image https://go.dev/blog/gopher/plush.jpg 200 _



* Exercise: concurrent coffee making (using a wait group)

Use a wait group to make `main` wait until both `grindCoffeeBeans` and `frothMilk` have terminated before `main` itself can terminate.

Tip: you can apply the `go` keyword to an anonymous function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _

: if you don't control the functions you want to spawn as goroutines, wrap them in anonymous funcs that capture the waitgroup



* Exercise: concurrent coffee making (using a wait group)

(implementations of `grindCoffeeBeans` and `frothMilk` are as before)

.play -edit src/goroutines_with_waitgroup.go /^//START/,/^//END/

: mention that Go's runtime embarks a rudimentary deadlock detector
: don't forget the pair of parens at the end of each function literal!
: What happens if I remove a wg.Done()? deadlock
: What happens if I remove a wg.Add(1)? only one of the two goroutine will likely have time execute



* Goroutines execute in the same address space

For example, a goroutine can pass a pointer to another goroutine, and the latter can dereference that pointer without causing an access violation.

[[https://go.dev/doc/effective_go.html#goroutines][The onus is on you to be careful]] in order to avoid _data_races_!

A [[https://en.wikipedia.org/wiki/Race_condition#Data_race][data race]] occurs when multiple goroutines write to and read from the same memory location in a concurrent fashion (i.e. at the "same" time).

Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access. See [[https://go.dev/ref/mem#tmp_1][The Go Memory Model]].

.image http://alinken.people.ua.edu/uploads/8/7/9/2/87929690/published/ghostbusters.jpg



* Concurrency safety

_Concurrency_safety_ is a property of a given operation on a variable of a given type.

An operation is _concurrency-safe_ if it can be carried out in a concurrent fashion (from multiple goroutines) without explicit synchronization and consistently produces predictable results.

Be careful: a simple update to a package-level variable is *never* concurrency-safe!



* Concurrency-safe types

When all the methods on a given type are safe for concurrent use by multiple goroutines, the type itself is said to be _concurrency-safe_. Here are some examples:

- [[https://pkg.go.dev/sync#WaitGroup][`sync.WaitGroup`]] is a typical example of a concurrency-safe type.
- [[https://pkg.go.dev/net/http#Client][Struct type `http.Client`]] is also concurrency-safe: you can safely send HTTP requests using the same client from multiple goroutines.
- [[https://pkg.go.dev/net/http#CookieJar][Interface `http.CookieJar`]] requires its implementations to be concurrency-safe.

Unless a type is documented to be concurrency-safe, do not assume that it is!

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 200 _

: consult the doc



* Synchronization bug

TODO



* Closures running as goroutines: spot the bug (Go <1.22)

Can you spot the bug in the following program?

.play -edit src/goroutine_func_quiz.go /^//START/,/^//END/

: ask them first how they expect the program to behave
: sometimes prints 10, not 9! because iteration variable goes beyond bound before loop can end



* Closures running as goroutines: explanation (Go <1.22)

The program contains a [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][_synchronization_bug_]], which is very likely to cause a _data_race_ and yield unpredictable and undesirable results! ðŸ˜±

.play -edit src/goroutine_func_answer.go /^//START/,/^//END/

Why? Because `i` is a single variable scoped to the loop (not to individual iterations). And, crucially, variable `i` is [[https://en.wikipedia.org/wiki/Closure_(computer_programming)][_captured_]] and _read_ by the child goroutines while it's being _updated_ by the loop, in a concurrent fashion, without any precautions!

See the [[https://go.dev/doc/faq#closures_and_goroutines][Go FAQ]] and [[https://github.com/golang/go/wiki/CommonMistakes#using-goroutines-on-loop-iterator-variables][CommonMistakes - Using goroutines on loop iterator variables]].

: before learning how to fix it, let's see how we can get help for detecting it



* Detection of synchorization bugs with go vet

The `vet` subcommand performs some static analysis and can report a range of issues, including some synchronization bugs.

If you run `vet` on your program, it will report something like the following:

  $ go vet main.go
  ./main.go:19:16: loop variable i captured by func literal

In the [[https://go.dev/play/p/8-lOBoCLGTy][Go Playground]], `vet` is run before compilation (when you click _Run_).

And VS Code runs `vet` in the background and directly highlights issues in your code.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 150 _



* Go's race detector

Go provides a [[https://go.dev/blog/race-detector][race detector]], i.e. a tool that can detect data races during execution. Caution: the race detector is [[https://go.dev/doc/articles/race_detector][not guaranteed to catch _all_ data races]].

  $ go run -race main.go
  5
  4
  5
  ==================
  WARNING: DATA RACE
  Read at 0x00c00011e038 by goroutine 6:
    main.printTenIntsConcurrently.func1()
        /Users/jub0bs/my-project/main.go:19 +0x8b

  Previous write at 0x00c00011e038 by main goroutine:
    main.printTenIntsConcurrently()
        /Users/jub0bs/my-project/main.go:16 +0xa4
    main.main()
        /Users/jcretel/Desktop/go-course-beginner/main.go:9 +0x1c
  -snip-

Don't leave the race detector on in production: its overhead is prohibitive.



* One way to fix the synchronization bug (Go <1.22)

In constrast to the iteration variable, variables declared within the body of the loop are not shared between iterations. Therefore, one way to fix the synchronization bug consists in declaring a copy of the iteration variable inside the loop, before the `go` statement:

.play -edit src/goroutine_func_redecl.go /^//START/,/^//END/

Although the redeclaration looks a bit weird, this solution has merit insofar as the fix is colocated with the start of the `go` statement (reduced cognitive load).

: kind of awkward to pass them as parameters further down if the anonymous function is long



* Another way to fix the synchronization bug (Go <1.22)

An alternative solution consists in passing the value of the iteration variable as an argument to the anonymous function.

That way, by virtue of Go's call-by-value evaluation strategy, the function only has access to a copy of the iteration variable's value at the time of the iteration of interest.

.play -edit src/goroutine_func_arg.go /^//START/,/^//END/



* Yet another way to fix the synchronization bug (Go <1.22)

When running a closure as a goroutine, it's very easy to inadvertently capture variables, which may introduce synchronization bugs.

Defining a dedicated named function helps in guarding your code against such bugs:

.play -edit src/goroutine_func_standalone.go /^//START/,/^//END/



* Good news: Go 1.22 will fix for loops!

From Go 1.22 onwards, variables introduced by a `for` loop will have per-iteration scope, instead of per-loop scope (as they are in versions prior to Go 1.22).

You can already preview this scoping change

- in [[https://go.dev/play/p/xuAs_QEW6xd?v=gotip][the Go Playground]] after selecting _Go_dev_branch_, and
- locally, which Go 1.21+, by setting `GOEXPERIMENT=loopvar` in your environment.

For more details about this change, see [[https://go.dev/blog/loopvar-preview][Fixing For Loops in Go 1.22]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/party/birthday.svg 200 _

: Inadvertently capturing a loop variable is so common that the Go team had to act.



* Namecheck project: check each user name concurrently

1. Extract the body of the for-range loop that iterates on your `[]Checker` slice as a function in your `main` package:

  func check(checker Checker, username string)

2. Add a parameter of type `*sync.WaitGroup` to your `check` function.

3. Within the for-range loop, apply the `go` keyword to your `check` function.

4. Use a wait group in order to wait, at the end of the `main` function, for all the goroutines that you've spawned to terminate.

5. Time the program's execution. Does user experience improve?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Namecheck project: aggregate the results (how?)

What if, instead of printing the results, we wanted to somehow aggregate them?

Remember: the result(s) of the function call to which the `go` keyword is applied are lost.

We need a way to communicate between goroutines...

.image https://go.dev/blog/gopher/plush.jpg 300 _



* Channels



* Sharing is caring

Because goroutines all execute in the same address space, programs that modify data being simultaneously accessed by multiple goroutines [[https://go.dev/ref/mem#tmp_1][*must* serialize such access]].

Programs that ignore this injunction are bound to contain [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][_synchronization_bugs_]], which may manifest as _data_races_...


.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Share memory by communicating

Rather than using locks to synchronize goroutine access to the shared memory, Go encourages an approach in which shared values are passed around on _channels_.

The Go community [[https://go.dev/doc/effective_go#sharing][summarizes this powerful idea]] through a slightly cryptic mantra:
[[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=2m42s][_Do_not_communicate_by_sharing_memory;_instead,_share_memory_by_communicating._]]

Compared to their lower-level alternatives alternatives like mutexes, channels are indeed often [[https://www.youtube.com/watch?v=oV9rvDllKEg&t=1280s][more elegant, more composable, and less error-prone]].

As Rob Pike puts it: [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=4m20s][channels orchestrate; mutexes serialize]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Channels are typed

Channels are typed conduits that allow goroutines to synchronize and exchange data.

A channel whose element type is `T` has type `chan`T`.

  ch := make(chan string) // channel of strings

The element type of a channel is completely arbitrary; here is a contrived example:

  type Man string
  ch := make(chan chan Man)

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/liberty.svg 200 _

: channels only exist within the confines of your program; they can't be used to communicate between different processes, be they written in Go.



* Popular naming choices for channels

"ch" on its own or as a suffix (with or without camelcase):

  ch := make(chan string)
  taskCh := make(chan Task)

Plural of the channel's element type:

  tasks := make(chan Task)

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _



* Channels are first-class values

You can pass a channel to a function:

  func Aggregate(results chan Result) Result { /* ... */ }

You can return a channel from a function:

  func Generate(upTo int) chan int { /* ... */ }

You can store a channel in a struct type:

  type Request struct {
      fn func() int  // The operation to perform.
      c  chan bool    // The channel to return the result.
  }

Channels are comparable.



* Initializing a channel

The zero value of channel types is `nil`. You cannot do much with an uninitialized channel (although [[https://www.youtube.com/watch?v=t9bEg2A4jsw][assigning `nil` to a channel variable is sometimes useful]]).

To initialize a channel, use the built-in function `make` with two arguments:

- the desired type of the channel,
- the desired _capacity_ of the channel.

  ch := make(chan string, 16)

You can omit the second argument; the capacity of the resulting channel is `0`.

  ch := make(chan string) // equivalent to make(chan string, 0)

A channel's capacity cannot be changed after initialization.

: The specified capacity (if any) must be non-negative; otherwise, you'll get a compilation error or, worse, a panic.



* Buffered and unbuffered channels

A channel of positive capacity is said to be _buffered_.

  ch := make(chan string, 16)

A channel of zero capacity is said to be _unbuffered_ or _synchronous_.

  ch := make(chan string, 0)

Contrary to what you may believe, unbuffered channels are useful. More on that soon.



* Channel capacity

A channel's capacity corresponds to the size of its _buffer_, i.e. the maximum number of elements that the channel can contain at any give time.

Built-in function `cap` can be used to query a channel's capacity:

  ch := make(chan Result, 16)
  fmt.Println(cap(ch))        // 16

Choose channel capacity judiciously; this choice typically affects the correctness (and sometimes the performance) of your program.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _

: The number of elements queued in a channel's buffer can also be queried via built-in function `len`, but is rarely useful. Why?
: if more than one goroutine interact with the channel, len(ch) is stale as soon as queried
: increasing buffer size may help reduce pressure on the Go scheduler



* A kitchen serving-hatch as a metaphor

Think of goroutines as cooks and waiters on either side of a serving hatch,
which represents a channel.

The channel's capacity corresponds to the number of plates that can fit
on the serving hatch's platform at any one time.

.image https://josephdmcnamee.files.wordpress.com/2012/01/serving-hatch1.jpg 350 _

: what does a channel of capacity 0 correspond to?
: An unbuffered channel has a capacity of zero and so itâ€™s already full before any writes
: Far from being useless, an unbuffered channel can be used to create a synchronization point between two goroutines.
: the analogy is imperfect because channels are FIFO and waiters don't necessarily pick up plates in the order in which they arrived



* Channels are FIFO

Channels [[https://go.dev/ref/spec#Channel_types][act as first-in-first-out queues]].

.image https://i.imgflip.com/68zdq9.jpg 300 _

Of course, if multiple goroutines send values to a channel, the order in which values are received is only partial.

See [[https://go.dev/play/p/6kpQq0hhlun][this Playground]] (although you may be able to fully understand the code only later).

: the values from the two goroutines may be interleaved



* Choose the capacity of your channels wisely

Choosing the capacity of a channel can be delicate! An inappropriate capacity may detrimentally affect the correctness and/or performance of your program.

In some cases, an inappropriately buffered channel can lead to a _deadlock_, i.e. goroutines blocking one another and preventing any further progress.

In other cases, an inappropriately buffered channel may lead some goroutines to _leak_ (i.e. turn into zombies), which may ultimately cause a crash.

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 200 _



* Choose the capacity of your channels wisely (cont'd)

In yet other cases, that choice has no impact on correctness or on the occurence of goroutine leaks, but it affects performance.

In such cases, you should profile your program under realistic load in order to determine a good value to use.

Such performance optimization is covered in [[https://www.humancoders.com/formations/go-avance#outline][the next course]].

.image https://go.dev/blog/5years/gophers5th.jpg 300 _




* Operations on a channel

Channels support _send_ an _receive_ operations, which are collectively known as _channel_communications_.

You can also _close_ a channel to inform receivers that no more items will be sent to it.

In addition, you can _range_ over a channel, a more derivative operation that consists in continually receiving values from it until the channel is closed and drained.

All those operations are *concurrency-safe*.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/adventure/hiking.svg 250 _



* Sending to a channel

The syntax of a _channel_send_ consists in the name of the channel in question
followed by a left-pointing arrow (`<-`) followed by the value to send.

  ch := make(chan string)
  // ...
  v := "superimportant message"
  ch <- v

The `gofmt` tool will adds a space on either side of the arrow; don't fight it.

A channel send is a statement, not an expression.



* Semantics of a channel send

.image img/send_semantics.svg _ 900

Notes:

- When you send to a channel, the channel better not already be closed!
- Buffered channels accept a limited number of values without a corresponding receive for those values.
- Each send on an _unbuffered_ channel must have a corresponding receive!
: or goroutines will leak



* Receiving from a channel

The syntax of a _channel_receive_ consists in a left-pointing arrow (`<-`) followed by the channel in question.

  ch := make(chan string)
  // ...
  <-ch

The `gofmt` tool removes any whitespace between the arrow the channel; don't fight it.

A channel receive is an expression: you can store the received value in a variable...

  v := <-ch

\... or even pass it directly to a function:

  fmt.Println(<-ch)

A channel is _not_ a [[https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern][pub/sub]] topic: a value received from a channel by a goroutine gets removed from the channel; no other goroutines can receive the same channel element.



* Semantics of a channel receive

.image img/receive_semantics.svg 500 _




* Dispelling the ambiguity on receive

If we receive the zero value of the channel's element type, how can we tell whether the value we're receiving is from a closed and empty channel or whether someone really sent that value to the channel?

To lift that ambiguity, there is a special form of channel receive that yields an additional boolean value:

   v, ok := <-ch

The value of variable `ok` is

- `true` if the value received was actually sent to the channel, or
- `false` if the channel is both closed and fully drained (empty).

: similar comma-ok idiom for maps and type assertions



* Exercise: resolving a deadlock

Here is a short but instructive code snippet about channel semantics:

.play -edit src/deadlock_example.go /^//START/,/^//END/

1. Run this program, and note that it ends in a deadlock. Can you guess why?

2. How would you resolve the issue?

3. Can you think of naive and incorrect ways of resolving the issue?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: ask them what happens if we write go fmt.Println(<-ch)
: an incorrect approach: go func() { fmt.Println(<-ch) }() then ch <- 42 ...
: ... because <-ch can execute and main terminate before the Println does
: correct: go func() { ch <- 42}() and in main: fmt.Println(<-ch)
: https://twitter.com/jub0bs/status/1400387164358197254



* Closing a channel

A freshly initialized channel starts its life in an "open" state.

  ch := make(chan string) // ch is open (until closed)

You can inform receivers on a channel that no more items will be sent to the channel
by _closing_ the channel. To do so, simply pass the channel to the built-in `close` function:

  close(ch)

Closing a channel is definitive; a closed channel cannot be "re-opened".

Contrary to a common misconception, closing a channel doesn't make it `nil`.

: not to be confused with Close methods, e.g. on the body of a http.Response



* Semantics of close

.image img/close_semantics.svg _ 800

Note that you must structure your program in such a way that, when a channel get closed, no more values will ever be sent to that channel!



* Do not systematically close channels

Another common misconception is that channels _must_ systematically be closed. Not so!

Channels are not resources; closing a channel is not a way to reclaim or clean up resources (memory, etc.).

A channel will get garbage-collected just like any other variable once it becomes unreachable from the rest of the program.

Don't guess; only close a channel if the semantics of your program demand it.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _




* Closing a channel doesn't drain it

Closing a channel is akin to a restaurant announcing the end of service.

- The restaurant no longer accepts customers for the day.
- However, the staff allows already present customers to stay and finish their meal.

.image https://www.matternow.com/wp-content/uploads/2020/06/CAL-BlgPst-1200x630-043014-1024x538-3.jpg 250 _

Similarly, closing a channel doesn't drain it from the elements it contains; and some goroutine(s) can still receive on a closed channel in order to consume its elements.

: close is an unfortunate term; may mislead beginners to believe that you cannot receive values from a closed channel



* Ranging over a channel

Ranging over a channel amounts to iteratively receiving from it:

  for v := range ch {
    // do something with v
  }

Note that, when ranging over a channel, only one iteration variable is available. It takes the successive values sent on the channel until the channel is both closed and empty.

The code above is exactly equivalent to the following:

  for {
    v, ok := <-ch
    if !ok {
      break
    }
    // do something with v
  }

: There's no notion of indexing with channels.



* Ranging over a channel blocks until the channel is closed

Closing a channel to which a for-range loop is applied causes the loop to terminate:

.play -edit src/range_blocks_until_channel_closed.go /^//START/,/^//END/



* Remember: channels are "reference types"

Operating on a copy `cb` of a channel `ca` affects the same underlying data structure as if you operated on channel `ca` directly.
.play -edit src/channels_are_references.go /^//START/,/^//END/

(If that weren't the case, channel function parameters wouldn't be very useful;
those parameters would instead need to be pointers to channels.)



* Namecheck project: aggregate the results

1. At the top of `cmd/cli/main.go`, declare the following `Result` type:

  type Result struct {
    Username  string
    Platform  string
    Valid     bool
    Available bool
    Err       error
  }

2. In `main`, initialize a `chan`Result` named `resultCh`; pass that channel as an argument to the `check` function.

3. In each child goroutine, create a `Result` value and send it to the channel.

4. In `main`, range over that channel and store the results in a slice, then print the slice.

.image https://go.dev/blog/store/gophers.jpg 150 _

: the channel allows us to serialize access to the slice (local mutable state)
: for anonymous function for wait and close, no need for a wait group? why not?
: could you put the go func() {...}() before the call to wg.Add?
: subsidairy question: how would you implement the fan-out/fan-in without a wait group?
:   simply loop as many times as len(checkers)
:   within loop: receive one result and append to slice



* Directional channels

Adding an arrow on one side of the `chan` keyword in a channel type restricts the _direction_ of that channel, i.e. its "mode of operation".

In this first example, `ch` is a _send-only_channel_; the `produce` function can only send values to it and/or close it, but not receive values from it.

  func produce(ch chan<- string) {}

In this second example, `ch` is a _receive-only_channel_; the `consume` function can only receive values from it, but neither send values to it nor close it:

  func consume(ch <-chan string) {} // ch is receive-only

In this third example, the channel result of function `Done` is receive-only:

  func Done() <-chan struct{}

Wherever a (uni)directional channel is expected, a bidirectional channel is accepted.



* Directional channels (cont'd)

.play -edit src/channel_dir.go /^//START/,/^//END/



* Why use directional channels

Directional channels are great for

- clarifying the role of a channel within a function,
- increasing your confidence in the correctness of your code.

Use them liberally, wherever possible.

However, in cases where a function [[https://go.dev/talks/2012/10things.slide#10][legitimately needs to both send to and receive from a channel]], a bidirectional channel is needed.



* Namecheck project: use directional channels

Review the functions that accept a channel parameter, and determine whether a direction could be specified.

.image https://go.dev/blog/gopher/plush.jpg 400 _



* A simple Web server (Go 1.22)

.play -edit src/server_helloworld.go /^//START/,/^//END/

You can define a handler as a package-level function. It must have two parameters:

- a [[https://pkg.go.dev/net/http#ResponseWriter][`http.ResponseWriter`]], an interface for you to compose the HTTP response.
- a pointer to a [[https://pkg.go.dev/net/http#Request][`http.Request`]], which describes the HTTP request to handle.

You can then use [[https://pkg.go.dev/net/http#HandleFunc][function `http.HandleFunc`]] to register a pattern and associate it to some handler.

Finally, start the server with [[https://pkg.go.dev/net/http#ListenAndServe][function `http.ListenAndServe`]], which blocks for as long as the server stays up. Don't forget to check the error it returns.

: http.HandleFunc registers the handler on the DefaultServeMux (package-level variable)
: ListenAndServe: it last arg is nil, serves the DefaultServeMux
: important to capture error from http.ListenAndServe, because otherwise fails silently if port collision (e.g. ":80")



* HTTP handlers vs. shared memory

Be careful! The HTTP server provided by `net/http` is *concurrent*: it handles each incoming request in a *separate* goroutine.

Therefore, if your handler updates some shared memory, you *must* serialize access to it, or you risk introducing synchronization bugs in your code!

As discussed earlier, a synchronization bug often manifests itself at run time as a data race, which leads to unpredictable results and possibly disastrous consequences!

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 200 _



* Caution: HTTP handlers vs. shared memory (cont'd)

The following program contains a simple synchronization bug:

  var toggle bool

  func handleToggle(_ http.ResponseWriter, _ *http.Request) {
     toggle = !toggle // ðŸ˜±
  }

  func main() {
      http.HandleFunc("POST /toggle", handleToggle)
      if err := http.ListenAndServe(":8080", nil); err != nil {
          log.Fatal(err)
      }
  }

If two requests are sent to `/toggle` at exact the same time, the subsequent value of global variable `toggle` is unpredictable.

This bug is particularly insidious because it will only manifest itself under sufficiently heavy load on the server. Simple integration tests are unlikely to catch it.



* Namecheck project: turn your CLI tool into a Web server

1. Move the declaration of your three interface types from `main.go` to `namecheck.go`; adjust your `main` function accordingly.

2. Copy `cmd/cli/main.go` to `cmd/server/main.go`. We won't touch `cmd/cli` for the remainder of the course.

3. In `cmd/server/main.go`, rename the `main` function to `handleCheck`.

4. Adjust `handleCheck`'s signature to make it compatible with a HTTP handler:

  func handleCheck(w http.ResponseWriter, r *http.Request)

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _




* Namecheck project: turn your CLI tool into a Web server (cont'd)

4. Adjust `handleCheck`'s implementation:

- If the client provided no username via a query param named "`username`",
  write a `400`Bad`Request` response and terminate the handler.
- Otherwise, write your slice of results in the response. Hint: use `fmt.Fprint`.

5. Add a `main` function in `cmd/server/main.go`. In it, register your `handleCheck` handler on pattern `GET /check`, then start the server on port 8080.

6. Run the program and hit the `/check` endpoint, e.g. by visiting [[http://localhost:8080/check?username=jub0bs][http://localhost:8080/check?username=jub0bs]] in your browser:

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* JSON encoding

Use [[https://pkg.go.dev/encoding/json/][the `encoding/json` package]] to encode some Go value to JSON.

Create a `json.Encoder` that writes to the handler's `http.ResponseWriter`,
then pass the value to its `Encode` method:

.play -edit src/json_encoding.go /^//START2/,/^//END2/

_Field_tags_ are used to map the correspondance between the names of a struct's fields (which must be exported!) and the property names of the resulting JSON object:

.code -edit src/json_encoding.go /^//START1/,/^//END1/

: w is the http.ResponseWriter
: don't forget to inspect the resulting error



* Namecheck project: write the results as JSON in the response

1. Instead of writing a Go-specific textual representation of the slice of checkers in the HTTP response, encode the slice to JSON. If encoding fails, send a `500` response.

2. Add field tags in the declaration of your `Result` struct type so that property names in the resulting JSON be lowercase.

3. Make sure you specify an appropriate content type.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* JSON decoding

Decoding some JSON object to a Go variable words in a similar way:

.play -edit src/json_encoding.go /^//START3/,/^//END3/

The use of a local variable whose type is an anynomous struct is pretty common.

Create a `json.Decoder` that reads from the body of the handler's `*http.Request`,
then pass a pointer to the variable to its `Decode` method.

[[https://twitter.com/mholt6][Matt Holt]]'s [[https://mholt.github.io/json-to-go/][JSON-to-Go converter]] is a time-saving tool for JSON decoding.

For more about JSON encoding and decoding, see [[https://go.dev/blog/json][Andrew Gerrand - JSON and Go]].

: don't forget to inspect the resulting error
: curl -v -XPOST -H "Content-Type: application/json" --data '{"name": "Bob"}' http://localhost:8080/admin/new
: no exercise for JSON decoding, but you could retrieve the username to test from the request's JSON body instead of a query param



* Adding third-party dependencies to your project

So far, you've exclusively relied on Go's standard library but, thanks to Go's module system, you can of course bring in third-party dependencies.

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 150 _

For example, you may want to configure your server for [[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS][CORS]], so that your API can be consumed by a browser-based [[https://developer.mozilla.org/en-US/docs/Glossary/Origin][cross-origin]] client. The most popular CORS middleware library for Go may be [[https://github.com/rs/cors][rs/cors]], but I [[https://jub0bs.com/posts/2023-02-08-fearless-cors/][strongly recommend]] my own: [[https://github.com/jub0bs/fcors][jub0bs/fcors]].

To add this CORS middleware library as a dependency to your project, you would run

  go get github.com/jub0bs/fcors

This command downloads and caches the module locally in `$GOPATH/pkg/mod`.



* go.mod's require directive

Running that `go`get` command adds the following line to your `go.mod` file:

  require github.com/jub0bs/fcors v0.6.0 // indirect

Note the presence of an "indirect" comment, which indicates that you're not (yet?) directly depending on that module in your code.

Once you actually use package `github.com/jub0bs/fcors` in your code, you'll be able to remove that "indirect" comment by running the following command:

  go mod tidy



* The go.sum file

Adding/updating a dependency also creates/updates a file named `go.sum`.

That file contains cryptographic hashes of the dependency's source code, which the module system relies on to detect integrity issues.

Don't forget to track changes to this file in your version-control system!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _

: example of integrity issue: existing version whose content change after release (either accidentally or for malicious reasons)



* A simple Web server configured for CORS

.play -edit src/cors.go /^//START/,/^//END/



* Namecheck project: configure your server for CORS

1. Run the following command within your project to download the dependency:

  go get github.com/jub0bs/fcors

2. Inspect the contents of the `go.mod` file and of the newly created `go.sum` file.

3. Import `github.com/jub0bs/fcors` in your server's `main.go`.

4. In your main function, instantiate a CORS middleware and apply it to the default `http.ServeMux`.

5. Run the following command to clean up your `go.mod` file:

  go mod tidy

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Select statement


The `select` statement is a multi-way communication selector: it allows you to randomly select one among several channel communications.

With goroutines and channels, `select` completes the concurrency trifecta.
It is very powerful, which is why you should invest time to master it.

.image https://pbs.twimg.com/media/DDWqkrFUMAAbIyL?format=png&name=large 300 _

: reminder: channel communication = a channel send or receive



* Syntax of a select statement

The syntax of the select statement is reminiscent of that of the switch statement.

  select {
  case out <- 42:
    // ...
  case v, ok:= <-in:
    if !ok {
      break
    }
    // do something with v
  default:
    time.Sleep(200 * time.Millisecond)
  }

A `select` comprises "normal" case clauses (introduced by the `case` keyword), each of which is associated with a _channel_communication_.

A `select` may also comprise a `default` case clause, which isn't associated to any channel communication.

The `break` keyword can be used within a `select` statement to break out of it.



* Semantics of the select statement

  select {
  case out <- 42:
    // ...
  case v, ok:= <-in:
    if !ok {
      break
    }
    // do something with v
  default:
    time.Sleep(200 * time.Millisecond)
  }

Recall that, depending on a channel's state, communications on that channel may block.

When program execution reaches a `select` statement, what happens is governed by

- the presence or absence of a default case, and
- the blocking or non-blocking character of the channel communications listed.



* Semantics of the select statement (cont'd)

If all the normal cases are blocking, two situations are possible:

- If the `select` statement lacks a `default` case, the `select` statement itself blocks.
- If the `select` statement contains a `default` case, the instructions associated to that case are executed.

Otherwise, if exactly one normal case is non-blocking, that case gets _selected_, i.e.
the channel communication occurs and the associated instructions are executed.

Otherwise, if more than one cases are non-blocking, one of those cases gets selected in a pseudo-random uniform fashion.

.image https://pbs.twimg.com/media/DDWqkrFUMAAbIyL?format=png&name=large 200 _



* Event loop: a select nested inside a loop

`select` is often used in conjunction with `for` to form a so-called _event_loop_.

For instance, if you want to continually receive from two (or more) channels,
a simple for-range loop won't do; you'll need to nest a `select` inside a loop:

  loop:
    for {
      select {
      case err := <-errorCh:
        fmt.Fprintln(os.Stderr, err)
        break loop
      case res, ok := <-resultCh:
        if !ok {
          break loop
        }
        // do something interesting with res
      }
    }

Note that a [[https://go.dev/ref/spec#Label][label]] (named `loop`) is required in order to break out of the infinite loop rather than out of the `select` statement nested within.



* Event loop: a select nested inside a loop (cont'd)

To avoid the need for unsightly [[https://go.dev/ref/spec#Labeled_statements][labeled statements]], you may prefer a "while" loop controlled by a boolean variable:

  var finished bool
  for !finished {
    select {
    case err := <-errorCh:
      fmt.Fprintln(os.Stderr, err)
      finished = true
      continue
    case res, ok := <-resultCh:
      if !ok {
        finished = true
        continue
      }
      // do something interesting with res
    }
  }

: TODO: add a link to Mat Ryer's talk https://www.youtube.com/watch?v=5DVV36uqQ4E&t=9m58s



* Namecheck project: fail early if an availability check fails

Modify your `cmd/server/main.go` as follows:

1. Remove the `Err` field from your `Result` type.

2. Declare another channel named `errorCh` dedicated to `error` values.

3. Report normal results and errors through the two different channels.

4. In your `handleCheck` function, use a for-select to receive from both channels.

5. As soon as you receive one error from `errorCh`, send a `500` response and return.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _

: smallest channel capacity to prevent goroutine leaks: len(checkers) - 1
: use a bool variable to control the termination of the loop
: mangle the domain name in github.Github's IsAvailable method in order to cause an error


* Goroutines leak!

If you've written the `check` function as shown below and you've chosen insufficient capacities for the two channels, goroutines may leak. Explain why and how.

  func check(checker namecheck.Checker, username string,
    wg *sync.WaitGroup, resultCh chan<- Result, errorCh chan<- error) {
    defer wg.Done()
    res := Result{Username: username, Platform: checker.String(), Valid: checker.IsValid(username)}
    if !res.Valid {
      resultCh <- res
      return
    }
    avail, err := checker.IsAvailable(username)
    if err != nil {
      errorCh <- err
      return
    }
    res.Available = avail
    resultCh <- res
  }

If you did not modify the `check` function, what capacities should `resultCh` and `errorCh` have to avoid ever leaking goroutines? Is this approach viable in general, though?



* Canceling goroutines

Spawning goroutines is easy, but making sure they terminate sometimes requires more effort. For example, consider the following function:

.code -edit src/uncancelable.go /^//START1/,/^//END1/

If you start it as a goroutine, that goroutine will live on until your program ends:

.play -edit src/uncancelable.go /^//START2/,/^//END2/

However, you may want to force that goroutine to terminate that goroutine earlier...



* Canceling goroutines (cont'd)

One common recipe for making a function cancelable consists of

- a `select` statement, and
- a channel of type `<-chan`struct{}` passed as a parameter to the function.

  func cancelable(done <-chan struct{}) {
    for {
        select {
        case <-done:
          return
        default:
          fmt.Println("still alive...")
          time.Sleep(500 * time.Millisecond)
        }
    }
  }

If function `cancelable` is launched as a goroutine, you can trigger its eventual termination simply by closing the `done` channel. Why?

: closing a channel unblocks all receives on it!
: can be used to broadcast a signal to multiple goroutines!



* Exercise: render a function cancelable

1. Open this [[https://go.dev/play/p/yWEVD1G7Oix][Playground]]. Note that function `printInts` never terminates.

2. Modify the program to make `printInts` cancelable.

3. Cancel the goroutine from `main` after one second.

(A solution is available in this [[https://go.dev/play/p/7Hsz9o3MwRs][Playground]].)

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Canceling goroutines with context

The [[https://pkg.go.dev/context#Context][`context.Context` interface]] [[https://go.dev/talks/2014/gotham-context.slide#10][formalizes and expands upon this "done channel" trick]] and can be used to terminate goroutines via cancelations or timeouts.

Its `Done` method returns the channel in question, and its `Err` method returns a non-`nil` error value when the context is [[https://pkg.go.dev/context#Canceled][canceled]] or [[https://pkg.go.dev/context#DeadlineExceeded][times out]]:

  func cancelable(ctx context.Context) error {
    for {
        select {
        case <-ctx.Done():
          return ctx.Err()
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

By convention, a function that has a `context.Context` parameter should feature it at the beginning of its parameter list and should return the context's error.

: contexts form a tree, canceling one context also cancels its descendants



* Exercise: canceling a goroutine with context.Context

You can do this exercise in the [[https://go.dev/play/p/7Hsz9o3MwRs][Go Playground]].

1. Study the documentation of [[https://pkg.go.dev/context/][the `context` package]].

2. Modify the solution to the previous exercise to use a `context.Context` rather than a channel of empty structs.

(A solution is available in this [[https://go.dev/play/p/fuQ8vahNfDL][Playground]].)

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: we won't be using context in our project but...
: TODO: make check function cancelable, to avoid leaking goroutines if some errors occur



* Making a channel send cancelable

Remember: a channel send may block.

  resultCh <- res

To make a channel send cancelable, you can wrap it in a select and add a case in which you detect a context's cancelation:

  select {
    case <-ctx.Done():
      break
    case resultCh <- res:
  }

You can use a similar trick to make a channel receive cancelable.

You now know enough about the `context` package to fix the goroutine leak! ðŸ’ª



* Exercise: debug this ping-pong game

1. Open [[https://go.dev/play/p/n7XQ_TdOY4t][this Playground]] adapted from a talk by Sameer Ajmani ([[https://www.youtube.com/watch?v=QDDwwePbDtw&t=2m54][video]]; [[https://go.dev/talks/2013/advconc.slide#6][slides]]).
The program models a simple ping-pong game.

2. The game ends with a deadlock. Can you explain why?

3. Discuss and fix the program.

Two solutions ([[https://go.dev/play/p/xi2-SMe3xyW][1]] and [[https://go.dev/play/p/yblNr3B5yg7][2]]) are available on the Playground.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: The `main` goroutine plays the role of the umpire.
: two goroutines exchanging one value over and over
: pointer element to reduce memory footprint
: show that deadlock if you never throw the ball on the table
: one player terminates while the other is left holding the ball
: one possibility: buffer size of 1, but no guarantee that the same player will play twice in a row
: non-blocking send by adding a select statement
: easy solution: referee receive ball from main after cancel()



* Namecheck project: fix the goroutine leak

1. Add a `context.Context` parameter to the `check` function.

2. Modify the `check` function so that, even if sends on either or both of the two channels block, canceling the context forces the function to terminate.

3. In the `handleCheck` handler, create a context and pass it to the `check` function. Cancel that context if an error is received on the `errorCh` channel. Also, terminate the loop if you detect a cancelation of the context.

4. Make both `resultCh` and `errorCh` unbuffered channels.

What could be further improved?

: IsAvailable itself isn't cancelable... but we could make it so.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Communicating by sharing memory

Go encourages you to use channels to communicate between goroutines.

However, sharing memory can sometimes be simpler and/or more performant.

Go's standard library provides two main mechanisms for sharing memory:

- [[https://en.wikipedia.org/wiki/Mutual_exclusion][mutual exclusions]], provided by [[https://pkg.go.dev/sync][the `sync` package]],
- synchronized operations on fixed-sized integers from [[https://pkg.go.dev/sync/atomic/][the `sync/atomic` package]], which are difficult to use correctly and which most programs should avoid.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/party/birthday.svg 200 _

: won't cover the latter because easy to misuse



* Namecheck project: count of checks per username

Let's keep track (in memory) of how many times each username has been checked.

1. Declare a variable of a suitable type at the top level.

2. In `handleCheck`, increment the count associated to the username being checked.

3. Declare an additional `handleStats` handler that returns a JSON representation of the variable declared in step 1.

4. Register pattern `GET /stats` and associate it to your `handleStats` handler.

5. Run your server and exercise it.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* One problem: a synchronization bug

Remember: the HTTP server provided by `net/http` is concurrent: it handles each incoming request in a separate goroutine.

However, maps are *not* concurrency-safe: unsynchronized updates to a map from multiple goroutines yields unpredictable results!

The Go runtime [[https://go.dev/doc/go1.6#runtime][may be able to detect concurrent map writes]] and intentionally crash the program (see [[https://go.dev/play/p/NMDVMeaVLLx][this Playground]]), or the runtime may miss the data race and you may silently lose some updates to the map.

One solution: synchronizing access to the map via a mutex.

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 200 _



* Mutual exclusions

A [[https://en.wikipedia.org/wiki/Mutual_exclusion][_mutual_exclusion_]] (a.k.a. _mutex_) allows you to delineate sections of code that must (in order to guarantee correctness of the program) be executed by at most one goroutine at any given time.

Such a section of code to be executed in mutual exclusion is known as a [[https://en.wikipedia.org/wiki/Critical_section][_critical_section_]].

To avoid [[https://en.wikipedia.org/wiki/Resource_contention][_contention_]], strive to keep critical sections short and free of I/O operations.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _



* Using sync.Mutex

The [[https://pkg.go.dev/sync][`sync` package]] provides two types of mutexes, the simplest of which is [[https://pkg.go.dev/sync#Mutex][`sync.Mutex`]].

That type requires no initialization, because its zero value is readily usable:

  var mu sync.Mutex

Mutex variables are typically declared in a function rather than at package level.

Then, surround the critical section(s) by calls to the `Lock` and `Unlock` methods:

  mu.Lock()   // ðŸ”’
  // critical section
  mu.Unlock() // ðŸ”“

Like a `sync.WaitGroup`, a `sync.Mutex` must not be copied after first use. `go`vet` [[https://go.dev/play/p/set7VxnF7yj][alerts you about such programming mistakes]].

: A popular name for a mutex variable is "mu".
: at most one goroutine at a time can acquire the lock



* Clarifying the role of a mutex

If access to some variable or struct field is protected by a mutex, convention dictates that you either declare the mutex nearby (perhaps in the same `var` block):

  var (
    toggle bool
    mu sync.Mutex
  )

\... or that you leave [[https://cs.opensource.google/go/go/+/refs/tags/go1.21.4:src/context/context.go;l=640][a clarifying comment]]:

  type timerCtx struct {
    *cancelCtx
    timer *time.Timer // Under cancelCtx.mu.

    deadline time.Time
  }



* Namecheck project: count of checks per username

1. Study the documentation of `sync.Mutex`.

2. Guard accesses (both writes *and* reads!) to the map with a mutex.

3. Run the server.

4. What could be improved?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: instead of a package-level map, we could make the handler a method of some API/server struct type in which we inject the mutex



* Conclusion



* What we haven't covered

We're nearing the end of the course.

You've learned a lot, but there is [[https://www.humancoders.com/formations/go-avance][more]]!

.image https://go.dev/blog/store/gophers.jpg 400 _



* Additional learning resources

*Spec*: [[https://go.dev/ref/spec][the Go programming language specification]]

*Development*: [[https://github.com/golang/go][golang/go (GitHub)]]

*Blogs*

- [[https://go.dev/blog][the (official) Go blog]]
- [[https://dave.cheney.net/][Dave Cheney's blog]]

*Book*: [[https://www.gopl.io/][Donovan & Kernighan - The Go programming language]] (2015)

*Online*community*:

- [[https://gophers.slack.com][Gophers Slack]]
- [[https://groups.google.com/g/golang-nuts][golang-nuts Google group]]

: esp. channels #general, #newbies, and #bestpractices



* Additional learning resources (cont'd)

*Podcast*: [[https://changelog.com/gotime][Go Time (The Changelog)]]

*Vidcast*: [[https://www.youtube.com/c/justforfunc][Francesc Campoy Flores - justforfunc]] (no longer active but still good)

*Conference*talks*

- [[https://www.youtube.com/@GopherAcademy][Gopher Academy (GopherCon US)]]
- [[https://www.youtube.com/@GopherConEurope][GopherCon Europe]]
- [[https://www.youtube.com/@GopherConUK][GopherCon UK]]

*Video*courses*:

ðŸ’² [[https://www.oreilly.com/library/view/ultimate-go-programming/9780135261651/][Bill Kennedy - Ultimate Go 2]] (2018)
ðŸ’² [[https://www.oreilly.com/library/view/introduction-to-go/9781491913871/][John Graham-Cumming - Introduction to Go Programming]] (2014)




* Appendix A: other import syntaxes



* Blank imports

A blank import uses the blank identifier as package name:

  import _ "github.com/go-sql-driver/mysql"

A blank import makes none of the imported package's members available in the importing package.

The sole reason for using a blank import to import a package is the side effects carried out during [[https://go.dev/ref/spec#Package_initialization][the package's initialization]].

Blank imports are used in the so-called _registration_pattern_ in packages such as `database/sql` and `image`.

Use that pattern if you have to, but do not emulate it in your own code.

: difficult to understand, based on shared global state



* Dot imports

A dot import allows you to access all the exported identifiers of the imported package without the need to qualify them:

.play -edit src/helloworld_dot.go

Dot imports can be convenient in test code (see [[https://cs.opensource.google/go/go/+/refs/tags/go1.18.1:src/strconv/quote_test.go;l=8][this example]]), but are best avoided in production code because

- they pollute the namespace of your source file,
- they obscure the provenance of identifiers.

: similar to Java's static imports



* Relative imports

A relative import relies on the location of the imported package relative to that of the importing package on the disk:

  package main

  import ./github

Avoid relative imports like the plague!



* Appendix B: more about interfaces



* Interfaces under the hood

  ----------------------
  | pointer to itable  |
  ----------------------
  |  pointer to value  |
  ----------------------

Under the hood, an interface value is a two-word data structure:

- a pointer to an _itable_, which contains metadata about the concrete type stored in the interface value: name, set of methods, etc.
- generally, a pointer to the value of the concrete type stored in the interface value.

For the gory details, see [[https://research.swtch.com/interfaces][Russ Cox - Go Data Structures: Interfaces]].

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 150 _



* Comparability and zero value

Interface types are comparable (but you already knew that).

Interfaces are "reference types"; therefore, manipulating pointers to interface is rare.

An interface type's zero value is `nil`:

.play -edit src/interface_zero.go /^//START/,/^//END/

An interface value is considered `nil` if and only if

- *it*isn't*associated*to*any*concrete*type* (!), and
- it does contain or point to the value of a concrete type.

  ---------------------------------------
  |                 nil                 |
  ---------------------------------------     ==     nil
  |                 nil                 |
  ---------------------------------------

: pointers to interfaces useful for decoding JSON to an interface value
: see https://go.dev/blog/json-and-go



* Pitfall: interface vs. nil

Be careful: an interface value that holds a `nil` pointer to a concrete type is not itself `nil`!

  ---------------------------------------
  | pointer to github.GitHub's itable |
  ---------------------------------------     !=     nil
  |                 nil                 |
  ---------------------------------------

Developers who fail to account for this distinction expose themselves to subtle bugs...

More details about this subtlety are available in the [[https://go.dev/doc/faq#nil_error][Go FAQ]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _



* Interface vs. nil: spot the bug

The following program contains a subtle bug. Can you identify it?

.play -edit src/interface_nil.go /^//START/,/^//END/



* Interface vs. nil: spot the bug (solution)

  -----------------------------------------
  | pointer to *ErrLaunchFailure's itable |
  -----------------------------------------     !=     nil
  |                 nil                   |
  -----------------------------------------

To indicate failure, a fallible function should return a result of type `error`, as opposed to a result of a concrete type that happens to satisfy the `error` interface!

.play -edit src/interface_nil_fixed.go /^//START/,/^//END/

See [[https://www.youtube.com/watch?v=ynoY2xz-F8s&t=14m12s][Francesc Campoy Flores - Understanding nil (GopherCon 2016)]].



* Interface vs. nil: spot the bug again

The following program contains a subtle bug. Can you identify it?

.play -edit src/interface_nil_concrete_var.go /^//START/,/^//END/


* Interface vs. nil: spot the bug again (solution)

  -----------------------------------------
  | pointer to *ErrLaunchFailure's itable |
  -----------------------------------------     !=     nil
  |                 nil                   |
  -----------------------------------------

.play -edit src/interface_nil_fixed.go /^//START/,/^//END/

Avoid declaring variables of a concrete type that happens to satisfy `error`!

See [[https://www.youtube.com/watch?v=ynoY2xz-F8s&t=13m20s][Francesc Campoy Flores - Understanding nil (GopherCon 2016)]].


