Formation Go
16 February 2022

Julien Cretel
jcretel-infosec@protonmail.com
https://jub0bs.com
@jub0bs



* Setup

Make sure you have the latest version of Go (1.17.3) installed by running

  go version

To figure out where your Go distribution is installed, run

  go env GOROOT

To learn Go, I recommend Visual Studio Code and its [[https://code.visualstudio.com/docs/languages/go][Go extension]], which embarks a number of utilities such as `goimports` and `gofmt`.

Also make sure you have Git installed.


* Running these slides

A README at the root of this Git repository explains how to run the slides using the `present` tool.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 300 _



* What to expect from the course

- interaction
- regular breaks
- learn the fundamentals
- emphasis on practice over theory
- long-running project
- gophers
- cooking analogies

: the source code of my solution will be available on GitHub



* Namecheck project

*Objectives*

Write a small CLI tool (and then a server) to check the validity and availability
of a username on multiple social networks: Twitter, GitHub, etc.

A forcing function for learning Go: we'll introduce new concepts as needed.

*Business* *case*

- Ability to choose a brand name consistent across multiple platforms.
- Username squatting!

.image https://raw.githubusercontent.com/nielsing/yar/master/images/yargopher3.png 150 _

: mention Newsweaver's rebranding to Poppulo, missed claiming @Poppulo on Twitter



* Go's history



* Genesis

Go was created in 2007 at Google by Robert Griesemer, Rob Pike, and Ken Thompson.

.image https://miro.medium.com/max/1256/0*pCC5UI7QqThjdBvm.png _ 800

: Griesemer: V8 JS engine, Hot Spot JVM
: Pike: predecessors to Go (Newsqueak), Plan 9, Unicode
: Thompson: recipient of Turing Award, UNIX (with Dennis Ritchie), Unicode (with Pike), Plan 9 (with Pike), increment/decrement operators (https://en.wikipedia.org/wiki/B_(programming_language)#History)



* Genesis

Robert, Rob, and Ken started working on Go [[https://www.youtube.com/watch?v=i0zzChzk8KE&t=545s][largely out of frustration with C++]]: language complexity, long build times, poor support for concurrency, etc.

.image https://imgs.xkcd.com/comics/compiling.png



* History of the Go project

- 2007: the project starts at Google.
- 2009: Go is open-sourced.
- 2012: Go 1.0 released.
- 2015: The go compiler (`gc`) becomes self-hosted.
- ...
- 2021: Go 1.17 is released.
- ...
- 2022: Go 1.18 is released. Generics are added to the language.



* What you should know about Go
: answer some questions you may have straight away
: manage your expectations



* Go's mascot

\... [[https://go.dev/blog/gopher][is a gopher]].

.image https://go.dev/blog/gopher/gopher.png 400 _

: more popular than the language's logo


* Go's logo

\... [[https://go.dev/blog/go-brand][is not the gopher!]]

.image https://go.dev/blog/go-brand/logos.jpg 400 _

: Lapins Crétins vibe!



* Reminiscent of but different from C

- strong typing
- fast compilation
- garbage collection
- memory safety
- packages
- full Unicode support

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/projects/with-C-book.svg 200 _

: compiled, but type inference, so feels like a dynamic language
: memory safety: pointers, but no pointer arithmetic; no dangling pointers; no uninitialized variables
: mention heap-overflow vuln discovered in curl



* Reminiscent of but different from C (cont'd)

- concurrency primitives
- sensible `switch` behavior
- first-class functions
- multiple function results
- no semi-colons

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/projects/with-C-book.svg 200 _

: multiple returns allow principled error handling
: packages: no ifdef guards, no required ordering of top-level declarations
: also syntax differences: type name comes after variable name



* Go's rich toolchain

The `go` toolchain comes with tools for

- cross-compilation
- code formatting (`gofmt`)
- automatic package imports (`goimports`)
- testing & code coverage
- microbenchmarks
- profiling & tracing
- run-time race detector
- etc.

Moreover, the core library is pretty extensive; see [[https://pkg.go.dev/std][pkg.go.dev/std]].

: gofmt: enforced specific style. flattens learning curve and reduces friction for code reviews
: goimports: imports in canonical order and in alphabetical order per section



* Go is object-oriented... with a twist!

The ability to define custom types (and methods on them) promote _abstraction_.

Go's interfaces (and, soon, generics) enable _polymorphism_.

Go's packages enable _encapsulation_.

Go has no concept of _inheritance_, but facilitates _composition_ instead.

.image https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png 300 _



* Object orientation without inheritance

Can a language without inheritance be described as object-oriented? Sure!

.image https://i.redd.it/2dpp8t6mk7641.png 200 _

See also

- [[https://www.infoworld.com/article/2073649/why-extends-is-evil.html][Allen Holub - Why extends is evil (InfoWorld 2003)]]
- [[https://www.quora.com/What-does-Alan-Kay-think-about-inheritance-in-object-oriented-programming][What does Alan Kay think about inheritance in object-oriented programming? (Quora)]]
- [[https://golang.org/doc/faq#Is_Go_an_object-oriented_language][Is Go an object-oriented language? (golang.org FAQ)]]

: James Gosling (Java): "I'd leave classes out."
: No concept of inheritance in Alan Kay's Simula... a Web of objects



* Go also has functional aspects

Functions are first-class citizens. They can

- take other functions as parameters,
- return functions as results,
- be stored in variables,
- be stored in struct fields.

However, despite having anonymous functions, Go has no concise "lambda" notation.



* Go development pays well

See the results of the [[https://insights.stackoverflow.com/survey/2020#technology-what-languages-are-associated-with-the-highest-salaries-worldwide-global][Stack Overflow's 2020 Developer Survey]].

.image https://go.dev/blog/gophergala/fancygopher.jpg 400 _



* First steps in Go



* The Go Playground

The Go Playground ([[https://go.dev/play/][https://go.dev/play/]]) is a Web app that lets you write and run
a small Go program from your browser. Features include:

- permalinks (convenient for sharing code snippets)
- automatic formating
- automatic imports (from the core library)
- basic static analysis with `go`vet`
- [[https://go.dev/play/p/lEDjyvhttIB][limited support for modules and multiple packages]]
- downloading of the program source (^S or ⌘+S)

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/computer/gamer.svg 150 _

: It's a good place to experiment and fix ideas about the language and its core library.



* Some limitations of the Go Playground

As the name indicates, the Playground isn't meant for anything extensive.

Limitations include:

- single executable
- no networking allowed
- no command-line arguments
- poor support for third-party packages

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _

: In this course, we'll only use the Playground to solve simple exercises.
: An alternative with more features, incl. syntax highlighting: https://goplay.space/



* Hello, World!

.play -edit src/helloworld.go

You can play with this program [[https://go.dev/play/p/7vin2BK8_A6][in the Go Playground]].

.image https://go.dev/blog/gopher/plush.jpg 300 _

: we can already draw some observations from this piece of code



* Observations about our Hello-World program

.play -edit src/helloworld.go

All source file starts with a _package_clause_, i.e. the `package` keyword followed by the package's name: `package`main`

A package named `main` produces an executable program (as opposed to a library).

Imports specify _package_paths_ in double quotes.

The `main` function of a `main` package is the program's entrypoint; it takes no parameters and returns no results.



* More observations about our Hello-World program

.play -edit src/helloworld.go

Go's formal grammar [[https://golang.org/ref/spec#Semicolons][uses semicolons as statement terminators]], but those semicolons do not appear in the source; [[https://golang.org/doc/effective_go#semicolons][they're added by the compiler]]. As a result, you're not free to break lines wherever you want.

The formater uses tabs (not spaces) for indentation.

Go source files [[https://golang.org/ref/spec#Source_code_representation][*must* be encoded in UTF-8]], or compilation will fail.

: cmd args: os.Args
: guillemets doubles



* Namecheck project: a starting point

1. Create a folder named `namecheck`; in it, create a file named `main.go`:

  namecheck
  └── main.go

2. Write a "Hello World" programme in main.go

3. Compile it by running the following command, which creates an executable
(named `main` on *nix systems or `main.exe` on Windows):

  go build main.go

4. Execute the executable.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _

: for now, we'll code in this source file, but we'll reorganize our code later



* Compiling and executing a program in one fell swoop

If you just want to run the program without keeping the executable, run

  go run main.go

which is roughly equivalent (on *nix systems) to

  go build main.go
  ./main
  rm main

Don't use `go`run` in production, though.

.image https://miro.medium.com/max/4800/1*-bo7H329eM0O1eL_ASBVOA.jpeg 200 _



* Cross-compilation

By default, the compiler will produce an executable targeting your operating system and architecture.

However, you can cross-compile to a different operating system and architecture using the `GOOS` and `GOARCH` environment variables:

  GOOS=windows GOARCH=amd64 go build main.go

The following command lists all valid GOOS/GOARCH combinations:

  go tool dist list

.image https://go.dev/blog/store/gophers.jpg 200 _



* Modules

Go's solution to dependency management is known as the _module_system_.

The terms _package_ and _module_ are confusingly similar, but don't conflate the two!

- _Packages_ are composed of one or more source files.
- A _module_ is a set of packages that are versioned together.

You *must* initialize a module at the root of your project in order to manage dependencies, including packages within the same project!

: typically, one module per project



* Modules (cont'd)

A module is identified by its _path_, which

- takes the form of a schemeless URI where the module will be made available,
- acts as prefix for package import paths within the module.

The `go`mod` subcommand allows you to interact with the module system. You can initialize a module by running a command of the form

   go mod init <your-module-path>

Doing do will create a text file named `go.mod` at the root of your project.

Don't edit the `go.mod` file manually; instead, you can interact with it solely through the `go`mod` subcommand.




* Namecheck project: initialize a module

At the root of your project, initialize a module:

  go mod init github.com/YOUR_GITHUB_USERNAME/namecheck

A go.mod file will be created at the root of your project:

  namecheck
  ├── go.mod
  └── main.go

Inspect its contents.



* Keywords

  break           default           func          interface       select
  case            defer             go            map             struct
  chan            else              goto          package         switch
  const           fallthrough       if            range           type
  continue        for               import        return          var

Discuss. Which keywords are new to you? Which one(s) seem to be missing?

.image https://go.dev/blog/5years/gophers5th.jpg 300 _



* Keywords

*chan* and *select* are related to _channels_, which allow you to communicate between goroutines (Go's lightweight threads).

*fallthrough* can be used to override `switch`'s normal "breaking" behavior.

*go* is used to spawn goroutines.

*goto* is present in the language, but you shouldn't have to ever use it.

*range*, used in conjunction with `for`, allows you to iterate over various data structures.

No `while` keyword in Go: all loops are written with the `for` keyword.

No `try`/`catch`/`finally` keywords in Go: errors are reported as normal values.

*defer* allows you to unconditionally execute some code at the end of a function.


: defer: a cleaner alternative to finally



* Predeclared names

Go also comes with several predeclared names accessible from anywhere in your code:

*Constants*

  false true nil iota

*Built-in*types*

  bool int rune uint byte float64 string
  struct map chan
  interface error

*Built-in*functions*

  make    len     cap     new
  append  copy    delete
  panic   recover

(None of those lists is exhaustive.)



* Comments

[[https://golang.org/ref/spec#Comments][_Line_comments_]] start with a double slash and extend to the end of the line:

  var foo = "foo" // this is a comment

[[https://golang.org/ref/spec#Comments][_General_comments_]] are delimited by `/*` and `*/`; they can be multiline and they do not nest:

  /*
    this is
    a general comment
  */

The documentation of a package is written as comments in the package's source file(s).

: won't talk too much about documentation in this first course



* Consuming packages



* Package path and package name

A package is identified by its _path_, which must be globally unique.

  fmt
  net/http
  github.com/jub0bs/missilelauncher

The _default_name_ of a package typically corresponds to the last component of its path:

  fmt
  http
  missilelauncher

Compiling a package whose default name is `main` produces an executable
(and a library otherwise).

: first two are part of core library; third one is third-party
: "usually": the exception is for a package whose enclosing folder doesn't mach the package name; best avoided
: also, with versions of modules after v1, it's the second last path component: "rsc.io/quote/v3" => quote



* Package: the unit of compilation

A package is composed of one or more source files that are compiled together.

All of a package's source files (and no other!) must

- be in the same folder (e.g. foo),
- start with the same package clause (e.g. `package`foo`).

Each source file of a package must import the packages it consumes.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _

: imports are not "shared" across source files.



* Exercise: a closer look at the fmt package with go list

`go`list` allows you to ask questions about packages at the command line.

Run the following command in your shell to list the production source files that make up the `fmt` package:

  go list -f "{{ join .GoFiles \"\\n\" }}" fmt

Run the following command in your shell to determine where the `fmt` package lives
on your machine, and check the contents of the folder:

  go list -f "{{ .Dir }}" fmt

Note that the folder also contains test files.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Exercise: a closer look at the fmt package

Consult the documentation of the `fmt` package.

The documentation is available offline via the `go`doc` subcommand:

  go doc fmt
  go doc fmt Println

It's also available online at [[https://pkg.go.dev/fmt][https://pkg.go.dev/fmt]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _



* Package: the unit of encapsulation

In Go, the package (not the type!) is the unit of encapsulation.

There are only two access levels: a package-level identifier is either

- _exported_ (i.e. accessible from another package), or
- _unexported_ (i.e. only accessible within its own package).

Whether a package-level identifier is exported depends on the case of its first letter:

  package foo

  var Bar = "Bar"                   // starts with an uppercase B:   exported by package foo
  type Baz struct { /* ... */ }     // starts with an uppercase B:   exported by package foo
  const qux = 42                    // starts with a lowercase q:  unexported by package foo
  func quux() { /* ... */ }         // starts with a lowercase q:  unexported by package foo



* Importing packages

We'll cover two ways of importing packages: normal imports and named imports.

(For other import syntaxes, see Appendix B.)

The [[https://pkg.go.dev/golang.org/x/tools/cmd/goimports][`goimports`]] utility takes care of adding missing imports, removing unreferenced imports, and organizes imports in a canonical way:

  import (
    // core-library packages

    // third-party packages

    // project packages
  )

.image https://go.dev/blog/store/gophers.jpg 200 _

: We won't mention relative imports again because they are best avoided.
: goimports should run every time you save a file in VS Code



* Normal imports

This is the most common form of import.

You used a normal import in your Hello-World program:

.play -edit src/helloworld.go

To access an identifier exported by a different package (`fmt`, here), you must qualify it using the default package name as prefix (`fmt.Println`).

Importing a package without consuming it causes a compilation error!



* Named imports

Named imports allows you to use the imported package under a different name.

A named import is handy when you perceive the default package name as inappropriate:

  import ml "github.com/jub0bs/missilelauncher"

But named imports are especially useful

- when your code imports multiple packages whose default names collide:

  import "math/rand"
  import crand "crypto/rand"

- when your code uses multiple major versions of a _module_ within the same file:

  import "github.com/jub0bs/missilelauncher"
  import mlv2 "github.com/jub0bs/missilelauncher/v2"

: more on this later



* Types



* Basic types

Go provides basic types:

- booleans
- numeric (integer and floating-point)
- strings

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _



* Composites types

Go also provides composite types, which are composed of other existing types:

- pointers
- functions
- channels
- interfaces
- arrays
- slices
- maps
- structs



* Every type has a zero value

In Go, [[https://twitter.com/dildog/status/1390848784918327298][unlike in C]], there is no such thing as an uninitialized variable.

Every type, whether built-in or user-defined, has a default value called its _zero_value_.

When you declare a variable without initializing it, its value is the zero value of the variable's type:

  var i int    // the value of i is 0
  var s string // the value of s is the empty string ""

Types whose zero value is `nil` are known as _reference_types_: pointers, functions, channels, interfaces, slices, and maps.

: in French: valeur vierge



* Comparability

A type is said to be _comparable_ if arbitrary values of that type can be compared
for equality (with operator `==`) or inequality (with operator `!=`).

All basic types are comparable, but not all composite types are comparable;
for instance, functions, slices, and maps are not.

In some places (map keys, switch expressions, etc.), only comparable types can be used.

.image https://golangforall.com/assets/kanat.svg 200 _



* Type definitions

The `type` keyword lets you define a type based on some existing _underlying_type_:

  type Celsius int
  type Fahrenheit int
  type Kelvin int

`Celsius`, `Fahrenheit`, and `Kelvin` are three _defined_types_ all based on type `int`.

The four types share the same zero value (`0`, in this case).

However, they are distinct types and are *not* interchangeable.

.image https://go.dev/blog/gopher/header.jpg 150 _

: You can only declare methods on defined types that you own.
: you can have type definitions anywhere, incl. inside functions
:   - struct types useful for JSON encoding/decoding
:   - interface types useful for asserting on behaviour
: few restrictions on the underlying type
: You can define types at package level or within functions.



* Type conversion

If two types are "compatible", an expression of one type can be [[https://golang.org/ref/spec#Conversions][converted]] to the other, either implicitly or explicitly.

However, Go requires many conversions from one type to another to be explicit

.play -edit src/type_conversion.go /^//START/,/^//END/



* Variables

Go's declaration syntax departs from C's in many ways.
Rob Pike clarified the motivations behind this departure in
[[https://go.dev/blog/declaration-syntax][a post entitled _Go's_Declaration_Syntax_]].

[[https://go.dev/play/p/GTMUrroC0lz][Playground]]



* var vs. short variable declaration

Short variable declaration is only allowed for local variables, declared within functions.

Moreover, you have to use `var` rather than `:=` when the default type of the initializing expression won't do or cannot be inferred:

  var f Fahrenheit = 32   // more idiomatic than f := Fahrenheit(32)

  userptr := nil          // won't compile: untyped nil
  var userptr *user = nil // fine

In other cases, the choice between the two syntaxes is up to you.

However, convention favors using `var` rather than `:=` when the variable's initial value must be the zero value or simply doesn't matter. Favor `:=` in all other cases.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 150 _



* Pointers

[[https://go.dev/play/p/AqhVJV4KlTm][Playground]]



* If and switch statements



* If statements

The condition must be of type `bool` and needs not be enclosed in parens.
However, braces around the body are mandatory.

.play -edit src/if_simple.go /^//START/,/^//END/

A [[https://golang.org/ref/spec#Statements][_simple_statement_]] (usually a short variable declaration) can precede the condition:

.play -edit src/if_short_variable_decl.go /^//START/,/^//END/

The scope of such variables is restricted to the if(-else) statement.

: mandatory braces: no dangling-else problem like in C, JS, etc.
: short-var-decl: useful for error handling



* If-else statements

Braces around the `else` body are also mandatory.

.play -edit src/if_else.go /^//START/,/^//END/

`else` is one of the least popular keyword in Go!

If-else chains are considered non-idiomatic, and can often be advantageously replaced by a _tagless_ `switch`.



* Switch statement

The switch expression, whose type must be comparable, is evaluated once.

The case expressions (not necessarily constants), are evaluated left-to-right and top-to-bottom and tested for equality against the case expression until a match is found.

The first match's case gets executed. Otherwise, the default case (if any) gets executed.

.play -edit src/switch.go /^//START/,/^//END/

No need for the `break` keyword at the end of cases! Use `fallthrough`, if needed.

: A short-variable-declaration statement can precede the switch condition.
: The default clause can occur at any place among the the normal cases.



* Tagless switch

You can omit the switch expression, which is equivalent to using `true`:

.play -edit src/tagless_switch.go /^//START/,/^//END/

This form of `switch` statement is preferred to a long if-else chain.

(When we cover interfaces, you'll learn another form of switch, called a _type_switch_.)



* Loops



* While-style loop

Remember: no `while` keyword in Go!

.play -edit src/while.go /^//START/,/^//END/

The conditional expression

- must be of boolean type,
- needs not be parenthesized,
- can be omitted (to obtain an infinite loop).



* break and continue

As in other languages, the `break` keyword terminates the (innermost) loop;

.play -edit src/break.go /^//START/,/^//END/

the `continue` keyword skips to the next iteration of the (innermost) loop.

.play -edit src/continue.go /^//START/,/^//END/

For nested loops, those keywords can be used in conjunction with [[https://go.dev/ref/spec#Labeled_statements][_labels_]].



* C-style loop

The familiar loop syntax from the C-family languages is back.

.play -edit src/forc.go /^//START/,/^//END/

Again, no parentheses needed around the init/condition/post part.



* for-range loop

The `range` keyword can be used in conjunction with `for` to iterate over some data structures, such as a string:

.play -edit src/forrange.go /^//START/,/^//END/

A for-range loop can also be used to iterate over arrays, slices, maps, channels. More about that in due time.



* Functions



* Calling a function

To call a function, specify *all* the required arguments by *position* within parentheses
after the name of the function, using commas as delimiters:

.play -edit src/function_call.go /^//START/,/^//END/

[[https://docs.python.org/3/glossary.html#term-argument][Unlike Python]] (and others), Go doesn't allow you

- to specify arguments by keyword or name,
- to specify a default value for a parameter of your function.


* Evaluation strategy: call by value

Go's [[https://en.wikipedia.org/wiki/Evaluation_strategy][evaluation strategy]] is [[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value][_call_by_value_]], without any exception.

Each argument expression is eagerly evaluated, and the result is bound to the corresponding parameter variable within the function.

In brief, functions only operate on *copies* of their arguments:

.play -edit src/call_by_value.go /^//START/,/^//END/



* Evaluation strategy: call by sharing?

However, because some types (strings, slices, maps, channels, functions)
are composed of a pointer to some hidden data structure in memory.

[[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing][_Call_by_sharing_]] is perhaps a more appropriate term than _call_by_value_ to describe
what happens when values of such types are passed to a function.

.play -edit src/call_by_sharing.go /^//START/,/^//END/


* Function declaration

Here is a simple example of a named function:

  func CountWords(s string) int {
    return len(strings.Fields(s))
  }

A function can return multiple results (whose types must be specified within parens):

  func CountWordsInFile(path string) (int, error) {
    var count int
    // ...
    return count, nil
  }

Multiple function results are key to error reporting in Go!

There's no function overloading in Go: no two functions within the same scope
can have the same name but different signatures.



* Namecheck project: validation of Twitter usernames

A prospective username is valid on Twitter if it

- does not contain any case-insensitive match of "twitter" (e.g. "TwItTEr"),
- contains between 4 and 15 alphanumeric or underscore characters.

Write a function that implements the first rule:

  func containsNoIllegalPattern(username string) bool

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: hint: keep it simple


* Named results

You can name (either all or none of) your function's results:

  func CountWordsInFile(path string) (count int, err error) {
    // ...
    return
  }

Note the "naked" return: often, what to return is implied from the list of named results.

The code above is roughly equivalent to the following:

  func CountWordsInFile(path string) (int, error) {
    var count int
    var err error
    // ...
    return count, err
  }

Named results can be useful for documenting the results' roles and simplifying some implementations, but use them sparingly.




* Variadic functions

You can declare a function that accepts an arbitrary number of identically typed parameters:

.play -edit src/function_variadic.go /^//START/,/^//END/


The variadic argument (`rest`, here) is a _slice_ and must be the last to appear in the parameter list.

You've already used a variadic function... Which one? Check its signature in the doc.



* Type factorization in parameter and result lists

The type of identically typed consecutive parameters can be factored out:

  func Split(s, sep string) []string { // see the strings package

Similarly, the type of identically typed consecutive results can be factored out:

.play -edit src/function_factored_type_in_result_list.go /^//START/,/^//END/



* Recursion

Go supports recursion: a function can call itself (directly or indirectly).

.play -edit src/recursion.go /^//START/,/^//END/

Recursion is useful for traversing recursive data structures, such as trees.

Because call stacks grow and shrink as needed, unless you have a bug somewhere,
you're less likely to cause a stack overflow by recursing than in other languages.



* Functions are first-class values

Functions can [[https://pkg.go.dev/net/http/#HandleFunc][take other functions as parameters]], [[https://go.dev/play/p/LfT4e0lPmNV][return functions as results]],
be stored in variables, etc.

.play -edit src/function_nil.go /^//START/,/^//END/

Each function has a type.

Function types are *not* comparable.

The zero value of function types is `nil`.

Be careful: calling a `nil` function causes a panic!

: function-typed results can also be useful for cleaning up; see Mat Ryer's talk



* Anonymous functions and lexical closures

Go supports anonymous functions but lacks a concise "lambda" notation:

  incr := func (i int) int { return i + 1 }

An anonymous functions can _capture_ variables that are accessible to it:

.play -edit src/function_closure.go /^//START/,/^//END/

Anonymous functions are often conveniently used in conjunction with the `go` keyword to launch goroutines.



* And one more thing: defer

*defer* allows you to unconditionnaly execute some code at the end of a function call.

It's particularly useful for cleaning up, reclaiming resources, etc.

More about `defer` later in the course!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 300 _



* Namecheck project: validation of Twitter usernames

Use the `regexp` package to write a function that implements the second rule:

  func looksGood(username string) (bool, error)

Does the function's signature satisfy you?

What signature would you prefer? Why?

How would you achieve that?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/adventure/hiking.svg 200 _

: transition: we need to learn about error handling in Go, and for that we need to learn about if and switch statements
: ^[0-9A-Z_a-z]{4,15}$



* Error handling



* Errors are values

There are no exceptions in Go! Anticipated failures are reported as [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=16m13s]["normal" values]] of the built-in interface type `error`.

A function that can fail returns an additional `error` result (the last one, by convention):

  func Get(url string) (resp *http.Response, err error)

A non-nil `error` result indicates that the function failed in some way and that its "normal" results are unusable.

"err" is a conventional name for error values and the following nil-check idiom is typical:

  resp, err := http.Get("https://jub0bs.com")
  if err != nil {
    // failure (resp is unusable): handle err and perhaps return early
  }
  // success: do something interesting with resp

: mention that a boolean result can be used if the function can fails for a single unambiguous cause

: compare with other languages
:   C: error codes, in-band, no multiple return values; write more to a volatile location in memory
:   Java/Scala: exceptions, or Option, Either or some Result type (more functional)



* Don't ignore errors

Few errors should be ignored. You can deviate from this general rule in some cases,
particularly with `fmt.Println` and friends.

You simply cannot assume success of a fallible function and the soundness
of its other results (if any) if you don't check the error it returns!

Error handling in Go is very explicit; it can be perceived as repetitive and tedious,
but that's actually [[https://changelog.com/gotime/16#transcript-68][a strength of the language]]. You will grow to love it!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-hug.svg 200 _

: for some functions, a non-nil error may indicate only a partial failure (e.g. Read)
: just restart the container? what if you have long-running jobs (e.g. billing)? that would add latency to your system



* Line of sight

Always deal with the failure case first.

Don't do this:

  v, err := fallibleFunction()
  if err == nil {
    // success; do something interesting with v
  } else {
    // failure: handle error
  }

Do this instead:

  v, err := fallibleFunction()
  if err != nil {
    // failure: handle error and perhaps return early
  }
  // success; do something interesting with v

: Narrow code is better than deeply nested code!



* Line of sight (cont'd)

This idiom greatly contributes to the readability of Go code.

By avoiding the `else` keyword and eliminating error cases as they arise,

- you [[https://golang.org/doc/effective_go#if][keep the "happy path" on the left]],
- you [[https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting][minimize nesting]] (your code reads like columns of a broadsheet newspaper),
- you [[https://www.youtube.com/watch?v=yd_rtwYaXps&t=33m30s][reduce the cognitive load]] required to read and understand your code.

See also [[https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88][Mat Ryer's]] and [[https://dave.cheney.net/2019/07/09/clear-is-better-than-clever][Dave Cheney's]] posts on the topic.

.image https://upload.wikimedia.org/wikipedia/commons/4/44/New_York_Times_1914-07-29.jpg 200 _

: also about cognitive load: https://talks.golang.org/2013/bestpractices.slide#3



* Different ways of treating an error value

*Reporting*it*to*the*caller*

- bubbling it up as is
- wrapping it in some custom higher-level error type

*Consuming*it*

- logging it
- printing it to stderr

*Inspecting*it*(before*deciding*what*to*do)*

- comparing it to some sentinel error value (e.g. `io.EOF`)
- looking up its underlying cause (if any)

The best way of treating an error value is highly context-dependent.

: bubble it up: you lose context



* Consuming or reporting? You must choose!

However you choose to handle an error value, do _not_ both consume it and report it!

  func foo() error {
    v, err := fallibleFunction()
    if err != nil {
      log.Println(err) // bad!
      return err       // bad!
    }
    // do something interesting with v
  }

Either consume it or report it, but not both. Why not? Discuss.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _

: I've seen people logging the error at every stage of the call stack! => duplicate entries in logs, confusing



* Creating error values

`errors.New` allows you to create a simple error value:

  err := errors.New("namecheck: failure to check availability of 'jub0bs' on Twitter")

\... but `fmt.Errorf` is more flexible:

  username := "jub0bs"
  platform := "Twitter"
  err := fmt.Errorf("namecheck: failure to check availability of %q on %s", username, platform)

By convention, error messages

- are of the form "<package-name>: <human-readable-error-message>",
- should be lowercase,
- should not contain linebreaks.

You can also create your own error types (i.e. types that satisfy the `error` interface).

: more on custom error types later



* Namecheck project: rethinking the looksGood function

1. Exercise function `looksGood` in your `main` function.

2. Treat the error in a sensible way.

3. Take a few moments to think about function `looksGood`...

- Is it easy to use?
- Does its signature make sense?
- Who, between the caller and library author, would be to blame for a non-nil error?
- How would you improve function `looksGood`?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: we're re-compiling the regexp at each call



* Panic

A panic is a run-time event that indicates an exceptional and fatal failure.

It can be triggered by a run-time error (such as calling a `nil` function) or some direct or indirect call to built-in function `panic`.

A panic stops the programme's normal execution, runs deferred function calls as it unwinds the stack, prints an error message and goroutine traces, and exit the program with a non-zero status:

.play -edit src/panic.go /^//START/,/^//END/

Panics can (but rarely, if ever, should) be [[https://go.dev/blog/defer-panic-and-recover][_recovered_]].

: recover: if you consume a third-party package that panic willy-nilly



* Don't panic willy-nilly in your code

Do not panic in your functions for anticipated and mundane failures:

- a file couldn't be opened
- a HTTP request failed
- the connection to the database dropped

In idiomatic Go, such failures are instead reported to the caller as `error` values.

However, panicking during the initialization of your package is legitimate
if some programming error renders the package unusable.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Namecheck project: fail early if the regexp is unusable

1. In the documentation of the `regexp` package, identify a function that compiles a regular expression and panics if the pattern is invalid.

2. Use that function to declare a variable of type `*regexp.Regexp` at package level.

3. Adapt `looksGood`'s implementation to make use of that variable, and simplify `looksGood`'s signature to

  func looksGood(username string) bool

4. Fix your `main` function accordingly.

.image https://i.redd.it/48emz1dvfz441.png 200 _

: if the regexp is invalid, the package is unusable => communicate that by panicking at initialisation
: more efficient: regexp compiled at most once
: the package-level var cannot be a const



* Namecheck project: validation of Twitter usernames

1. Write a function named `IsValid` that returns `true` if its parameter is a valid username on Twitter, and `false` otherwise:

  func IsValid(username string) bool

2. Write a few "tests" for `IsValid` in the `main` function.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: the need for dedicated packages

All the code we've written in `main.go` so far is specific to Twitter, which is a bit messy.

It would be preferable to create a dedicated library package for each of the supported platforms (Twitter, GitHub, etc.)

Let's learn how to create a library package and use it in our `main` package.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _



* Designing and organizing packages



* Two kinds of packages

*Library*packages*

- A library package produces a library meant to be imported in other packages.
- The package name *must*not* be "main".
- The name of the enclosing folder should match the package name.

*Main*packages*

- A main package produces an executable.
- The package name *must* be "main".
- The package *must* declare a `main` function without any parameters or results.
- The name of the enclosing folder is arbitrary.
- If a project produces several executables, put each of the main packages in a subfolder of a folder named "cmd" located at the root of your project.

: only should, because _test package exception and also not enforced by tooling, but otherwise confusing
: in most cases, the last segment of the package path should match the package name as declared in package clause
: cmd folder: we'll do this ourselves



* Source files of a package

A package is composed of one to several source files.

All of a package's source files must be placed in the same folder.

Source files from different packages cannot be in the same folder!

All package members are accessible to all of the package's source files.

Each source file must import the packages that it needs.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _



* Designing a package

*Naming*a*package*

[[https://www.youtube.com/watch?v=zzAdEt3xZ1M&t=5m45s][A well-designed package starts with its name]]. The name of a package should be

- lowercase alphanumeric (no underscores!),
- concise ("net", not "network") but descriptive (avoid "util", "helpers", "common"),
- a noun rather than a verb,
- a clue to its purpose (rather than its content).

*Strive*for*cohesion*

A package should provide a focused set of related features. Let the name guide you!

*Keep*the*conceptual*surface*area*small*

Don't export identifiers by default; be deliberate about what you export.

: concise: fmt, not format; strconv, not stringconversion



* Good naming practices for package identifiers

Remember: exported identifiers will be prefixed by their package name in client code.

Avoid _stutter_, if possible. (Any counterexamples in the core library?)

  log.LogInfo // not great
  log.Info  // much better

Avoid redundancy in factory functions:

  twitter.NewTwitter // redundant
  twitter.New        // much better

Only choose more specific factory-function names if the package exports multiple types,
such as `Encoder` and `Decoder` in the `encoding/json` package:

  json.NewEncoder
  json.NewDecoder

: exceptions: regexp.Regexp, time.Time



* Subpackages

Subpackages of a package are simply packages located in subfolders of that package.

They allow grouping of functionalities related to but more specific than those provided by their superpackage.

.image img/encoding_core_lib.png 150 _

A package doesn't have any special relationship with its subpackages:

- if package `foo/bar` depends on package `foo`, `foo/bar` must import `foo`;
- `foo/bar` does not have access to identifiers not exported by `foo`;
- `foo` does not have access to identifiers not exported by `foo/bar`.



* No dependency cycles allowed by the compiler

For example, package `foo` cannot import package `bar` if `bar` itself imports `foo`.

.image img/dependency_cycle.svg 150 _

Imports form a _directed_acyclic_graph_, like the graph of commits in a Git repository.

This design decision by the Go team is a key enabler of fast compilation.

.image https://miro.medium.com/max/4800/1*-bo7H329eM0O1eL_ASBVOA.jpeg 200 _

: ex: the core library can be compiled in 10s on a modern machine



* Avoiding dependency cycles with subpackages

A rule of thumb is that a superpackage doesn't depend on any of its subpackages.

For example, here is a partial view of the `encoding` package and its subpackages:

.image img/dep_arrows_dont_point_down.svg _ 1000

Note that no dependency arrows points down.


* Flat is better

To a deep and narrow package hierarchy, prefer a shallow and possibly wide one:

.image img/pkg_shallow_and_wide.svg 400 _



* Keep cool: don't panic

Good library packages do not panic, at least not

- after proper initialization, and
- if they're used as was intended by the package author(s).

Exported functions should communicate anticipated failures to client code as values of the `error` type, not as panics.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/dandy/umbrella.svg 200 _



* Namecheck project: twitter package

1. Create a folder named "twitter" at the root of your project.

2. Create a "twitter.go" file in there:

  namecheck
  ├── go.mod
  ├── main.go
  └── twitter
      └── twitter.go

3. Add the appropriate package clause in `twitter.go`.

4. Move all the Twitter-specific stuff from `main.go` to `twitter.go`.

5. Adjust your `main.go`. You'll need to import your `twitter` package there.



* Testing



* First-party support for testing

Testing plays a key role in the Go ecosystem, and is supported out of the box.

The [[https://pkg.go.dev/testing/][`testing` package]] allows you to test your packages through

- unit tests or integration tests
- example tests (executable examples that end up in the package's documentation),
- micro-benchmarks (laser-focused performance tests for CPU-bound functions).

You can run tests by invoking the `go`test` subcommand.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _

: batteries included: compare to other languages, where testing is an afterthought



* Test files

In Go, a package's test files

- are placed in the same folder as the package's production source files,
- must be suffixed with `_test`.

For instance, to write tests for your package `foo`, composed here of a single source file named `foo.go`, you would create a file named `foo_test.go` in the `foo` folder alongside the `foo.go` file:

  foo
  ├── foo.go
  └── foo_test.go

Respect these location and naming conventions, or you won't be able to run your tests.

Test files are otherwise regular source files in which you write _test_functions_.

: differs from other languages, where tests are located in a mirrored structure of the production code



* White-box testing and black-box testing

You have two options in the name used in the package clause of your test files for package `foo`: `foo` or `foo_test`. This choice determines your testing approach.

*White-box*testing*

You can declare file `foo_test.go` to be part of package `foo`:

  // foo_test.go
  package foo

Your tests then have access to all members (incl. unexported ones) of package `foo`.

*Black-box*testing*

Alternatively, you can declare file `foo_test.go` to be part of package `foo_test`:

  // foo_test.go
  package foo_test

Your tests then only have access to the exported members of package `foo`.



* White or black box?

White-box testing is the approach favored in the core library. It is convenient,
but can lead to prohibitive coupling between tests and implementation details.

.image https://pbs.twimg.com/media/EzrMZe6X0AMSozD?format=jpg&name=900x900 300 _

Black-box testing is an approach favored by [[https://changelog.com/gotime/173#transcript-153][many Gophers]]: it keeps you honest,
as a package author, by forcing you to test your packages through their public API.
It can also be useful to avoid dependency cycles.



* Test functions

A test function is a regular Go function, but its name and signature must adhere
to a strict convention:

- It must be prefixed by `Test` and the following character must be uppercase.
- It takes a single parameter of type `*testing.T` and returns no results.

Respect this convention, or your test functions will be ignored by `go`test`.

The `testing.T` type provides methods (such as `Errorf`) that allow you to indicate that a test is failing, via an informative message.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _



* Test functions: an example for the twitter package

The following example uses black-box testing:

  package twitter_test

  // import declaration of your twitter package (omitted here)

  func TestUsernameContainsTwitter(t *testing.T) {
    // Arrange
    const (
      username = "jub0bsOnTwitter"
      want     = false
    )
    // Act
    got := twitter.IsValid(username)
    // Assert
    if got != want {
      t.Errorf("twitter.IsValid(%q): got %t; want %t", username, got, want)
    }
  }

The message format used here ("got ...; want ...") is widely used.



* Namecheck project: test twitter's IsValid function

Create a file named `twitter_test.go` in the `twitter` folder.

  namecheck
  ├── go.mod
  ├── main.go
  └── twitter
      ├── twitter.go
      └── twitter_test.go

Follow the black-box approach (use `twitter_test` as the package name)
and write the test function shown on the previous slide.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _



* Running tests

From within a package's folder, you can execute its tests by running

 go test

Passing tests are not mentioned in the output; use the `-v` flag to change that:

  go test -v

To execute the tests for a package and all of its subpackages, run

  go test ./...

You can also selectively run some test functions by specifying a regexp, e.g.:

  go test -run='TestUsernameToo*' ./...



* Code coverage

To determine how much of your package's production code is covered by its tests, run

  go test -cover ./...

To generate a more detailed (machine-readable) coverage report, first run

  go test -coverprofile="coverage.out" ./...

Then, for a shell-based breakdown of the coverage by package function, run

  go tool cover --func="coverage.out"

Alternatively, for a browser-based breakdown of the coverage by statement, run

  go tool cover --html="coverage.out"

What would a low coverage say about your tests? What about a high coverage? Discuss.



* Namecheck project: code coverage of twitter package

Inspect the code coverage of your `twitter` package.

Write enough good test cases to reach a code coverage that satisfies you.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/standing.svg 200 _



* Namecheck project: validation of GitHub usernames

Create a `github` package (you can copy the `twitter` package to get started quickly):

  namecheck
  ├── github
  │   ├── github.go
  │   └── github_test.go
  ├── go.mod
  ├── main.go
  └── twitter
      ├── twitter.go
      └── twitter_test.go

A prospective username is valid on GitHub if it

- contains between 3 and 39 alphanumeric or hyphen characters,
- doesn't start or end (or both) with a hyphen,
- doesn't contain two hyphens in a row.



* Namecheck project: validation of GitHub usernames

Write a function named `IsValid` that returns true if its parameter is a valid username on GitHub, and false otherwise:

  func IsValid(username string) bool {
    // returns true if username is valid on GitHub
  }

Adapt the test cases in `github_test.go` and make them pass.

Keep writing test cases until you're satisfied with the overall code coverage.

.image https://go.dev/blog/store/gophers.jpg 300 _



* Namecheck project: availability on GitHub

Let's write a function that checks the availability of a username on GitHub.

1. In the `github` package, add the following stub:

  func IsAvailable(username string) (bool, error) {
    return false, nil
  }

2. Study the second code snippet in [[https://pkg.go.dev/net/http/#pkg-overview][the Overview section of the `net/http` package]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: availability on GitHub (cont'd)

3. Now implement `IsAvailable` for real. It should send a `GET` request to

  https://github.com/USERNAME

where USERNAME stands for the username whose availability we'd like to check.

- If the response's status code is `404`, `IsAvailable` should return `true` and `nil`.
- If the response's status code is `200`, `IsAvailable` should return `false` and `nil`.
- For any other status code or in case an error occurs, `IsAvailable` should return `false` and a non-nil error.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* defer

[[https://pkg.go.dev/net/http/#pkg-overview][The documentation of the `net/http` package]] warns that the client must close the response body when finished with it. Note that the defer keyword is used:

  defer resp.Body.Close()

`defer` is useful for simplifying functions that perform various clean-up actions (such the body of a `http.Response` when you're done with it).

It's similar in spirit to the `finally` keyword from other languages, but it's much more convenient to use. You'll grow to love it!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 200 _

: Along with concurrency primitives and interfaces, this keyword is a highlight of Go!



* Mechanics of the defer keyword

`defer` causes the function call to which it's applied to unconditionnaly execute when the enclosing function terminates (whether normally or because of a panic).

.play -edit src/defer_unconditional.go /^//START/,/^//END/

Deferred function calls are executed in reverse order in which they occur in the enclosing function.

.play -edit src/defer_reverse.go /^//START/,/^//END/



* Mechanics of the defer keyword (cont'd)

Note also that the arguments of a deferred function call are evaluated, not when the function call executes, but when the `defer` statement is reached.

.play -edit src/defer_eval.go /^//START/,/^//END/

More about how `defer` works in [[https://go.dev/blog/defer-panic-and-recover][Andrew Gerrand - Defer, Panic, and Recover]].

: incl. the receiver, if the function is a method



* Why is defer useful?

Here is a version of `IsAvailable` that doesn't use `defer` to close the response body:

.code src/defer_IsAvailable_without_defer.go /^//START/,/^//END/

Notice how we need to call `resp.Body.Close` at each possible exit point of the `IsAvailable` function.



* Why is defer useful? (cont'd)

And now with `defer`:

.code src/defer_IsAvailable_with_defer.go /^//START/,/^//END/

As soon as we know the HTTP request succeeded, we can program the closure of the response body and forget about it!

: also: allows you to colocate the acquisition and cleanup of a resource in your code.



* A defer pitfall

`defer` is unreasonably convenient and powerful, but must be used with caution.

Consider the following function.

  func processFiles(paths ...string) {
    for _, path := range paths {
      file, err := os.Open(path)
      if err != nil {
        // deal with error
        continue
      }
      defer file.Close()
      // do something interesting with file...
    }
  }

What's a potential issue, here? How would you fix it?

: eschewing defer is not an answer :)



* A defer pitfall (cont'd)

Remember that deferred function calls are executed only when the enclosing function terminates, not at the end of the loop iteration that they appear in. Here, the files will all be closed _only_ when the function terminates!

One solution is to enclose the defer statement in a smaller function:

  func processFiles(paths ...string) {
    for _, path := range paths {
      if err := processFile(path); err != nil {
        // deal with error
      }
    }
  }
  func processFile(path string) error {
      file, err := os.Open(path)
      if err != nil {
        // deal with error
      }
      defer file.Close()
      // do something interesting with file...
  }

: defer is not block-based but function-based!
: If we pass a large number of files to the `processFiles` function, we could run out of file descriptors.
: ulimit -n



* Namecheck project: availability on Twitter

We cannot take the same shortcut for Twitter as we did for GitHub, because

  https://twitter.com/USERNAME

returns a `200` response regardless of whether the user `USERNAME` actually exists.

We'll need to do things properly and call the Twitter API.

For now, just stub `IsAvailable` in Twitter:

  func IsAvailable(username string) (bool, error) {
    return false, nil
  }



* Namecheck project: missing abstraction

Our project is starting to take shape, but it still suffers from limitations...

One issue is that, although the `twitter` and `github` packages both export `IsValid` and `IsAvailable` functions with identical signatures, nothing relates them.

It would be nice to have a common abstration to manipulate one or the other indiscriminately...

Interfaces will allow us to do that!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-hug.svg 200 _



* Namecheck project: no way of mocking the HTTP client

Another issue is the lack of testability of function `IsAvailable`.

At the moment, it unconditionally sends a HTTP request to the social network of interest. Explain why this is problematic if you want to write unit tests for `IsAvailable`.

We'd need a way of somehow injecting the real HTTP client in our production code and injecting a "fake" HTTP client in our tests.

Again, interfaces will allow us to solve this issue. Patience!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/crash-dummy.svg 200 _



* Arrays



* Arrays

Arrays are fixed-length containers of elements of the same type.

Contrary to other languages, Go encodes the length of an array in its type name.

The built-in function `len` yields the length of an array.

You can omit to specify the length in array literals and let the compiler infer it.

An array is comparable if the type of its elements is itself comparable.

.play -edit src/arrays.go  /^//START/,/^//END/

: the [0]func() trick is actually used to make types non-comparable w/o compromising memory footprint



* Array indexing

Like most languages, Go uses 0-based indexing.

Individual elements of an array can be accessed using the usual square-bracket syntax.

Taking the address of an array element is legal. Elements are contiguous in memory.

Be careful: indexing outside the bounds of an array causes either a compilation or a run-time error (panic).

.play -edit src/array_indexing.go  /^//START/,/^//END/



* Ranging over an array

You can iterate over an array using a for-range loop.

The first iteration variable corresponds to the index of the current element.

The second iteration variable is only a copy of the array's current element.

.play -edit src/array_range.go  /^//START/,/^//END/



* An array's zero value

Arrays are _not_ reference types. They cannot take the value `nil`.

The zero value of an array type is an array full of zero values of its element type.

.play -edit src/array_zero.go  /^//START/,/^//END/

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/zorro.svg 200 _



* Direct use of arrays is inflexible

A function taking, as a parameter, an array of a given length cannot accept an array of some other length.

.play -edit src/array_inflexible.go  /^//START/,/^//END/

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _



* Direct use of arrays can be expensive

Remember that Go's evaluation strategy is call by value. Accordingly, functions that take an array as parameter operate on a full copy of that array!

.play -edit src/array_expensive.go  /^//START/,/^//END/

.image https://go.dev/blog/gophergala/fancygopher.jpg 200 _



* Arrays are seldom used

For the reasons discussed previously, idiomatic Go code seldom makes direct use of arrays. This is what [[https://go.dev/doc/effective_go#arrays][Effective Go]] has to say on the topic:

_Arrays_are_useful_when_planning_the_detailed_layout_of_memory_and_sometimes_can_help_avoid_allocation,_but_primarily_they_are_a_building_block_for_slices_ [...]

_Slices_ are an abstraction over arrays and, in most situations, using slices should be favored over using arrays.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Slices



* Slices

Slices are arguably the most fundamental and ubiquitous type in Go.

A slice is a variable-length container of elements of the same type.

Contrary to arrays, slices do not have have a length specified in their type name,
and they can grow and shrink over the course of their lifetime.

In addition to slice literals, you can use the built-in `make` function to initialize a slice
of a given length.

.play -edit src/slices.go  /^//START/,/^//END

: only make([]string, l) for now



* Slices under the hood TODO

A slice is essentially a resizable view inside a backing array.

The backing array may extend past the end of the slice.



The _capacity_ of a slice is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice.

When using the `make` function to create a slice, you can specify the length and capacity independently. Doing this is often useful when you're about to add elements to the slice

Built-in functions `len` and `cap` yield the _length_ and _capacity_ of a slice.

: show make([]string, l, c) now



* Slices under the hood (cont'd) TODO

In memory, a slice is a data structure composed of three machine words:

  ------------------------
  | ptr to backing array |
  ------------------------
  |        length        |
  ------------------------
  |       capacity       |
  ------------------------



* Slice function parameters are cheap and flexible

The function operates on a copy of the slice, but copying the slice doesn't cause a copy of the underlying array!

Moreover, a slice parameter is much more flexible than an array parameter.

.play -edit src/slice_cheap.go  /^//START/,/^//END

: 24 bytes on a 64-bit architecture



* Slices are not comparable TODO

Slices are _not_ comparable; the only allowed comparison is to the `nil` value.



* Slice indexing

Like arrays, slices can be indexed.

Taking the address of a slice element is legal.

Be careful: indexing a slice in the negatives or beyond its _length_ causes a panic:

.play -edit src/slice_indexing.go  /^//START1/,/^//END1/

So does indexing a `nil` slice:

.play -edit src/slice_indexing.go  /^//START2/,/^//END2/


* Slicing operator

You can produce a new slice that focuses on a different portion of the same backing array using the _slicing_operator_.

.play -edit src/slicing_operator.go  /^//START/,/^//END/

The first index is inclusive and, if unspecified, defaults to `0`.

The second index is exclusive and, if unspecified, defaults to the length of the slice.



* Namecheck project: pass a username as a command-line arg

1. Consult the [[https://pkg.go.dev/os][documentation of the `os` package]].

2. Identify a member of that package that will allow you to get the program's command-line arguments as a slice of strings.

3. Check the length of that slice; terminate the programme (with a friendly error message) if no username was specified.

4. If a username was specified, use it as before in the rest of your programme.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Slicing operator (cont'd)

For slicing expression `s[i:j]` to be legal, the indices `i` and `j` must satisfy

  0 <= i <= j <= cap(s)

Otherwise, a compilation error or panic will occur.

Note that the slicing operator allows you to retrieve the part of the backing array that extends beyond the length of the slice you're operating on:

.play -edit src/slicing_operator2.go  /^//START/,/^//END/

There's also a three-index form, which can be useful in some cases, but we won't talk about it here.



* Ranging over a slice

Just like for arrays, you can iterate over a slice using a for-range loop.

The first iteration variable corresponds to the index of the current element.

The second iteration variable is only a copy of the slice's current element.

.play -edit src/slice_range.go  /^//START/,/^//END/

: iteration happens over the length (not the capacity) of the slice



* Namecheck project: use table-driven subtests

Have you noticed that the logic is duplicated across our test functions? Let's fix this!

1. Read the section entitled "Table-driven tests using subtests" [[https://go.dev/blog/subtests#table-driven-tests-using-subtests][of this blog post]].

2. Apply this technique in a `TestIsValid` function. If the anonymous struct confuses you, you can declare a `TestCase` struct type at the top of your function.

3. Move all the test cases for the `IsValid` function inside the slice of test cases within your `TestIsValid` test function.

4. You can now safely remove your original test functions.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: note that the name of the type can be omitted in struct literal



* Appending elements to a slice

A built-in function named `append` allows you to add elements to the end of a slice.

Its last parameter is variadic: you can add more than one element to the slice at a time.

.play -edit src/append.go  /^//START/,/^//END/

Under the hood, the `append` function copies elements of the backing array to a larger one when capacity in the former has been reached:

.play -edit src/append_grow.go  /^//START/,/^//END/



* Aliasing

Bear in mind that multiple slices may share the same backing array.

A change to an element of one such slice will be reflected in the other slices.

.play -edit src/slice_spooky.go  /^//START/,/^//END/

In fact, that is what happens when you pass a slice to a function: functions operate on copies of their arguments, but both the original slice and its copy reference the same backing array.



* Aliasing (cont'd)

Be careful: holding a pointer to a slice element while appending is a bad idea!

After appending, the pointer may well point to an element of an old array that is no longer backing the slice!

.play -edit src/slice_aliasing.go  /^//START/,/^//END/

: could cause a memory leak, because old array cannot be GC'd


* Maps



* Maps

A map is a built-in type that represent a unordered collection of key-value pairs.

The type of a map of keys of type `K` and values of type `V` is denoted by `map[K]V`.

The key type *must* be comparable:

.play -edit src/incomparable_key_type.go /^//START/,/^//END/

.image https://golangforall.com/assets/dvoe.svg 150 _

: implemented as a hash table



* Maps are reference types

A function that takes a parameter of some map type only gets a copy of a reference
to the underlying data structure (hash table).

The zero value of map types is `nil`.

Map types are *not* comparable.

.play -edit src/map_reference.go /^//START/,/^//END/



* Creating map values

Invoke built-in function `make` with the desired map type to initialize an empty map:

.play -edit src/map_make.go /^//START/,/^//END/

Alternatively, you can create and populate a map with a _map_literal_:

.play -edit src/map_literal.go /^//START/,/^//END/

The trailing comma is mandatory, here.



* Accessing a value associated with a key in a map

`m[k]` yields the value corresponding to a key `k` in a map `m`.

`m[k]` is *not* addressable!

If the key is absent from the map or if the map is `nil`, the zero value of the map's value type is returned.

To determine whether the key is value is present in the map, you can declare an additional variable (commonly named "ok" or "exists") of boolean type.

.play -edit src/map_access.go /^//START/,/^//END/

: yields the actual value: you can operate on m[k] directly (e.g. m[k]++ if map value type is integer)



* Storing a key-value pair in a map

Associating a key `k` with a value `v` in a map `m` is simple:

  m[k] = v

If the key was already present in the map, the value associated with it prior is lost.

Attempts to store a value in a `nil` map cause a panic!

.play -edit src/map_store.go /^//START/,/^//END/



* Removing a key-value pair from a map

To remove a key `k` and its value from a map `m`, use built-in function `delete`:

  delete(m, k)

If the map is `nil` or if the key is already absent from the map, deleting the key from the map is a no-op.

.play -edit src/map_delete.go /^//START/,/^//END/



* Implementing a set using a map

Go provides no native set types, but... maps to the rescue!

You can simply implement a set of `string` as a map[string]bool:

.play -edit src/map_set_bool.go /^//START/,/^//END/



* Implementing a set using a map (cont'd)

A more memory-efficient alternative consists in using a `map[string]struct{}`:

.play -edit src/map_set_nothing.go /^//START/,/^//END/

Pick whichever of the two approaches you prefer.



* Ranging over a map

You can iterate over a map using `for` and `range`:

.play -edit src/map_range.go /^//START/,/^//END/

At each iteration, the variables yielded by the `range` expression hold copies of
the key and value.

Maps are unordered collections. Not only is the iteration order unspecified, but it is also undeterministic! Try running the code snippet above a few times: the iteration order will typically change from one program execution to the next.



* Ranging over a map in a deterministic order

To range over a map in a certain order, you must

- collect all map keys in a slice,
- sort the slice as desired,
- access the map values as you range over the sorted slice of keys.

.play -edit src/map_range_deterministic.go /^//START/,/^//END/



* Don't insert entries in a map while ranging over it

You can of course mutate values associated to a key that is already present in the map.

However, inserting new keys in a map while ranging over it yields [[https://golang.org/ref/spec#For_range][undefined behavior]]!

.play -edit src/map_insert_while_ranging.go /^//START/,/^//END/

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 200 _

: If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped.
: The choice may vary for each entry created and from one iteration to the next.



* Don't remove entries unrelated to the current iteration

If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced.

Because of [[https://golang.org/ref/spec#For_range][this documented behavior]] and because iteration order on maps is random,
removing entries unrelated to the current iteration causes undesired *undeterminism*.

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Don't remove entries unrelated to the current iteration (cont'd)

Consider the following program:

.play -edit src/map_delete_while_ranging.go /^//START/,/^//END/

From one execution to the next, the output may be either

  map[baz:3 foo:1]

or

  map[bar:2 baz:3]



* Structs

[[https://go.dev/play/p/axkpaElUyHI][Live demo in Playground]]



* Exercise: design a binary tree

1. Open the Go Playground.

2. Declare a struct type named `Tree` to represent one node of a [[https://en.wikipedia.org/wiki/Binary_tree][binary tree]].

- Each node should contain a value of type `int`.
- Each node has at most two children.
- Each node should hold references to its children (if any), but not to its parent node.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Exercise: design a binary tree (cont'd)

3. Implement the following function:

  func Size(t *Tree) int

It should return the number of nodes in its argument.

4. Implement the following function:

  func Sum(t *Tree) int

It should return the sum of the values of all the nodes in its argument.



* Exercise: design a binary tree (solution)

The solution is available on the [[https://go.dev/play/p/bxVmvlNAodD][Go Playground]].

Is it satisfactory?

What if we wanted to use another type for node values?

Discuss.



* A glimpse of generics in Go

Go 1.18 added _generics_ to the language.

Types and functions can now be parameterized by types:

  type Tree[E any] struct {
    Elem  E
    Left  *Tree[E]
    Right *Tree[E]
  }

  func Size(t *Tree[E]) int
  func Sum(t *Tree[E]) E

(The `any` type is simply an alias for `interface{}`.)

Generics promote code reusability while providing some compile-time guarantees.

If you're interested in the gory details, check out the [[https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md][_Type_Parameters_Proposal_]].

However, you don't need to master generics at this stage of your Go learning.

: generic binary tree: https://go.dev/play/p/hViMHc2nEpR?v=gotip



* Namecheck project: availability on Twitter

Implement `IsAvailable` in the `twitter` package:

  func IsAvailable(username string) (bool, error) {
    const tmpl = "https://europe-west6-namechecker-api.cloudfunctions.net/userlookup?username=%s"
    endpoint := fmt.Sprintf(tmpl, username)
    resp, err := http.Get(endpoint)
    if err != nil {
      return false, errors.New("unknown availability")
    }
    defer resp.Body.Close()
    if resp.StatusCode != http.StatusOK {
      return false, errors.New("unknown availability")
    }
    var dto struct {
      Data interface{} `json:"data"`
    }
    dec := json.NewDecoder(resp.Body)
    if err := dec.Decode(&dto); err != nil {
      return false, err
    }
    return dto.Data == nil, nil
  }

: the absence of a data field in the response body indicates the username's availability
: anonymous struct
: simulateLatency=true



* Methods

Now let's talk about methods in Go, so we can turn the `IsValid` and `IsAvailable` functions into methods on the two types we've just declared.

Live demo in Playground



* Namecheck project: turn IsValid and IsAvailable into methods

1. In the `twitter` package, declare a `Twitter` type based on an empty struct:

  type Twitter struct{}

2. Turn `IsValid` and `IsAvailable` into methods on that type (use a pointer receiver).

3. Declare a third method named `String` on the `Twitter` type; it should take no parameter and return a string corresponding to the name of the platform: `"Twitter"`.

4. Adjust your tests in `twitter_test.go` and `main.go`.

5. Repeat steps 1-4 for the `github` package.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Interfaces



* Interfaces in a nutshell

Interfaces (along with generics) are a mechanism for achieving [[https://en.wikipedia.org/wiki/Polymorphism_(computer_science)][_polymorphism_]] in Go:
they allow you to manipulate different concrete type that provide the same behavior(s).

Contrary to all the types that we've covered so far, interfaces are abstract types. An interface is defined by a set of methods/behaviors:

  type Climber interface {
    Climb(meters int) error
  }

Interfaces, by focusing on _behavior_ rather than _implementation_, promote decoupling!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/arts/ballet.svg 200 _

: The names of method parameters are inconsequential and can be omitted
: what matters are the names and signatures of the methods required by the interface.



* Naming convention for interface types

Resist the temptation to name your interface types with and "I" prefix and/or with an "able" suffix, as you would in other language (e.g. `IEnumerable` in C#)!

In Go, the names of interface types are typically nouns rather than adjectives.

For a single-method interface types, convention dictates that its name be derived by appending "er" to the name of its method, even if doing so yields a weird name:

  type Stringer interface {
    String() string
  }

For interfaces types that require multiple methods or are composed of multiple smaller interfaces, naming conventions are not as firmly established. Pick something sensible.



* Interface satisfaction in other languages

In many other languages, interface satisfaction is specified on the type declaration of the implementor:

  class PokerHand implements Comparable<? super PokerHand>  // Java
  class Template implements iTemplate                       // PHP
  class BoomerangCollection : IEnumerable                   // C#

Not so in Go, and that's one reason why interfaces are one of the most fascinating and liberating aspect of the language!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/liberty.svg 250 _



* Interface satisfaction in Go is implicit

If a concrete type has _all_ the methods required by the interface, the compiler automatically considers that the concrete type satisfies the interface:

.play -edit src/interface_sat.go /^//START1/,/^//END1/

A concrete-type value can be used wherever an interface value is expected:

.play -edit src/interface_sat.go /^//START2/,/^//END2/

Important: `*Mountaineer` satisfies the `Climber` interface, but `Mountaineer` doesn't.

: structural typing as opposed to nominal subtyping



* Interface satisfaction: the fine print

Some interface types require implementors to follow additional rules. For instance,

- [[https://pkg.go.dev/io/#Reader][the `io.Reader` interface]] places restrictions on what can be done with the parameter and results of its `Read` method, and
- [[https://pkg.go.dev/net/http#RoundTripper][the `http.RoundTripper` interface]] requires that implementors be safe for concurrent use by multiple goroutines.

Bear in mind that such rules are not enforcible by the compiler, and that the onus is on you to respect them in your implementations.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _

: If you don't, your code may not work as expected.



* Keep interfaces small

The [[https://en.wikipedia.org/wiki/Interface_segregation_principle][Interface-Segregation principle]] states that clients should not be forced to depend on methods that they do not use. See [[https://www.youtube.com/watch?v=zzAdEt3xZ1M&t=12m49s][Dave Cheney - SOLID Go Design]].

Accordingly, refrain from _interface_pollution_, i.e. declaring interface types with many methods. Smaller interfaces are comparatively easier to satisfy and more composable.

[[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=5m18s][As Rob Pike puts it]]: _the_bigger_the_interface,_the_weaker_the_abstraction_.

Many of the interface types provided by Go's standard library are single-method:
`error`, `fmt.Stringer`, `io.Writer`, `io.Reader`, `http.Handler`, etc.

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _

: small interfaces are also easier to redeclare locally, in order to promote source decoupling
: could redeclare Stringer locally to avoid namecheck having to depend on fmt



* Namecheck project: move your main.go to a cmd folder

We're about to create a `namecheck` package at the root of our project, but our `main.go` (which belongs to package `main`) is getting in the way. Let's move it elsewhere.

1. Create a folder named "cmd" at the root of your project.

2. Move your `main.go` file to `cmd/`:

  namecheck
  ├── cmd
  │   └── main.go
  ├── github
  │   ├── github.go
  │   └── github_test.go
  ├── go.mod
  └── twitter
      ├── twitter.go
      └── twitter_test.go

3. From the root of your project, check that `main.go` still compiles:

  go run cmd/main.go



* Namecheck project: declare a Validator interface

1. At the root of your project, in a file named `namecheck.go`,
declare the following interface:

  type Validator interface {
    IsValid(string) bool
  }

2. Do `twitter.Twitter` and `github.GitHub` satisfy it? If not, make it so!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: mention that we're defining Validator after the fact!



* Namecheck project: declare an Availabler interface

1. Still in `namecheck.go`,  declare the following interface:

  type Availabler interface {
    IsAvailable(string) (bool, error)
  }

2. Do `twitter.Twitter` and `github.GitHub` satisfy it? If not, make it so!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: satisfy the fmt.Stringer

1. Study the [[https://pkg.go.dev/fmt#Stringer][documentation]] of the `fmt.Stringer` interface type.

  type Stringer interface {
    String() string
  }

That interface governs how functions from the `fmt` package represent values of the concrete type in question.

2. Do `twitter.Twitter` and `github.GitHub` satisfy it? If not, make it so!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Interface composition

Consider these two interfaces:

  type Reader interface {
    Read([]byte) (n int, err error)
  }

  type Closer interface {
    Close() error
  }

To declare an interface type that is both a `Reader` a `Closer`, you could of course just list the required methods:

  type ReadCloser interface {
    Read([]byte) (n int, err error)
    Close() error
  }

But no need to repeat yourself! Interface composition is easier than this in Go...



* Interface composition (cont'd)

You can declare a larger interface type simply by listing the more elementary interfaces it's made of:

  type ReadCloser interface {
    Reader
    Closer
  }

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _

: A mix of methods and interface names is also allowed:



* Namecheck project: declare a Checker interface

1. Still in `namecheck.go`, declare an interface type named `Checker` by composition of

- a `Validator`
- an `Availabler`
- a `fmt.Stringer`

2. Do `twitter.Twitter` and `github.GitHub` satisfy it?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: use a slice of Checkers

1. In your `main` function, create a slice of `Checker` with two elements:

- a pointer to a `twitter.Twitter`
- a pointer to a `github.GitHub`

2. Simplify the existing code by ranging over the slice of `Checker` values.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Notable interfaces: the empty interface

The empty interface is an interface that requires no method:

  interface{}

Therefore, it is automatically satisfied by _all_ types (no exception) in Go.

The empty interface is useful for maximum flexibility in very generic functions,
such as `fmt.Println`:

  func Println(a ...interface{}) (int, error)



* Notable interfaces: the empty interface (cont'd)

Because the empty interface is the least specific type in Go, you should use it sparingly.

[[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=7m36s][As Rob Pike puts it]], the empty interface says nothing.

If you declare a function that takes a parameter of type `interface{}`, Go's type checker can't provide any compile-time guarantees about the nature of that parameter.

Therefore, peppering empty interfaces all over the business layer of your application (where being very specific pays off) is a bad idea!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _

: a bit like *void in C



* Notable interfaces: error

Yes, `error` is an interface!

In fact, it's the only interface predeclared by the language, which explains why its name can start with a lowercase "e".

  type error interface {
    Error() string
  }

You can declare your own types and make them satisfy the `error` interface.

  type ErrUnkownAvailability struct {
    Username string
    Platform string
    Cause    error
  }

  func (e *ErrUnkownAvailability) Error() string {
    const tmpl = "unknown availability of %q on %s: %v"
    return fmt.Sprintf(tmpl, e.Username, e.Platform, e.Cause)
  }



* Notable interfaces: fmt.Stringer

`fmt.Stringer` requires a single method:

  type Stringer interface {
    String() string
  }

If a type satisfies `fmt.Stringer`, its `String` method governs the textual representation that functions from the `fmt` package use for that type.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _



* Notable interfaces: io.Reader and io.Writer

The `io` package provides two complementary interface types:

  type Reader interface {
    Read(dst []byte) (int, error)
  }

  type Writer interface {
    Write(src []byte) (int, error)
  }

`io.Reader` represents a _source_ of bytes; it's satisfied by `os.Stdin`, `*os.File`, etc.

`io.Writer` represents a _sink_ of bytes: it's satisfied by `os.Stdout`, `*os.File`, etc.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/projects/network-side.svg 200 _



* Interfaces under the hood

  ----------------------
  | pointer to itable  |
  ----------------------
  |  pointer to value  |
  ----------------------

Under the hood, an interface value is a two-word data structure:

- a pointer to an _itable_, which contains metadata about the concrete type stored in the interface value: name, set of methods, etc.
- generally, a pointer to the value of the concrete type stored in the interface value.

For the gory details, see [[https://research.swtch.com/interfaces][Russ Cox - Go Data Structures: Interfaces]].

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 150 _



* An interface's zero value

Interfaces are reference types; therefore, manipulating pointers to interface is rare.

An interface type's zero value is `nil`:

.play -edit src/interface_zero.go /^//START/,/^//END/

An interface value is considered `nil` if and only if

- *it*isn't*associated*to*any*concrete*type* (!), and
- it does contain or point to the value of a concrete type.

  ---------------------------------------
  |                 nil                 |
  ---------------------------------------     ==     nil
  |                 nil                 |
  ---------------------------------------

: pointers to interfaces useful for decoding JSON to an interface value
: see https://blog.golang.org/json-and-go



* Pitfall: interface vs. nil

Be careful: an interface value that holds a `nil` pointer to a concrete type is not itself `nil`!

  ---------------------------------------
  | pointer to twitter.Twitter's itable |
  ---------------------------------------     !=     nil
  |                 nil                 |
  ---------------------------------------

Developers who fail to account for this distinction expose themselves to subtle bugs...

More details about this subtlety are available in the [[https://go.dev/doc/faq#nil_error][Go FAQ]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _

: Interface types are comparable, but you already know that... How?



* Interface vs. nil: spot the bug

The following programme contains a subtle bug. Can you identify it?

.play -edit src/interface_nil.go /^//START/,/^//END/



* Interface vs. nil: spot the bug (solution)

  -----------------------------------------
  | pointer to *ErrLaunchFailure's itable |
  -----------------------------------------     !=     nil
  |                 nil                   |
  -----------------------------------------

To indicate failure, a fallible function should return a result of type `error`, as opposed to a result of a concrete type that happens to satisfy the `error` interface!

.play -edit src/interface_nil_fixed.go /^//START/,/^//END/

See [[https://www.youtube.com/watch?v=ynoY2xz-F8s&t=14m12s][Francesc Campoy Flores - Understanding nil (GopherCon 2016)]].



* Interface vs. nil: spot the bug again

The following programme contains a subtle bug. Can you identify it?

.play -edit src/interface_nil_concrete_var.go /^//START/,/^//END/


* Interface vs. nil: spot the bug again (solution)

  -----------------------------------------
  | pointer to *ErrLaunchFailure's itable |
  -----------------------------------------     !=     nil
  |                 nil                   |
  -----------------------------------------

.play -edit src/interface_nil_fixed.go /^//START/,/^//END/

Avoid declaring variables of a concrete type that happens to satisfy `error`!

See [[https://www.youtube.com/watch?v=ynoY2xz-F8s&t=13m20s][Francesc Campoy Flores - Understanding nil (GopherCon 2016)]].



* Favor interface parameters

If a given function parameter is supposed to provide _behavior_ (rather than data), you should strive to use an interface type (rather than a concrete type) for that parameter.

This principle isn't specific to Go and is known as [[https://blog.ndepend.com/programming-interface-simple-explanation/][_programming_to_an_interface_]].

For example, don't do this:

  type Tree struct {...}
  func (t *Tree) Save(f *os.File) error

Instead, do this:

  type Tree struct {...}
  func (t *Tree) Save(w io.Writer) error

The latter is more flexible, easier to test, promotes decoupling, and guides you towards the correct implementation.

: os.File has a lot of methods that are not relevant to what Tree's Save is supposed to do



* Require no more, promise no less

If what's of interest is behavior rather than implementation, your functions shouldn't ask for behaviors that they don't need.

In other words, if a function takes an interface parameter, that interface type should be as "small" as possible.

Don't do this:

  func (t *Tree) Load(rw io.ReadWriter) error

Instead, do this:

  func (t *Tree) Load(r io.Reader) error

Again, this is more flexible, testable, and promotes correctness of implementation.

See [[https://www.youtube.com/watch?v=zzAdEt3xZ1M&t=12m36s][Dave Cheney - SOLID Go Design]].

: a reason to keep interfaces small
: This principle is similar in spirit to the Domain Driven Domain's principle known as "keeping ports small".



* Avoid premature abstraction

As Rob Pike puts it: don’t design with interfaces, discover them.

You should resist the temptation to declare interface types upfront.

Instead, start with concrete types and let interfaces emerge naturally when needed
(e.g. for testability purposes).

Note that we declared the `twitter.Twitter` and `github.GitHub` struct types first,
and only then did we declare the interface types they satisfy.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Using interfaces for test doubles

[[https://www.martinfowler.com/bliki/TestDouble.html][_Test_doubles_]] are substitutes for objects whose side effects are undesirable in tests. Depending on the role they play within a test, people call them _mocks_, _stubs_, _fakes_, etc.

You now know that you can you declare an interface _after_the_fact_ for your own types.

But even if you use a concrete type that you do not own and for which no interface type is provided, you can always declare your own interface type that this concrete type automatically satisfies!

See [[https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742#e976][Mat Ryer's - 5 simple tips and tricks for writing unit tests in #golang]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/lifting-1TB.svg 200 _

: we defined Validator, Availabler, Checker after declaring Twitter and GitHub struct types
: unit test: no I/O, limit site effects
: email sender: you don't want to send an email every time
: payment system: unless e2e tests, don't want to trigger a real payment in unit tests



* Namecheck project: mocking the HTTP client

1. Inspect the source code for `http.Get`.

2. In `namecheck.go`, judiciously declare a useful `Getter` interface that `*http.Client` already satisfies.

3. Create a `stub` package and, in `stub.go`, declare the following struct type:

  type SuccessfulGetter struct {
    StatusCode int
  }

4. Make `stub.SuccessfulGetter` satisfy your `namecheck.Getter` interface; its `Get` method should always succeed and return the specified status code

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Namecheck project: mocking the HTTP client (cont'd)

5. Add a field of type `namecheck.Getter` to your `Twitter` and `GitHub` struct types.

  type Twitter struct {
    Getter namecheck.Getter
  }

6. Adjust your `main.go`

7. Write a few test cases for `github.GitHub`'s `IsAvailable` method and run them.

8. Is our stub type sufficient for testing `twitter.Twitter`'s `IsAvailable` method? If not, what would you change?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _

: You may get some panics. If you do, can you figure out why and fix it?
: need a non-nil request body: use http.NoBody



* Namecheck project: simulating support for many platforms

1. In `main.go`, judiciously populate your `[]Checker` slice with twenty pointers to the same `twitter.Twitter` instance.

2. Similarly, populate your slice of checkers with twenty pointers to the same `github.GitHub` instance.

3. Run your executable.

4. Comment on user experience. Is it fast? How could you improve things?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/stovepipe-hat-front.svg 250 _



* Namecheck project: make room for another main.go

We'll experiment with concurrency inside another `main.go`. Later, we'll write a server in that file. Let's set things up!

1. Create a folder named "cli" within the `cmd` folder. Move your `main.go` to `cmd/cli/`.

2. Create a folder named "server" within the `cmd` folder. Create a new `main.go` there.

  namecheck
  ├── cmd
  │   ├── cli
  │   │   └── main.go
  │   └── server
  │       └── main.go
  ├── github
  │   ├── github.go
  │   └── github_test.go
  ├── go.mod
  ├── namecheck.go
  └── twitter
      ├── twitter.go
      └── twitter_test.go






* Concurrency



* What do we mean by "concurrency"?

The art of composing a programme in terms of independent computations

Go has native support (i.e. in the language and runtime) for concurrency.

Go's concurrency model arguably is one of the language's most attractive features,
but can be difficult to learn and master.

.image https://i.stack.imgur.com/QjsGt.png 200 _

: hence being relegated to the end of many learning resources



* Concurrency metaphors

Disclaimer: many cooking metaphors ahead!

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 400 _



* Concurrency is not parallelism

*Concurrency*

- the art of structuring a programme in terms of independenly executing computations
- a property of the programme's code

*Parallelism*

- the simultaneous execution of multiple things on multiple cores
- a property of the running program



* Parallelism is not the goal of concurrency

Concurrency _enables_ parallelism, but parallelism isn't the goal.

Writing concurrent code is valuable regardless of whether that code will run in parallel.

And if good concurrent code _does_ run in parallel, we should get graceful performance improvement for free as the number of cores increase.

See also

- [[https://www.youtube.com/watch?v=oV9rvDllKEg][Rob Pike - Concurrency is not Parallelism (2012)]].
- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=3m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]

: metaphor: cooking recipe typically has a concurrent component, but whether you can prepare it in parallel depends on the number of cooks/hobs you have!



* Go's concurrency model

Largely inspired by [[https://dl.acm.org/doi/10.1145/359576.359585][Tony Hoare's  _Communicating_Sequential_Processes_ (1978)]]

Two fundamental mechanisms:

- goroutines: lightweight threads
- channels: typed pipes used to communicate and synchronize between goroutines

.image https://i.stack.imgur.com/QjsGt.png 200 _



* Goroutines

A goroutine is a concurrent function execution.

It can be thought of as a very lightweight thread: it's common for programmes to have 1000s of goroutines, even on a single core.

The `main` function is itself a goroutine that is created when the programme starts.

Each goroutine gets its own stack, which starts small and grows/shrinks as required.

.image https://go.dev/blog/store/gophers.jpg 300 _



* Goroutines execute in the same address space

For example, a goroutine can pass a pointer to another goroutine, and the latter can dereference that pointer without causing an access violation.

[[https://golang.org/doc/effective_go.html#goroutines][The onus is on you to be careful]] in order to avoid _data_races_!

A [[https://en.wikipedia.org/wiki/Race_condition#Data_race][data race]] occurs when multiple goroutines write to and read from the same memory location in a concurrent fashion (i.e. at the "same" time).

.image http://alinken.people.ua.edu/uploads/8/7/9/2/87929690/published/ghostbusters.jpg


* The Go scheduler

The _Go_scheduler_ is a part of the Go runtime that automatically multiplexes goroutines onto operating-system threads and manages their scheduling for us.

It continually observes the run-time behavior of goroutines and decides to suspends them when they block and then resumes them when they become unblocked.

No need for you to think about it yet; for now, simply picture the Go scheduler and goroutines as a chef and his/her kitchen assistants.

.image https://rrsg.s3.amazonaws.com/wp-content/uploads/2020/03/25180622/90517519_1171371749860657_3506201698723816143_n.jpg 250 _

: scheduler mechanics discussed in the advanced course



* The go keyword

The `go` keyword spawns a new goroutine: it causes the function call to which it applies to get executed "in the background":

  go grindCoffeeBeans()
  go frothMilk()

`go` statements do not block; they _immediately_ yield control to the next instruction.

The function's arguments (if any) are executed _before_ the goroutine starts.

The function's results (if any) are lost, but channels can be used to communicate values between goroutines.



* The go keyword (cont'd)

Launching an anonymous function as a goroutine is sometimes convenient for grouping statements that should be executed in the background:

  go func() {
    fmt.Println("Don't mind me!")
    fmt.Println("I'm just running in the background...")
  }()

Just don't forget to invoke it!

  go func() {
    fmt.Println("Don't mind me!")
    fmt.Println("I'm just running in the background...")
  } // missing parentheses

: goroutine terminology: spawning/spawned, parent/child



* Goroutines vs. Unix processes

It's useful to compare goroutines to Unix processes...

The `go` keyword is reminiscent of the ampersand operator (`&`) in Unix shells.

  #!/usr/bin/env sh

  grindCoffeeBeans &
  frothMilk &

However, unlike a Unix process, a goroutine has no concept of an ID (see why [[https://talks.golang.org/2014/go4gophers.slide#38][here]]).

Therefore, a goroutine cannot readily be _killed_.



* The golden rule about the go keyword

Before spawning a new goroutine, you must understand exactly under what conditions it will terminate.

If you're careless and spawn goroutines willy-nilly, you expose yourself to correctness and performance bugs (_goroutine_leaks_).

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Exercise: concurrent coffee making

Write two functions, `grindCoffeeBeans` and `frothMilk`, that

- take no parameters and return no results,
- simply write an informative message to stdout.

Call them concurrently in the `main` function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _

: Q: Which message will be printed first? We can't tell. Up to the scheduler.



* Exercise: concurrent coffee making (first attempt)

.play -edit src/goroutines_without_waitgroup.go /^//START/,/^//END/

Does the programme behave as you expected? Why or why not?



* main does not wait!

Nothing gets written to stdout because

- the two `go` statements _immediately_ transfer control back to `main`, and
- `main` terminates _before_ your two goroutines themselves terminate!

We need a way to tell `main` to "wait" until the two goroutines terminate.

Any ideas?



* Exercise: concurrent coffee making (with sleep)

Sleep a bit at the end?

.play -edit src/goroutines_with_sleep.go /^//START/,/^//END/

However, this solution is not entirely satisfactory. Why?

: inefficient at best, nondeterministic at worst



* Sleeping is not the answer

How long should the sleep be, exactly? Impossible to know in advance.

- Wait too little: `main` terminates too quickly for all the other goroutines to terminate.
- Wait too long: `main` ends up needlessly spinning and wasting time.

.image https://drek4537l1klr.cloudfront.net/youngman/Figures/f0255-01.jpg 200 _

Sleeping is simply not a reliable and efficient way of coordinating goroutines!

We need another mechanism...

: there are legitimate use cases for `time.Sleep` in a Go programme, but...



* Wait groups

The [[https://pkg.go.dev/sync/#WaitGroup][`sync` package]] provides a mechanism for orchestrating goroutines: _wait_groups_.

A wait group is little more than a glorified counter with _concurrency-safe_ operations.

A wait group allows you to

- keep track of the number of goroutines you spawn to perform a particular task, and
- wait for all those goroutines to terminate before moving on.

Wait groups are particularly useful when the number of goroutines to spawn is not known in advance.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/arts/upright.svg 200 _

: e.g. if you're spawning a goroutine for each line of a file that you're reading, or for each element received from a channel



* Using a wait group

Initialize a variable of type `sync.WaitGroup`, whose the zero value is readily usable.

A wait group supports three operations:

  func (wg *WaitGroup) Add(delta int)

- increments the counter by delta
- should be called _just_before_ spawning a goroutine

  func (wg *WaitGroup) Done()

- decrements the counter by 1
- should be called _at_the_very_end_ of each spawned goroutine (with a `defer`, typically)

  func (wg *WaitGroup) Wait()

- `wg.Wait()` blocks until the counter goes back to 0 (acts as a [[https://en.wikipedia.org/wiki/Barrier_(computer_science)][_barrier_]])
- should be called at the point of the spawning goroutine where you need to wait

: wg.Done() is equivalent to wg.Add(-1)



* Exercise: concurrent coffee making (using a wait group)

Use a wait group to make `main` wait until both `grindCoffeeBeans` and `frothMilk` have terminated before `main` itself can terminate.

Tip: you can apply the `go` keyword to an anonymous function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _

: if you don't control the functions you want to spawn as goroutines, wrap them in anonymous funcs that capture the waitgroup



* Exercise: concurrent coffee making (using a wait group)

(implementations of `grindCoffeeBeans` and `frothMilk` are as before)

.play -edit src/goroutines_with_waitgroup.go /^//START/,/^//END/

: don't forget the pair of parens at the end of each function literal!
: What happens if I remove a wg.Done()? deadlock
: What happens if I remove a wg.Add(1)? only one of the two goroutine will likely have time execute



* How not to misuse wait groups

Calls to `wg.Add` must take place in the spawning goroutine, _not_ within the child goroutine.

The call to `wg.Wait` must happen _after_ all calls to `wg.Add` (otherwise: data race).

A `sync.WaitGroup` must not be copied after first use. If a function needs to operate on a wait group that was declared elsewhere, pass a pointer to it (`*sync.WaitGroup`) as an argument to that function.

.image https://go.dev/blog/gopher/plush.jpg 250 _

: if wg.Add concurrent with wg.Wait, data race: https://go.dev/play/p/PPlY-M7yfYh



* Closures running as goroutines: spot the bug

Can you spot the bug in the following programme?

.play -edit src/goroutine_func_quiz.go /^//START/,/^//END/

: ask them first how they expect the programme to behave
: sometimes prints 10, not 9! because iteration variable goes beyond bound before loop can end



* Closures running as goroutines: explanation

There is a _data_race_: a variable is being read and updated by different goroutines in a concurrent fashion!

More specifically, the goroutines spawned by `printTenIntsConcurrently` _capture_ and read iteration variable `i` as it's being updated by the loop.

.play -edit src/goroutine_func_answer.go /^//START/,/^//END/

Consequently, the programme is undeterministic: the results are unpredictable.

: before learning how to fix it, let's see how we can get help for detecting it



* Detecting the data race

We've identified the data race by inspection, but some static- and dynamic-analysis tools can help.

*go*vet*

This subcommand analyzes the code and can detect issues that the compiler does not.

Try running `go` `vet` on the programme.

*race*detector*

The Go CLI provides a [[https://go.dev/blog/race-detector][race detector]], i.e. a tool that can detect data races during execution.

Try running the programme with the `-race` flag.

Caution: the race detector is [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][not guaranteed to catch all data races]].



* Fixing the data race

One way to fix the data race consists in shadowing the iteration variable inside the loop, before the `go` statement.

.play -edit src/goroutine_func_redecl.go /^//START/,/^//END/

Although the redeclaration looks a bit weird, this solution has merit insofar as the fix is colocated with the start of the `go` statement (reduced cognitive load).

See also the [[https://golang.org/doc/faq#closures_and_goroutines][Golang FAQ about this]].

: kind of awkward to pass them as parameters further down if the anonymous function is long



* Fixing the data race

An alternative solution consists in passing the value of the iteration variable as an argument to the anonymous function.

That way, by virtue of Go's call-by-value evaluation strategy, the function only has access to a copy of the iteration variable's value at the time of the iteration of interest.

.play -edit src/goroutine_func_arg.go /^//START/,/^//END/



* Be careful when running closures as goroutines

When running a closure as a goroutine, it's very easy to inadvertently capture variables, which may cause data races.

Defining a dedicated named function can help:

.play -edit src/goroutine_func_standalone.go /^//START/,/^//END/



* Namecheck project: check each user name concurrently

1. Extract the body of the for-range loop on your `[]Checker` slice as a function in your `main` package:

  func check(checker namecheck.Checker, username string, wg *sync.WaitGroup)

2. Within the loop, apply the `go` keyword to your `check` function.

3. Use a wait group in order to wait, at the end of the `main` function, for all the goroutines that you spawned to terminate.

Does user experience improve?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Namecheck project: aggregate the results (how?)

What if, instead of printing the results, we wanted to somehow aggregated them?

Remember: the result(s) of the function call to which the `go` keyword is applied are lost.

We need a way to communicate between goroutines...

.image https://go.dev/blog/gopher/plush.jpg 300 _



* Channels



* Sharing is caring

Because goroutines all execute in the same address space, programs that modify data being simultaneously accessed by multiple goroutines [[https://golang.org/ref/mem#tmp_1][*must* serialize such access]].

Programs that ignore this injunction are bound to contain [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][_synchronization_bugs_]], which may manifest as _data_races_...


.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Share memory by communicating

Rather than using locks to synchronize goroutine access to the shared memory, Go encourages an approach in which shared values are passed around on _channels_.

The Go community [[https://golang.org/doc/effective_go#sharing][summarizes this powerful idea]] through a slightly cryptic mantra:
[[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=2m42s][_Do_not_communicate_by_sharing_memory;_instead,_share_memory_by_communicating._]]

Compared to their lower-level alternatives alternatives, channels are indeed often

- more elegant,
- more composable,
- less error-prone.

As Rob Pike puts it: [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=4m20s][channels orchestrate; mutexes serialize]].



* Channels are typed

Channels are typed conduits that allow goroutines to synchronize and exchange information.

The element type of a channel is arbitrary.

A channel whose element type is `T` has type `chan`T`.

  var ch chan string // channel of strings

: channels only exist within the confines of your programme; they can't be used to communicate between different processes, be they written in Go.



* Popular naming choices for channels

"c" or "ch", on its own or as a suffix (with or without camelcase):

  var c chan int
  var ch chan string
  var errc chan error
  var taskCh chan Task

Plural of the channel's element type:

  var tasks chan Task

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _



* Channels are first-class values

You can pass a channel to a function:

  func Aggregate(results chan Result) Result { /* ... */ }

You can return a channel from a function:

  func Generate(upTo int) chan int { /* ... */ }

You can store a channel in a struct type:

  type Request struct {
      fn func() int  // The operation to perform.
      c  chan bool    // The channel to return the result.
  }

Channels are comparable.



* Initializing a channel

Channels are reference types; their zero value is `nil`.

To initialize a channel, use built-in function `make` with two arguments:

- the first argument corresponds to the type of the channel;
- the second argument is an (optional) `int` corresponding to the channel's desired (non-negative) _capacity_.

  c1 := make(chan string, 16) // initialize a channel of strings of capacity 16
  c2 := make(chan string)     // equivalent to make(chan string, 0)

A channel's capacity cannot be changed after initialization.

A freshly initialized channel starts its life in an "open" state, but can later be _closed_.

: The specified capacity (if any) must be non-negative; otherwise, you'll get a compilation error or, worse, a panic.



* Channel capacity

A channel's capacity corresponds to the size of its _buffer_, i.e. the maximum number of elements that the channel can contain at any give time.

Choosing it wisely is important, as it usually affects the correctness and/or the performance of your programme.

Built-in function `cap` can be used to query a channel's capacity:

  c := make(chan string, 16) // initialize a channel of strings of capacity 16
  fmt.Println(cap(c))        // 16

Some terminology:

- A channel of zero capacity is said to be _unbuffered_ or _synchronous_.
- A channel of positive capacity is said to be _buffered_.

: The number of elements queued in a channel's buffer can also be queried via built-in function `len`, but is rarely useful. Why?
: if more than one goroutine interact with the channel, len(ch) is stale as soon as queried
: increasing buffer size may help reduce pressure on the Go scheduler



* A kitchen serving-hatch as a metaphor

Think of goroutines as cooks and waiters on either side of a serving hatch,
which represents a channel.

The channel's capacity corresponds to the number of plates that can fit
on the serving hatch's platform at any one time.

.image https://josephdmcnamee.files.wordpress.com/2012/01/serving-hatch1.jpg 350 _

: what does a channel of capacity 0 correspond to?
: the analogy is imperfect because channels are FIFO and waiters don't necessarily pick up plates in the order in which they arrived



* Choose the capacity of your channels wisely

Choosing the capacity of a channel can be delicate!

In some cases, that choice directly impacts program correctness. If you choose unwisely, the program will typically deadlock or won't produce the correct results.

In other cases, it has no impact on correctness, but an unwise choice causes some _goroutine_leaks_, which in turn can cause performance degradation and even crashes.

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Choose the capacity of your channels wisely (cont'd)

In yet other cases, that choice has no impact on correctness or on the occurence of goroutine leaks, but it affects performance.

In such cases, you should profile your program under realistic load in order to determine a good value to use.

Such performance optimization is covered in [[https://www.humancoders.com/formations/go-avance#outline][the next course]].

.image https://go.dev/blog/5years/gophers5th.jpg 300 _




* Operations on a channel

Channels support the following operations:

- _sending_ a value to a channel,
- _receiving_ a value from a channel,
- _closing_ a channel (that hasn't been closed yet).

You can also _range_ over a channel, which consists in continually receiving values from it.

All those operations are *concurrency-safe*.

: _Channel_communications_ is a general term for describing both channel sends and receives.
: we'll see why closing a channel is useful soon



* Sending to a channel

The syntax of a _channel_send_ consists in the name of the channel in question
followed by a left-pointing arrow (`<-`) followed by the value to send.

  ch := make(chan string)
  // ...
  v := "superimportant message"
  ch <- v

The `gofmt` tool will adds a space on either side of the arrow; don't fight it.

A channel send is a statement, not an expression.



* Semantics of a channel send

.image img/send_semantics.svg _ 900

Note: buffered channels accept a limited number of values without a corresponding receive for those values.



* Receiving from a channel

The syntax of a _channel_receive_ consists in a left-pointing arrow (`<-`) followed by the channel in question.

  ch := make(chan string)
  // ...
  <-ch

The `gofmt` tool removes any whitespace between the arrow the channel; don't fight it.

A channel receive is an expression: you can store the received value in a variable,
or pass it to a function.

  v := <-ch
  fmt.Println(v)

The value received is only a copy of the value that was sent to the channel.



* Semantics of a channel receive

.image img/receive_semantics.svg 450 _

Note: the value received from a channel by a goroutine is only accessible to that goroutine; it is removed from the channel for all the other goroutines.



* Receive ambiguity

As shown by the diagram on the previous slide, when a channel is closed and empty, receiving from that channel yields the zero value of the channel's element type...

How can we tell whether the value we're receiving is from a closed channel or whether someone really sent a zero value of the element's type to the channel?

.image https://go.dev/blog/gopher/plush.jpg 300 _



* Dispelling the ambiguity

There is a special form of channel receive that yields an additional boolean value (named "ok", by convention):

   v, ok := <-ch


The value of variable `ok` is

- `true` if the value received was delivered by a send operation to the channel, or
- `false` if it is a zero value generated because the channel is closed and empty.

Note: variable `ok` is assigned the value `false`, not as soon as the channel gets closed, but only when the channel has been drained.



* Exercise: fixing a deadlock

.play -edit src/deadlock_example.go /^//START/,/^//END/

This programme deadlocks. Can you guess why? How would you fix it?

Add sends and receives to fix ideas. Discuss.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: ask them what happens if we write go fmt.Println(<-ch)
: an incorrect approach: go func() { fmt.Println(<-ch) }() then ch <- 42 ...
: ... because <-ch can execute and main terminate before the Println does
: correct: go func() { ch <- 42}() and in main: fmt.Println(<-ch)



* Closing a channel

A freshly initialized channel starts its life in an "open" state.

  ch := make(chan string) // ch is open (until closed)

You can close a channel to inform receivers that no more values will be sent to it:

  close(ch)

Closing a channel is definitive; a closed channel cannot be "re-opened".



* Semantics of close

.image img/close_semantics.svg _ 800

Note that both

- attempting to close a `nil` channel
- attempting to close an already closed channel

cause a panic.



* Do not systematically close channels

One common misconception is that channels _must_ be closed. Not so!

Channels are not resources; closing a channel is not a way to reclaim or clean up resources (memory, etc.).

Channels will get garbage-collected like any other variable once they become unreachable from the rest of the programme.

Only close a channel if the semantics of your programme demand it.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _




* Closing a channel doesn't drain it

Closing a channel neither makes it `nil` and nor drains it!

Closing a channel is akin to a restaurant announcing the end of service.

- After that, the restaurant accepts no new patrons for the day.
- However, the staff doesn't push all the patrons out and lock the door; patrons can finish their meal before paying and leaving.

.image https://rew-online.com/wp-content/uploads/2019/10/restaurantCLOSED.jpg 250 _



* Closing a channel doesn't drain it (cont'd)

Similarly, closing a channel only means that no more values can be sent to it
(at least, not without causing a panic).

Closing a channel doesn't amount to flushing it out.

Some goroutine(s) can still consume the elements left in a closed channel.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/party/birthday.svg 200 _



* Ranging over a channel

Ranging over a channel amounts to iteratively receiving from it:

  for v := range ch {
    // do something with v
  }

Note that, when ranging over a channel, only one iteration variable is available. It takes the successive values sent on the channel until the channel is both closed and empty.

The code above is an exact equivalent to the following:

  for {
    v, ok := <-ch
    if !ok {
      break
    }
    // do something with v
  }

: There's no notion of indexing with channels.



* Ranging over a channel blocks until the channel is closed

Closing a channel to which a for-range loop is applied causes the loop to terminate:

.play -edit src/range_blocks_until_channel_closed.go /^//START/,/^//END/



* Remember: channels are reference types

Operating on a copy `cb` of a channel `ca` affects the same underlying data structure as if you operated on channel `ca` directly.

.play -edit src/channels_are_references.go /^//START/,/^//END/

(If that weren't the case, channel function parameters wouldn't be very useful;
those parameters would instead need to be pointers to channels.)



* Namecheck project: aggregate the results

1. At the top of `main.go`, declare the following `Result` type:

  type Result struct {
    Username  string
    Platform  string
    Valid     bool
    Available bool
    Err       error
  }

2. In `main`, initialize a `chan`Result` named `resultCh`; make sure it's accessible to the child goroutines.

3. In each child goroutine, create a `Result` value and send it to the channel.

4. In `main`, range over that channel and store the results in a slice, then print it.

.image https://go.dev/blog/store/gophers.jpg 150 _

: the channel allows us to serialize access to the slice (local mutable state)
: for anonymous function for wait and close, no need for a wait group? why not?
: could you put the go func() {...}() before the call to wg.Add?



* Channel directions

You can mark a channel as _send-only_ or _receive-only_ by adding the optional `<-` operator on the right or left (respectively) of the `chan` keyword.

This is particularly useful for locally restricting the operations possible on a channel parameter within a function:

  func produce(c chan<- string) {} // c is send-only within produce
  func consume(c <-chan string) {} // c is receive-only within consume

You can pass a bidirectional channel wherever a unidirectional channel is expected.

The compiler disallows

- receiving from a send-only channel, and
- sending to or closing a receive-only channel.



* Channel directions: example

.play -edit src/channel_dir.go /^//START/,/^//END/



* Why use unidirectional channels

Unidirectional channels are great for

- clarifying the role of a channel within a function,
- increasing your confidence in the correctness of your code.

Use them liberally, wherever possible.

However, in cases where a function [[https://talks.golang.org/2012/10things.slide#10][legitimately needs to both send to and receive from a channel]], a bidirectional channel is needed.



* Namecheck project: use unidirectional channels

Review the functions that accept a channel parameter, and determine whether a channel direction could have been specified.

.image https://go.dev/blog/gopher/plush.jpg 400 _



* Channels are FIFO

Channels have first-in/first-out semantics.

.image https://i.imgflip.com/68zdq9.jpg 300 _

Of course, in the face of multiple goroutines sending values to a channel, the order in which values are received is only partial. See [[https://go.dev/play/p/6kpQq0hhlun][this Playground]].




* Select statement

The `select` keyword forms a trifecta with goroutines and channels!

A `select` statement is a multiway concurrent control switch: it allows you to select one of several channel communications (send or receive).

.image https://pbs.twimg.com/media/DDWqkrFUMAAbIyL?format=png&name=large 300 _



* Mechanics of select

  select {
  case v, ok:= <-ch1:
    // do something with v and ok
  case ch2 <- 42:
    // ...
  default:
    // ...
  }

- Each of the "normal" (non-default) cases correspond to a _channel_communication_ (send or receive).
- The first normal case that is non-blocking gets selected and its instructions executed.
- If more than one normal cases are non-blocking, one of them is chosen in a uniform pseudo-random fashion.
- If all normal cases are blocking, the default case (if any) gets selected; otherwise, the `select` statement blocks for as long as its cases remain blocking.
- You can use the `break` keyword within a case to escape from the `select`.



* Event loop: a select nested inside a loop

`select` is often used in conjunction with `for` to form a so-called _event_loop_.

For instance, if you want to continually receive from two (or more) channels,
a simple for-range loop won't do; you'll need to nest a `select` inside a loop:

  for !finished {
    select {
    case  err, ok := <-errorCh:
      finished = true
      continue
    case v, ok := <-resultCh:
      // ...
    }
  }

In that case, prefer a "while" loop to an infinite loop, to avoid the need for labels.



* Namecheck project: fail early

1. Remove the `Err` field from your `Result` type

2. Declare another channel named `errorCh` dedicated to `error` values. Choose the capacity of that channel wisely.

3. Report normal results and errors through the two different channels.

4. In your `main` function, use a for-select to receive from both channels.

5. As soon as you receive one error, print it and terminate the programme.

.image https://go.dev/blog/gopher/plush.jpg 200 _

: smallest channel capacity to prevent goroutine leaks: len(checkers) - 1
: use a bool variable to control the termination of the loop
: mangle the domain name in github.Github's IsAvailable method in order to cause an error



* Canceling goroutines

Spawning goroutines is easy, but making sure they terminate sometimes requires more effort. One common recipe for making a function cancellable consists of

- a `select` statement, and
- a channel of type `<-chan`struct{}`.

  func cancellable(quit <-chan struct{}) {
    for {
        select {
        case <-quit: // becomes non-blocking as soon as channel 'quit' is closed!
          return
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

If function `cancellable` is launched as a goroutine, you can trigger its eventual termination simply by closing the `quit` channel.

: can be used to broadcast a signal to multiple goroutines!
: 'done' is another common name for such a channel



* Exercise: render a function cancellable

.play -edit src/uncancellable.go /^//START/,/^//END/

Function `printInts` never terminates...

1. Modify the program to make `printInts` cancellable.

2. Cancel the goroutine from `main` after one second.

You can do this exercise in the [[https://go.dev/play/p/yWEVD1G7Oix][Go Playground]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* Exercise: render a function cancellable (solution)

The solution is available on the [[https://go.dev/play/p/WXQTEzx8TlY][Go Playground]].

: mention that closing the channel broadcasts a signal to all goroutines that receive from it



* Canceling goroutines with context

The `context` package [[https://vimeo.com/115309491#t=10m][formalizes this idea]] of broadcasting a signal by closing a channel.

It exports an interface type named `Context` that is convenient for terminating goroutines via cancellation and/or timeouts.

`Context`'s cancellation mechanism is based on the same quit-channel trick; the channel is accessible via `Context`'s `Done` method:

  func cancellable(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
          return
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

By convention, the `context.Context` parameter (if any) is always first.



* Exercise: cancelling a goroutine with context.Context

1. Study the documentation of [[https://pkg.go.dev/context/][the `context` package]].

2. Modify the solution to the previous exercise to use a `context.Context` rather than a `quit` channel.

You can do this exercise in the [[https://go.dev/play/p/WXQTEzx8TlY][Go Playground]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: extra exercise: make IsAvailable cancellable



* Exercise: cancelling a goroutine with context.Context (solution)

The solution is available on the [[https://go.dev/play/p/bJeIioSOTIV][Go Playground]].



* Exercise: debug this ping-pong game

1. Open [[https://go.dev/play/p/n7XQ_TdOY4t][this Playground]] (adapted from [[https://www.youtube.com/watch?v=QDDwwePbDtw&t=2m54s][one of Sameer Ajmani's talk]]). The program models a simple ping-pong game.

2. The game ends with a deadlock. Can you see why?

3. Discuss and fix the programme.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: two goroutines exchanging one value over and over
: pointer element to reduce memory footprint
: show that deadlock if you never throw the ball on the table
: one player terminates while the other is left holding the ball
: one possibility: buffer size of 1, but no guarantee that the same player will play twice in a row
: non-blocking send by adding a select statement (with an additional case <-ctx.Done())
: easy solution: referee receive ball from main after cancel()
: https://talks.golang.org/2013/advconc.slide#6



* Exercise: debug this ping-pong game (solution)

The solution is available on the [[https://go.dev/play/p/mollK937Rzo][Go Playground]].



* HTTP server



* Your very first Go server

.play -edit src/server_helloworld.go /^//START/,/^//END/

You can define a HTTP handler as a package-level function. It must take two params:

- a [[https://pkg.go.dev/net/http#ResponseWriter][`http.ResponseWriter`]], an interface for you to compose the HTTP response.
- a pointer to a [[https://pkg.go.dev/net/http#Request][`http.Request`]], which describes the HTTP request to handle.

You can then register your handler for a given route using [[https://pkg.go.dev/net/http#HandleFunc][function `http.HandleFunc`]].

Finally, start the server with [[https://pkg.go.dev/net/http#ListenAndServe][function `http.ListenAndServe`]], which blocks for as long as the server stays up. Don't forget to check the error it returns.

: http.HandleFunc registers the handler on the DefaultServeMux (package-level variable)
: ListenAndServe: it last arg is nil, serves the DefaultServeMux
: important to capture error from http.ListenAndServe, because otherwise fails silently if port collision (e.g. ":80")



* Namecheck project: turn your CLI tool into a Web server

1. Copy `cmd/cli/main.go` to `cmd/server/main.go`. In the latter, rename the `main` function to `handleCheck`.

2. Adjust `handleCheck`'s signature and implementation:

- If the client provided no username via a query param, return a `400` response.
- If an error occurs during an availability check, return a `500` response.
- Otherwise, write (using `fmt.Fprint`) your slice of results in the response.

3. Register your `handleCheck` handler on a route named `/check`.

4. Start your server and hit the `/check` endpoint.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _



* JSON encoding

Use [[https://pkg.go.dev/encoding/json/][the `encoding/json` package]] to encode some Go value to JSON.

_Field_tags_ are used to map the correspondance between the names of a struct's fields (which must be exported!) and the property names of the resulting JSON object:

.code -edit src/json_encoding.go /^//START1/,/^//END1/

Create a `json.Encoder` that writes to the handler's `http.ResponseWriter`,
then pass the value to its `Encode` method:

.play -edit src/json_encoding.go /^//START2/,/^//END2/

: w is the http.ResponseWriter
: don't forget to inspect the resulting error



* Namecheck project: write the results as JSON in the response

1. Instead of writing a Go-specific textual representation of the slice of checkers in the HTTP response, encode the slice to JSON.

2. Add field tags in the declaration of your `Result` struct type so that property names in the resulting JSON be lowercase.

3. Make sure you specify an appropriate content type.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* JSON decoding

Use [[https://pkg.go.dev/encoding/json/][the `encoding/json` package]] to decode some JSON to a Go variable.

.play -edit src/json_encoding.go /^//START3/,/^//END3/

Declaring a local variable whose type is an anynomous struct is pretty common.

Create a `json.Decoder` that reads from the body of the handler's `*http.Request`,
then pass a pointer to the variable to its `Decode` method.

[[https://twitter.com/mholt6][Matt Holt]]'s [[https://mholt.github.io/json-to-go/][JSON-to-Go converter]] is a time-saving tool for JSON decoding.

For more about JSON encoding and decoding, see [[https://go.dev/blog/json][Andrew Gerrand - JSON and Go]].

: don't forget to inspect the resulting error
: curl -v -XPOST -H "Content-Type: application/json" --data '{"name": "Bob"}' http://localhost:8080/admin/new
: no exercise for JSON decoding, but you could retrieve the username to test from the request's JSON body instead of a query param



* Namecheck project: use a third-party package for routing

Let's use [[https://github.com/gorilla/mux][gorilla/mux]], a popular alternative to `net/http` for defining routes.

1. Run the following command within your project to download the dependency:

  go get github.com/gorilla/mux

2. Inspect the changes in your `go.mod` file and notice the creation of a `go.sum` file.

3. Import `gorilla/mux` in your server's `main.go` and redefine your route with it.

4. Run the following command to clean up your `go.mod` file:

  go mod tidy

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 150 _

: we don't really need mux here; nothing fancy; just for practice



* Namecheck project: count of checks per username

Let's keep track (in memory) of how many times each username has been checked.

1. Declare a variable of a suitable type at package level.

2. In `handleCheck`, increment the count associated to the username being checked.

3. Declare an additional `handleStats` server that returns a JSON representation of the variable declared in step 1.

4. Register your `handleStats` handler on a route named `/stats`.

5. Run your server (with `--race`) and exercise it. Do you notice any problem?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* One problem: we've introduced a synchronization bug

The HTTP server provided by `net/http` is concurrent: it handles each incoming request in a separate goroutine.

However, maps are *not* concurrency-safe: carelessly updating a map from multiple goroutines yields unpredictable results!

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Maps are not concurrency-safe

.play -edit src/map_not_concurrency_safe.go /^//START/,/^//END/



* Communicating by sharing memory

Go encourages you to use channels to communicate between goroutines.

However, sharing memory can sometimes be simpler and/or more performant.

Go's standard library provides two main mechanisms for sharing memory:

- [[https://en.wikipedia.org/wiki/Mutual_exclusion][mutual exclusions]], provided by [[https://pkg.go.dev/sync/][the `sync` package]],
- synchronized operations on fixed-sized integers from [[https://pkg.go.dev/sync/atomic/][the `sync/atomic` package]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/party/birthday.svg 200 _

: won't cover the latter because easy to misuse



* Namecheck project: count of checks per username

1. Study the documentation of `sync.Mutex`.

2. Guard reads from and writes to the map with a mutex.

3. Run the server again with the race detector on. Any issue this time?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Conclusion



* What we haven't covered

We're nearing the end of the course.

You've learned a lot, but there is [[https://www.humancoders.com/formations/go-avance][more]]!

.image https://go.dev/blog/store/gophers.jpg 400 _



* Open discussion



* Appendix A: strings



* Bytes, code points, characters

Three distinct concepts are at play with strings in Go: _bytes_, _code_points_, and _characters_.

*Bytes*

- A byte is made up of 8 bits. Duh!

*Code*points*

- Also known as "runes" in the Go world.
- A code point simply corresponds to a place in the Unicode alphabet.

*Characters*

- Also known as "glyphs".
- A character is made up of one or mode code points.

See [[https://go.dev/blog/strings][Rob Pike - Strings, bytes, runes and characters in Go (Golang blog)]]



* Runes

The predeclared `rune` type is a 32-bit integer type that represents a Unicode code point.
Unsurprisingly, its zero value is `0`.

Rune literals are delimited by single quotes. Escape sequences (`'\u00e9'`) are possible.

In UTF-8, a rune is encoded as a sequence of 1 to 4 bytes.

.play -edit src/rune_bytes.go /^//START/,/^//END/

The `rune` type is an alias of type `int32`. The two types are interchangeable.



* Characters

You're used to reading characters on a computer screen, but the Unicode concept of _character_ is harder to grasp than you might think!

Note in particular that

- a character can be made up of more than one code points, and
- a given character can have multiple representations.

For instance, the character `é` can be represented either by

- a single code point named [[https://unicode-table.com/en/00E9/][_Latin_Small_Letter_E_with_Acute_]], or by
- the combination of a [[https://unicode-table.com/en/0065/][_Latin_Small_Letter_E_]] and an [[https://unicode-table.com/en/00B4/][_Acute_Accent_]] (a _combining_code_point_):

.play -edit src/characters.go /^//START/,/^//END/



* The string type: zero value and literals

The `string` type's zero value is simply the empty string.

String literals come in two forms:

*Interpreted*string*literals*

- delimited by double quotes (`"`)
- the most common form
- guaranteed to contain valid UTF-8 (if they do no contain byte-level escapes)

*Raw*string*literals*

- delimited by backticks (```)
- escape sequences are not applied
- can be multiline
- guaranteed to contain valid UTF-8


: string literals always contain UTF-8 text as long as they have no byte-level escapes
: Go source code is UTF-8, so the source code for the string literal is UTF-8 text
: useful for regexp, templates, multiline strings



* The string type's zero value and string literals

.play -edit src/string_literals.go /^//START/,/^//END/



* The string type: under the hood

A string is _not_ stored in memory as a sequence of runes, but as a more compact sequence of bytes that (usually) represent valid UTF-8 text.

More specifically, a string is a two-word immutable data structure made up of

- a pointer to a byte array,
- an integer corresponding to the number of bytes that make up the string.

For instance, the string `"Hello,`World!"` is represented in memory as follows:

.image img/strings_two_words.svg 200 _



* String indexing

`s[i]` returns the `i`-th *byte* (not rune or character!) using 0-based indexing in string `s`.

If `i` is either negative or larger than `len(s)-1`, then `s[i]` causes a _panic_!

Overwriting `s[i]` or taking its address is illegal and will cause a compilation error.

.play -edit src/string_indexing.go /^//START/,/^//END/



: panic is a run-time error
: also substring operator, but similar to slicing operator which we'll see later



* Ranging over a string

A for-range loop decodes one UTF-8-encoded *rune* (not character!) on each iteration:

.play -edit src/string_range.go /^//START/,/^//END/

In the code above, during each iteration of the loop,

- `i` corresponds to the starting position of the current rune (measured in bytes),
- `r` corresponds to the current rune.



* Other operations on strings

As in many other languages, the plus sign is used for string concatenation.

Built-in function `len` returns the number of *bytes* in a string, whereas
function `utf8.RuneCountInString` returns the number of *runes* in a string.

.play -edit src/strings_etc.go /^//START/,/^//END/

Other useful functions for manipulating strings are can be found in packages `unicode/utf8`, `strings`, `strconv`, `fmt`, and `regexp`.


* Appendix B: other import syntaxes



* Blank imports

A blank import uses the blank identifier as package name:

  import _ "github.com/go-sql-driver/mysql"

A blank import makes none of the imported package's members available in the importing package.

The sole reason for using a blank import to import a package is the side effects carried out during [[https://golang.org/ref/spec#Package_initialization][the package's initialization]].

Blank imports are used in the so-called _registration_pattern_ in packages such as `database/sql` and `image`.

Use that pattern if you have to, but do not emulate it in your own code.

: difficult to understand, based on shared global state



* Dot imports

A dot import allows you to access all the exported identifiers of the imported package without the need to qualify them:

.play -edit src/helloworld_dot.go

Dot imports can be convenient in test code, but are otherwise best avoided because

- they pollute the namespace of your source file,
- they obscure the provenance of identifiers.

: similar to Java's static imports



* Relative imports

A relative import relies on the location of the imported package relative to that of the importing package on the disk:

  package main

  import ./twitter

Avoid relative imports like the plague!
