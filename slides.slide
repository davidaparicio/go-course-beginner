Formation Go
01 January 2021

Julien Cretel
jcretel-infosec@protonmail.com
https://jub0bs.com
@jub0bs

* Setup TODO

Make sure you have the latest version of Go (1.16.2) installed by running

  go version

To figure out where your Go distribution is installed, run

  go env GOROOT

Visual Studio Code

[[https://code.visualstudio.com/docs/languages/go][Go extension for Visual Studio Code]]

embarks a number of utilities such as `goimports` and `gofmt`.

- Git


* What to expect from the course TODO

- interaction
- regular breaks
- learn the fundamentals
- emphasis on practice over theory
- long-running project
- gophers
- cooking analogies

: the source code of my solution will be available on GitHub



* Namecheck project

*Objectives*

Write a small CLI tool (and then a server) to check the validity and status of a username on multiple social networks: Twitter, GitHub, etc.

A forcing function for learning Go: we'll introduce new concepts as needed.

*Business* *case*

- Ability to choose a brand name consistent across multiple platforms.
- Username squatting!

.image https://raw.githubusercontent.com/nielsing/yar/master/images/yargopher3.png 150 _

: mention Newsweaver's rebranding to Poppulo, missed claiming @Poppulo on Twitter



* Go's history



* Genesis

Go was created in 2007 at Google (on 20% time) by Robert Griesemer, Rob Pike, and Ken Thompson.

.image three_lads.jpeg



* Genesis

Robert, Rob, and Ken started working on Go [[https://www.youtube.com/watch?v=i0zzChzk8KE&t=545s][largely out of frustration with C++]]: language complexity, long build times, poor support for concurrency, etc.

.image https://imgs.xkcd.com/comics/compiling.png

: Griesemer: V8 JS engine, Hot Spot JVM
: Pike: predecessors to Go (Newsqueak), Plan 9, Unicode
: Thompson: recipient of Turing Award, UNIX (with Dennis Ritchie), Unicode (with Pike), Plan 9 (with Pike)



* History of the Go project

- started in 2007
- open-sourced in 2009
- Go 1.0 released in 2012
- The go compiler (`gc`) becomes self-hosted in 2015.
- ...
- Go 1.16 released in 2021.



* What you should know about Go
: answer some questions you may have straight away
: manage your expectations



* Go's mascot

\... [[https://blog.golang.org/gopher][is a gopher]].

.image https://blog.golang.org/gopher/gopher.png 400 _

: more popular than the language's logo


* Go's logo

\... [[https://blog.golang.org/go-brand][is not the gopher!]]

.image https://blog.golang.org/go-brand/logos.jpg 400 _

: Lapins Crétins vibe!



* Go versus the C programming language

Go is clearly reminiscent of C, but Go is different from C in many notable ways:

- strong typing
- fast compilation
- garbage collection
- memory safety
- full Unicode support
- concurrency primitives
- sensible `switch` behavior
- first-class functions
- multiple function results
- principled error handling

: memory safety: pointers, but no pointer arithmetic)
: mention heap-overflow vuln discovered in curl



* Go is object-oriented... with a twist!

The ability to define custom types (methods on them) promote _abstraction_.

Go's interfaces (and, soon, generics) enable _polymorphism_.

Go's packages enable _encapsulation_.

Go has no concept of _inheritance_, but facilitates _composition_ instead.

.image https://habrastorage.org/getpro/habr/post_images/eb1/923/9cc/eb19239cc91d38445932da1ade5a5e7d.png 300 _



* Object orientation without inheritance

Can a language without inheritance be described as object-oriented? Sure!

.image https://i.redd.it/2dpp8t6mk7641.png 200 _

See also

- [[https://www.infoworld.com/article/2073649/why-extends-is-evil.html][Allen Holub - Why extends is evil (InfoWorld 2003)]]
- [[https://www.quora.com/What-does-Alan-Kay-think-about-inheritance-in-object-oriented-programming][What does Alan Kay think about inheritance in object-oriented programming? (Quora)]]
- [[https://golang.org/doc/faq#Is_Go_an_object-oriented_language][Is Go an object-oriented language? (golang.org FAQ)]]

: James Gosling (Java): "I'd leave classes out."
: No concept of inheritance in Alan Kay's Simula... a Web of objects



* Functions are first-class citizens

In Go, functions can

- take other functions as parameters,
- return functions as results,
- be stored in variables,
- be stored in struct fields.

However, despite having anonymous functions, Go has no concise "lambda" notation.



* Go development pays well

See the results of the [[https://insights.stackoverflow.com/survey/2020#technology-what-languages-are-associated-with-the-highest-salaries-worldwide-global][Stack Overflow's 2020 Developer Survey]].

.image https://blog.golang.org/gophergala/fancygopher.jpg 400 _



* First steps in Go



* The Go Playground

The Go Playground ([[https://play.golang.org][play.golang.org]]) is a Web app that lets you write and run
a small Go program from your browser. Features include:

- permalinks (convenient for sharing code snippets)
- automatic formating
- automatic imports (from the core library)
- basic static analysis with `go`vet`
- [[https://play.golang.org/p/lEDjyvhttIB][limited support for modules and multiple packages]]
- downloading of the program source (^S or ⌘+S)

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/computer/gamer.svg 150 _

: It's a good place to experiment and fix ideas about the language and its core library.



* Some limitations of the Go Playground

As the name indicates, the Playground isn't meant for anything extensive.

Limitations include:

- single executable
- no networking allowed
- no command-line arguments
- poor support for third-party packages

.image https://miro.medium.com/max/4800/1*OxWM0qyTBnb6WfSEw-T9sg.jpeg 200 _

: In this course, we'll only use the Playground to solve simple exercises.
: An alternative with more features, incl. syntax highlighting: https://goplay.space/



* Hello, World!

.play -edit helloworld.go

You can play with this program [[https://play.golang.org/p/7vin2BK8_A6][in the Go Playground]].

.image https://blog.golang.org/gopher/plush.jpg 300 _

: we can already draw some observations from this piece of code



* Observations about our Hello-World program

.play -edit helloworld.go

All source file starts with a _package_clause_,
i.e. the `package` keyword followed by the package's name: `package`main`

A package named `main` produces an executable program (as opposed to a library).

Imports specify _package_paths_ in double quotes.



* More observations about our Hello-World program

.play -edit helloworld.go

The `main` function of a `main` package is the program's entrypoint;
it takes no parameters and returns no results.

Go's grammar uses semicolons as statement terminators, but those semicolons do not appear in the source; [[https://golang.org/doc/effective_go#semicolons][they're added by the compiler]]. As a result, you're not free to break lines wherever you want.

The formater uses tabs (not spaces) for indentation.

: cmd args: os.Args
: guillemets doubles



* Namecheck project: a starting point

1. Create a folder named `namecheck`.
2. Create a file named `main.go` file at the root of the `namecheck` folder.

  namecheck
  └── main.go

3. Write a "Hello World" programme in main.go
4. Compile it by running the following command, which creates an executable
(named `main` on *nix systems or `main.exe` on Windows):

  go build main.go

5. Execute the executable.



* Compiling and executing a program in one fell swoop

If you just want to run the program without keeping the executable, run

  go run main.go

which is roughly equivalent (on *nix systems) to

  go build main.go
  ./main
  rm main

Don't use `go`run` in production, though.

.image https://miro.medium.com/max/4800/1*-bo7H329eM0O1eL_ASBVOA.jpeg 200 _



* Cross-compilation

By default, the compiler will produce an executable targeting your operating system and architecture.

However, you can cross-compile to a different operating system and architecture using the `GOOS` and `GOARCH` environment variables:

  GOOS=windows GOARCH=amd64 go build main.go

.image https://blog.golang.org/store/gophers.jpg 300 _



* Keywords

  break           default           func          interface       select
  case            defer             go            map             struct
  chan            else              goto          package         switch
  const           fallthrough       if            range           type
  continue        for               import        return          var

Discuss. Which keywords are new to you? Which one(s) seem to be missing?

.image https://blog.golang.org/5years/gophers5th.jpg 300 _



* Keywords

*chan* and *select* are related to _channels_, which are typed conduits used for communication between goroutines, Go's lightweight threads.

*defer* allows you to unconditionnaly execute some code at the end of a function call.

*fallthrough* can be used to override `switch` cases' normal behavior, which consists in automatically breaking at the end (without the need for an explicit `break` statement).

*go* is used to spawn goroutines.

*goto* is present in the language but best avoided for most projects.

*range*, used in conjunction with `for`, allows you to iterate over various data structures.

No `while` keyword in Go! All loops are done with the `for` keyword.

: defer: a cleaner alternative to try-catch-finally



* Predeclared names

Go also comes with several predeclared names accessible from anywhere in your code:

*Constants*

  false true nil iota

*Built-in*types*

  bool int rune uint byte float64 string
  struct map chan
  interface error

*Built-in*functions*

  make    len     cap     new
  append  copy    delete
  panic   recover

(None of those lists is exhaustive.)



* Comments

End-of-line comments start with a double slash and extend to the end of the line:

  var foo = "foo" // this is a comment

Multiline comments are delimited by `/*` and `*/` and do not nest:

  /*
    this is
    a multiline comment
  */

The documentation of a package is written as comments in the package's source file(s).

: won't talk too much about documentation in this first course



* Packages



* Package path and package name

A package is identified by its _path_, which must be globally unique.

  fmt
  net/http
  github.com/jub0bs/missilelauncher

The _default_name_ of a package typically corresponds to the last component of its path:

  fmt
  http
  missilelauncher

Compiling a package whose default name is `main` produces an executable
(and a library otherwise).

: first two are part of core library; third one is third-party
: "usually": the exception is for a package whose enclosing folder doesn't mach the package name; best avoided
: also, with versions of modules after v1, it's the second last path component: "rsc.io/quote/v3" => quote



* Package: the unit of compilation

A package is composed of one or more source files that are compiled together.

All of a package's source files (and no other!) must

- be in the same folder (e.g. foo),
- start with the same package clause (e.g. `package`foo`).

Each source file of a package must import the packages it consumes.

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 200 _

: imports are not "shared" across source files.


* Exercise: a closer look at the fmt package with go list

`go`list` allows you to ask questions about packages at the command line.

Run the following command in your shell to list the production source files that make up the `fmt` package:

  go list -f '{{ join .GoFiles "\n" }}' fmt

Run the following command in your shell to determine where the `fmt` package lives
on your machine, and check the contents of the folder:

  go list -f '{{ .Dir }}' fmt

Note that the folder also contains test files.



* Exercise: a closer look at the fmt package TODO

Check out the online documentation of the 

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _


* Package: the unit of encapsulation

In Go, the package (not the type!) is the unit of encapsulation.

There are only two access levels: a package-level identifier is either

- _exported_ (i.e. accessible from another package), or
- _unexported_ (i.e. only accessible within its own package).

Whether a package-level identifier is exported depends on the case of its first letter:

  package foo

  var Bar = "Bar"                   // starts with an uppercase B:   exported by package foo
  type Baz struct { /* ... */ }     // starts with an uppercase B:   exported by package foo
  const qux = 42                    // starts with a lowercase q:  unexported by package foo
  func quux() { /* ... */ }         // starts with a lowercase q:  unexported by package foo



* Importing packages

A package can be imported in different ways:

- normal import
- named import
- blank import
- dot import
- relative import

We won't mention relative imports again because they are best avoided.

.image https://blog.golang.org/store/gophers.jpg 200 _



* Normal imports

This is the most common form of import.

You used a normal import in your Hello-World program:

.play -edit helloworld.go

To access an identifier exported by a different package (`fmt`, here), you must qualify it using the default package name as prefix (`fmt.Println`).

Importing a package without consuming it causes a compilation error!



* Named imports

Named imports allows you to use the imported package under a different name.

A named import is handy when you perceive the default package name as inappropriate:

  import ml "github.com/jub0bs/missilelauncher"

But named imports are especially useful

- when your code imports multiple packages whose default names collide:

  import "math/rand"
  import crand "crypto/rand"

- when your code uses multiple major versions of a _module_ within the same file:

  import "github.com/jub0bs/missilelauncher"
  import mlv2 "github.com/jub0bs/missilelauncher/v2"

: more on this later



* Blank imports TODO

Blank imports are sometimes useful; see the `database/sql` and `image` packages.

To import a package solely for its side-effects (initialization), use the blank identifier as explicit package name:

https://golang.org/ref/spec#Package_initialization


* Dot imports

A dot import allows you to access all the exported identifiers of the imported package without the need to qualify them:

.play -edit helloworld_dot.go

Dot imports can be convenient in test code, but are otherwise best avoided because

- they pollute the namespace of your source file,
- they obscure the provenance of identifiers.

: similar to Java's static imports


* Functions



* Calling a function

To call a function, specify *all* the required arguments by *position* within parentheses
after the name of the function, using commas as delimiters:

.play -edit function_call.go /^//START/,/^//END/

[[https://docs.python.org/3/glossary.html#term-argument][Unlike Python]] (and others), Go doesn't allow you

- to specify arguments by keyword or name,
- to specify a default value for a parameter of your function.


* Evaluation strategy: call by value

Go's [[https://en.wikipedia.org/wiki/Evaluation_strategy][evaluation strategy]] is [[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value][_call_by_value_]], without any exception.

Each argument expression is eagerly evaluated, and the result is bound to the corresponding parameter variable within the function.

In brief, functions only operate on *copies* of their arguments:

.play -edit call_by_value.go /^//START/,/^//END/



* Evaluation strategy: call by sharing?

However, because some types (strings, slices, maps, channels, functions)
are composed of a pointer to some hidden data structure in memory.

[[https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing][_Call_by_sharing_]] is perhaps a more appropriate term than _call_by_value_ to describe
what happens when values of such types are passed to a function.

.play -edit call_by_sharing.go /^//START/,/^//END/


* Function declaration

Here is a simple example of a named function:

  func CountWords(s string) int {
    return len(strings.Fields(s))
  }

A function can return multiple results (whose types must be specified within parens):

  func CountWordsInFile(path string) (int, error) {
    var count int
    // ...
    return count, nil
  }

Multiple function results are key to error reporting in Go!

There's no function overloading in Go: no two functions within the same scope
can have the same name but different signatures.



* Namecheck project: validation of Twitter usernames

A prospective username is valid on Twitter if it

- does not contain any case-insensitive match of "twitter" (e.g. "TwItTEr"),
- contains between 4 and 15 alphanumeric or underscore characters.

Write a function that implements the first rule:

  func containsNoIllegalPattern(username string) bool {
    // returns true if username does not contain "twitter"
    // (and all case variations, incl. "TwItTEr", etc.)
  }

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: hint: keep it simple


* Named results

You can name (either all or none of) your function's results:

  func CountWordsInFile(path string) (count int, err error) {
    // ...
    return
  }

Note the "naked" return: often, what to return is implied from the list of named results.

The code above is roughly equivalent to the following:

  func CountWordsInFile(path string) (int, error) {
    var count int
    var err error
    // ... 
    return count, err
  }

Named results can be useful for documenting the results' roles and simplifying some implementations, but use them sparingly.




* Variadic functions

You can declare a function that accepts an arbitrary number of identically typed parameters:

.play -edit function_variadic.go /^//START/,/^//END/


The variadic argument (`rest`, here) is a _slice_ and must be the last to appear in the parameter list.

You've already used a variadic function... Which one? Check it its signature in the doc.



* Type factorization in parameter and result lists

The type of identically typed consecutive parameters can be factored out:

  func Split(s, sep string) []string { // see the strings package

Similarly, the type of identically typed consecutive results can be factored out:

.play -edit function_factored_type_in_result_list.go /^//START/,/^//END/



* Recursion

Go supports recursion: a function can call itself (directly or indirectly).

.play -edit recursion.go /^//START/,/^//END/

Recursion is useful for traversing recursive data structures, such as trees.

Because call stacks grow and shrink as needed, unless you have a bug somewhere,
you're less likely to cause a stack overflow by recursing than in other languages.



* Functions are first-class values

Functions can [[https://golang.org/pkg/net/http/#HandleFunc][take other functions as parameters]], [[https://play.golang.org/p/LfT4e0lPmNV][return functions as results]],
be stored in variables, etc.

.play -edit function_nil.go /^//START/,/^//END/

Each function has a type.

Function types are *not* comparable.

The zero value of function types is `nil`.

Be careful: calling a `nil` function causes a panic!

: function-typed results can also be useful for cleaning up; see Mat Ryer's talk



* Anonymous functions and lexical closures

Go supports anonymous functions but lacks a concise "lambda" notation:

  incr := func (i int) int { return i + 1 }

An anonymous functions can _capture_ variables that are accessible to it:

.play -edit function_closure.go /^//START/,/^//END/

Anonymous functions are often conveniently used in conjunction with the `go` keyword to launch goroutines.



* And one more thing: defer

*defer* allows you to unconditionnaly execute some code at the end of a function call.

It's particularly useful for cleaning up, reclaiming resources, etc.

More about `defer` later in the course!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-balloon.svg 300 _



* Namecheck project: validation of Twitter usernames

Use the `regexp` package to write a function that implements the second rule:

  func looksGood(username string) (bool, error) {
    // returns true iff username matches regexp ^[0-9A-Z_a-z]{4,15}$ and some (?) error
  }

Does the function's signature satisfy you?

What signature would you prefer? Why?

How would you achieve that?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/adventure/hiking.svg 200 _

: transition: we need to learn about error handling in Go, and for that we need to learn about if and switch statements



* If and switch statements



* If statements

The condition must be of type `bool` and needs not be enclosed in parens.
However, braces around the body are mandatory.

.play -edit if_simple.go /^//START/,/^//END/

A short-variable-declaration statement can precede the condition:

.play -edit if_short_variable_decl.go /^//START/,/^//END/

The scope of such variables is restricted to the if(-else) statement.

: mandatory braces: no dangling-else problem like in C, JS, etc.
: short-var-decl: useful for error handling



* If-else statements

Braces around the `else` body are also mandatory.

.play -edit if_else.go /^//START/,/^//END/

`else` is one of the least popular keyword in Go!

If-else chains are considered non-idiomatic, and can often be advantageously replaced by a _tagless_ `switch`.



* Switch statement

The switch expression (whose type must be comparable) is evaluated once.

The case expressions (not necessarily constants), are evaluated left-to-right and top-to-bottom and tested for equality against the case expression until a match is found.

The first match's case gets executed. Otherwise, the default case (if any) gets executed.

.play -edit switch.go /^//START/,/^//END/

No need for the `break` keyword at the end of cases! Use `fallthrough`, if needed.

: A short-variable-declaration statement can precede the switch condition.
: The default clause can occur at any place among the the normal cases.



* Tagless switch

You can omit the switch expression, which is equivalent to using `true`:

.play -edit tagless_switch.go /^//START/,/^//END/

This form of `switch` statement is preferred to a long if-else chain.



* Type switch

A _type_switch_ allows you to switch on an interface value and change the logic on the basis of the concrete type stored inside it:

.play -edit type_switch.go /^//START/,/^//END/

Use type switches sparingly. More on that when we cover interfaces.



* Error handling



* Errors are values

There are no exceptions in Go! Anticipated failures are reported as [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=16m13s]["normal" values]] of the built-in interface type `error`.

A function that can fail returns an additional `error` result (the last one, by convention):

  func Get(url string) (resp *Response, err error) // example from the http package

A non-nil `error` result indicates that the function failed; hence this error-check idiom:

  resp, err := http.Get("https://jub0bs.com")
  if err != nil {
    fmt.Fprintln(os.Stderr, "failure to GET jub0bs.com:", err)
    return
  }
  // do something interesting with resp

: mention that a boolean result can be used if the function can fails for a single unambiguous cause

: compare with other languages
:   C: error codes, in-band, no multiple return values; write more to a volatile location in memory
:   Java/Scala: exceptions, or Option, Either or some Result type (more functional)



* Don't ignore errors 

Few errors should be ignored. You can deviate from this general rule in some cases,
particularly with `fmt.Println` and friends.

You simply cannot assume success of a fallible function and the soundness
of its other results (if any) if you don't check the error it returns!

Error handling in Go is very explicit; it can be perceived as repetitive and tedious,
but that's actually [[https://changelog.com/gotime/16#transcript-68][a strength of the language]]. You will grow to love it!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/heart-hug.svg 200 _

: for some functions, a non-nil error may indicate only a partial failure (e.g. Read)



* Line of sight

Always deal with the failure case first.

Don't do this:

  v, err := fallibleFunction()
  if err == nil {
    // success; do something interesting with v
  } else {
    // failure: handle error
  }

Do this instead:

  v, err := fallibleFunction()
  if err != nil {
    // failure: handle error and perhaps return early
  }
  // success; do something interesting with v



* Line of sight (cont'd)

This idiom greatly contributes to the readability of Go code.

By avoiding the `else` keyword and eliminating error cases as they arise,

- you [[https://golang.org/doc/effective_go#if][keep the "happy path" on the left]],
- you [[https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting][minimize nesting]] (your code reads like columns of a broadsheet newspaper),
- you [[https://talks.golang.org/2013/bestpractices.slide#3][reduce the cognitive load]] required to read and understand your code.

See also [[https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88][Mat Ryer's blog post on this topic]].

.image https://upload.wikimedia.org/wikipedia/commons/4/44/New_York_Times_1914-07-29.jpg 200 _



* Different ways of handling errors

- bubble it up to the caller
- log it or print it to stderr
- compare it to some sentinel error value (e.g. `io.EOF`)
- inspect its underlying cause
- wrap it in a higher-level error

Which approach to favor is highly context-dependent.

However you choose to handle an error, handle it only once!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _

: bubble it up: you lose context
: I've seen people logging the error at every stage of the call stack! => duplicate entries in logs, confusing



* Creating error values

`errors.New` allows you to create a simple error value:

	err := errors.New("namecheck: failure to check availability of 'jub0bs' on Twitter")

\... but `fmt.Errorf` is more flexible:

	username := "jub0bs"
	platform := "Twitter"
	err := fmt.Errorf("namecheck: failure to check availability of %q on %s", username, platform)

By convention, error messages

- are of the form "<package-name>: <human-readable-error-message>",
- should be lowercase,
- should not contain linebreaks.

You can also create your own error types (i.e. types that satisfy the `error` interface).

: more on custom error types later



* Panic

A panic is a runtime event that indicates a truly exceptional and unrecoverable failure.

It can be triggered by a runtime error (such as calling a `nil` function) or some direct or indirect call to built-in function `panic`.

A panic stops the programme's normal execution, runs deferred function calls as it unwinds the stack, prints an error message and goroutine traces, and exit the program with a non-zero status:

.play -edit panic.go /^//START/,/^//END/

Panics can (but rarely, if ever, should) be [[https://blog.golang.org/defer-panic-and-recover][_recovered_]].

: recover: if you consume a third-party package that panic willy-nilly



* Don't panic willy-nilly in your code

Do not panic in your functions for anticipated and recoverable failures:

- a file couldn't be opened
- a HTTP request failed
- the connection to the database dropped

In idiomatic Go, such failures are instead reported to the caller as `error` values.

However, panicking during the initialization of your package is legitimate
if some programming error renders the package unusable.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _



* Namecheck project: fail early if the regexp is unusable

Use what you've learned to change the signature of your `looksGood` function to

  func looksGood(username string) bool {
    // returns true iff username matches regexp ^[0-9A-Z_a-z]{4,15}$
  }

Fail early if the regular expression doesn't compile.

.image https://i.redd.it/48emz1dvfz441.png 200 _



* Namecheck project: validation of Twitter usernames

Write a function named `IsValid` that returns true if its parameter is a valid username on Twitter, and false otherwise:

  func IsValid(username string) bool {
    // returns true if username is valid on Twitter
  }

Write a few "tests" for `IsValid` in the `main` function.

All the code we've written in `main.go` so far is specific to Twitter, which is a bit messy.

It would be preferable to create a dedicated library package for each of the supported platforms (Twitter, GitHub, etc.)

Let's learn how to create a library package and import it in our `main` package.



* Namecheck project: validation of GitHub usernames

Create a `github` package (you can copy the `twitter` package to get started quickly):

  namecheck
  ├── github
  │   ├── github.go
  │   └── github_test.go
  ├── go.mod
  ├── main.go
  └── twitter
      ├── twitter.go
      └── twitter_test.go

A prospective username is valid on GitHub if it

- contains between 3 and 39 alphanumeric or hyphen characters,
- doesn't start or end (or both) with a hyphen,
- doesn't contain two hyphens in a row.



* Namecheck project: validation of GitHub usernames

Write a function named `IsValid` that returns true if its parameter is a valid username on GitHub, and false otherwise:

  func IsValid(username string) bool {
    // returns true if username is valid on GitHub
  }

Adapt the test cases in `github_test.go` and make them pass.

Keep writing test cases until you're satisfied with their code coverage.

.image https://blog.golang.org/store/gophers.jpg 300 _



* Concurrency



* Concurrency

Concurrency is the art of composing a programme in terms of independently executing computations.

Go has native support (i.e. in the language and runtime) for concurrency.

Go's concurrency model is arguably one of the language's strengths, but can be difficult to learn and master.

: hence being relegated to the end of many learning resources



* Concurrency

Disclaimer: many cooking metaphors ahead!

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 400 _



* Concurrency is not parallelism

*Concurrency*

- the art of structuring a programme in terms of independenly executing computations
- a property of the programme's code

*Parallelism*

- the simultaneous execution of multiple things on multiple cores
- a property of the running program



* Parallelism is not the goal of concurrency

Concurrency _enables_ parallelism, but parallelism isn't the goal.

It's valuable to write concurrent code even while being ignorant of whether that code will eventually run in parallel.

And if good concurrent code does run in parallel, we should get graceful performance improvement for free as the number of cores increase.

See also

- [[https://www.youtube.com/watch?v=oV9rvDllKEg][Rob Pike - Concurrency is not Parallelism (2012)]].
- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=3m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]



* Go's concurrency model

Largely inspired by [[https://dl.acm.org/doi/10.1145/359576.359585][Tony Hoare's  _Communicating_Sequential_Processes_ (1978)]]

Two fundamental mechanisms:

- goroutines: lightweight threads
- channels: typed pipes used to communicate and synchronize between goroutines

.image busy_gophers.jpeg 300 _



* Goroutines

A goroutine is a concurrent function execution.

It can be thought of as a very lightweight thread: it's common for programmes to have 1000s of goroutines, even on a single core.

The `main` function is itself a goroutine that is created when the programme starts.

Each goroutine gets its own stack, which starts small and grows/shrinks as required.

.image https://blog.golang.org/store/gophers.jpg 400 _



* Goroutines execute in the same address space

For example, a goroutine can pass a pointer to another goroutine, and the latter can dereference that pointer without causing an access violation.

[[https://golang.org/doc/effective_go.html#goroutines][The onus is on you to be careful]] in order to avoid data races!

(A [[https://en.wikipedia.org/wiki/Race_condition#Data_race][data race]] occurs when multiple goroutines write to and read from the same memory location at the same time.)



* The Go scheduler

The _Go_scheduler_ is a part of the Go runtime that automatically multiplexes goroutines onto operating-systems threads and manages their scheduling for us.

It continually observes the run-time behavior of goroutines and decides to suspends them when they block and then resumes them when they become unblocked.

No need for you to think about it; just picture the Go scheduler and goroutines as a chef and his/her kitchen assistants.

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 250 _



* The go keyword

The `go` keyword spawns a new goroutine: it causes the function call that follows it to get executed "in the background".

  go grindCoffeeBeans()
  go frothMilk()

`go` statements return _immediately_.

The result(s) of the function call to which the `go` keyword is applied are lost.

Launching an anonymous function as a goroutine is common:

  go func() {
    fmt.Println("Grinding coffee beans...")
  }()

: just don't forget to invoke it!
: terminology: spawning goroutine vs. spawned goroutine



* Goroutines vs. Unix processes

It's useful to compare goroutines to Unix processes...

The `go` keyword is reminiscent of the ampersand operator (`&`) in Unix shells.

  #!/usr/bin/env sh

  grindCoffeeBeans &
  frothMilk &

However, unlike a Unix process, a goroutine has no concept of an ID (see why [[https://talks.golang.org/2014/go4gophers.slide#38][here]]).

Therefore, a goroutine cannot readily be _killed_.



* The golden rule

Before spawning a new goroutine, you must understand exactly under what conditions it will terminate.

If you're careless and spawn goroutines willy-nilly, you expose yourself to correctness and performance bugs (_goroutine_leaks_).

.image this_is_fine.png 300 _



* Exercise: concurrent coffee making

Write two functions, `grindCoffeeBeans` and `frothMilk`, that

- take no parameters and return no results,
- simply write an informative message to stdout.

Call them concurrently in the `main` function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _

: Q: Which message will be printed first? We can't tell. Up to the scheduler.



* Exercise: concurrent coffee making (first attempt)

.play -edit goroutines_without_waitgroup.go /^//START/,/^//END/

Does the programme behave as you expected? Why or why not?



* main does not wait!

Nothing gets written to stdout because

- the two `go` statements _immediately_ transfer control back to `main`, and
- `main` terminates _before_ your two goroutines themselves terminate!

We need a way to tell `main` to "wait" until the two goroutines terminate.

Any ideas?



* Exercise: concurrent coffee making (with sleep)

Sleep a bit at the end?

.play -edit goroutines_with_sleep.go /^//START/,/^//END/

However, this solution is not entirely satisfactory. Why?

: inefficient at best, nondeterministic at worst



* Sleeping is not the answer

How long should the sleep be, exactly? Impossible to know in advance.

- Wait too little: `main` terminates too quickly for all the other goroutines to terminate.
- Wait too long: `main` ends up needlessly spinning and wasting time.

.image https://drek4537l1klr.cloudfront.net/youngman/Figures/f0255-01.jpg 200 _

Sleeping is simply not a reliable and efficient way of coordinating goroutines!

We need another mechanism...

: there are legitimate use cases for `time.Sleep` in a Go programme, but...



* Wait groups

The core library's [[https://golang.org/pkg/sync/#WaitGroup][`sync` package]] provides a mechanism for _orchestrating_ goroutines: wait groups.

Wait groups are particularly useful when the number of goroutines to spawn is not known in advance.

: e.g. if you're spawning a goroutine for each line of a file that you're reading, or for each element received from a channel



* Declaring a wait group

Because the zero value of `sync.WaitGroup` is readily usable, you can simply write

  var wg sync.WaitGroup

Alternatively, if you want a `*sync.WaitGroup`, write

  wg := new(sync.WaitGroup)     // equivalent to &sync.WaitGroup{}



* Operations on a wait group

A wait group is little more than a glorified counter with _concurrency-safe_ operations.

- `wg.Add(n)` increments the counter by n (>0).
- `wg.Done()` decrements the counter by 1. It's equivalent to `wg.Add(-1)`.
- `wg.Wait()` blocks until the counter goes back to 0; it acts as a [[https://en.wikipedia.org/wiki/Barrier_(computer_science)][_barrier_]].



* How to use a wait group

Call `wg.Add(1)` _just_before_ spawning a goroutine.

Call `wg.Done()` _at_the_very_end_ of each spawned goroutine (use `defer`!).

Call `wg.Wait()` in the spawning goroutine to wait for all spawned goroutines to terminate.



* Exercise: concurrent coffee making (using a wait group)

Use a wait group to make `main` wait until both `grindCoffeeBeans` and `frothMilk` have terminated before `main` itself can terminate.

Tip: you can apply the `go` keyword to an anonymous function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _



* Exercise: concurrent coffee making (using a wait group)

(implementations of `grindCoffeeBeans` and `frothMilk` are as before)

.play -edit goroutines_with_waitgroup.go /^//START/,/^//END/

: don't forget the pair of parens at the end of each function literal!
: What happens if I remove a wg.Done()? deadlock
: What happens if I remove a wg.Add(1)? only one of the two goroutine will likely have time execute



* How not to misuse wait groups

Calls to `wg.Add` must take place in the spawning goroutine, _not_ within the spawned goroutine.

The call to `wg.Wait` must happen _after_ all calls to `wg.Add` (otherwise: data race).

If a function needs a wait group declared elsewhere, pass a pointer to it (`*sync.WaitGroup`) as an argument to the function.

.image https://blog.golang.org/gopher/plush.jpg 300 _

: if wg.Add concurrent with wg.Wait, data race: https://play.golang.org/p/PPlY-M7yfYh



* Closures running as goroutines: spot the bug

Can you spot the bug in the following programme?

.play -edit goroutine_func_quiz.go /^//START/,/^//END/

: ask them first how they expect the programme to behave
: sometimes prints 10, not 9! because loop variable goes beyond bound before loop can end



* Closures running as goroutines: explanation

There is a _data_race_: a variable is being read and updated by different goroutines at the same time!

More specifically, the goroutines spawned by `printTenIntsConcurrently` _capture_ and read loop variable `i` as it's being updated by the loop.

.play -edit goroutine_func_answer.go /^//START/,/^//END/

Consequently, the programme is undeterministic: the results are unpredictable.



* Detecting the data race

We've identified the data race by inspection, but some static- and dynamic-analysis tools can help.

*go*vet*

This subcommand analyzes the code and can detect issues that the compiler does not.

Try running `go` `vet` on the programme.

*race*detector*

The Go CLI provides a [[https://blog.golang.org/race-detector][race detector]], i.e. a tool that can detect data races during execution.

Try running the programme with the `-race` flag.

Caution: the race detector is [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][not guaranteed to catch all data races]].



* Fixing the data race

Pass the value of the loop variable as an argument to the anonymous function.

That way, by virtue of Go's call-by-value evaluation strategy, the function only has access to a copy of the loop variable.

.play -edit goroutine_func_arg.go /^//START/,/^//END/



* Fixing the data race

An alternative solution consists in redeclaring the variable inside the loop.

.play -edit goroutine_func_redecl.go /^//START/,/^//END/

See also the [[https://golang.org/doc/faq#closures_and_goroutines][Golang FAQ about this]].



* Be careful when running closures as goroutines

When running a closure as a goroutine, it's very easy to inadvertently capture variables, which may cause data races.

Defining a dedicated named function can help:

.play -edit goroutine_func_standalone.go /^//START/,/^//END/



* Namecheck project: check concurrently

Rather than checking the username on each platform sequentially, do so concurrently.

Does the user experience improve?



* Namecheck project: aggregate the results (how?)

What if, instead of simply printing the results, we wanted to somehow aggregated them?

Remember: the result(s) of the function call to which the `go` keyword is applied are lost.

We need a way to communicate between goroutines...



* Channels



* Don't communicate by sharing memory; share memory by communicating.

Because goroutines all execute in the same address space, we need to be careful about data access from multiple goroutines.

We could use locks to synchronize goroutine access to the shared memory...

\... but Go encourages a different approach, in which shared values are passed around on _channels_.

See also

- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=2m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]
- [[https://golang.org/doc/effective_go#sharing][Effective Go (Share by communicating)]]



* Channels are typed

Channels are typed conduits that allow goroutines to synchronize and exchange information.

The element type of a channel is arbitrary.

A channel whose element type is `T` has type `chan`T`.

  var ch chan string // channel of strings

: channels only exist within the confines of your programme; they can't be used to communicate between different processes, be they written in Go.



* Popular naming choices for channels

"c" or "ch", on its own or as a suffix (with or without camelcase):

  var c chan int
  var ch chan string
  var errc chan error
  var taskCh chan Task

Plural of the channel's element type:

  var tasks chan Task

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Channels are first-class values

You can pass a channel to a function:

  func Aggregate(results chan Result) Result { /* ... */ }

You can return a channel from a function:

  func Generate(upTo int) chan int { /* ... */ }

You can store a channel in a struct type:

  type Request struct {
      fn func() int  // The operation to perform.
      c  chan bool    // The channel to return the result.
  }

Channels are comparable.




* Initializing a channel

Channels are reference types; their zero value is `nil`.

To initialize a channel, use built-in function `make` with two arguments:

- the first argument corresponds to the type of the channel;
- the second argument is an (optional) `int` corresponding to the channel's desired (non-negative) _capacity_.

  c1 := make(chan string) // equivalent to make(chan string, 0)
  c2 := make(chan string, c)

A channel's capacity cannot be changed after initialization.

A freshly initialized channel starts its life in an "open" state, but can later be _closed_.

: The specified capacity (if any) must be non-negative; otherwise, you'll get a compilation error or, worse, a panic.



* Channel capacity

A channel's capacity corresponds to the size of its _buffer_.

Choosing it wisely is important, as it usually affects the correctness and/or the performance of your programme.

Built-in function `cap` can be used to query a channel's capacity:

  c := make(chan string, 20)
  fmt.Println(cap(c)) // 20

Some terminology:

- A channel of zero capacity is called an _unbuffered_channel_.
- A channel of positive capacity is called a _buffered_channel_.

: The number of elements queued in a channel's buffer can also be queried via built-in function `len`, but is rarely useful. Why?
: if more than one goroutine interact with the channel, len(ch) is stale as soon as queried
: increasing buffer size may help reduce pressure on the Go scheduler



* A kitchen serving-hatch as a metaphor

Think of goroutines as cooks and waiters on either side of a serving hatch,
which represents a channel.

The channel's capacity corresponds to the number of plates that can fit
on the serving hatch's platform at any one time.

.image https://josephdmcnamee.files.wordpress.com/2012/01/serving-hatch1.jpg 350 _

: what does a channel of capacity 0 correspond to?
: the analogy is imperfect because channels are FIFO and waiters don't necessarily pick up plates in the order in which they arrived



* Operations on a channel

Channels support the following operations:

- _sending_ a value to a channel,
- _receiving_ a value from a channel,
- _closing_ a channel (that hasn't been closed yet).

You can also _range_ over a channel, which consists in continually receiving values from it until the channel gets closed.

All those operations are *concurrency-safe*.

: _Channel_communications_ is a general term for describing both channel sends and receives.
: we'll see why closing a channel is useful soon



* Sending to a channel

The syntax of a _channel_send_ consists in the name of the channel in question
followed by a left-pointing arrow (`<-`) followed by the value to send.

  ch := make(chan string)
  // ...
  v := "superimportant message"
  ch <- v

The `gofmt` tool will adds a space on either side of the arrow; don't fight it.

A channel send is a statement, not an expression.



* Semantics of a channel send

.image send_semantics.svg 400 _

Note: buffered channels accept a limited number of values without a corresponding receive for those values.


* Receiving from a channel

The syntax of a _channel_receive_ consists in a left-pointing arrow (`<-`) followed by the channel in question.

  ch := make(chan string)
  // ...
  <-ch

The `gofmt` tool removes any whitespace between the arrow the channel; don't fight it.

A channel receive is an expression: you can store the received value in a variable,
or pass it to a function.

  v := <-ch
  fmt.Println(<-ch)

The value received is only a copy of the value that was sent to the channel.



* Semantics of a channel receive

.image receive_semantics.svg 400 _

Note: the value received from a channel by a goroutine is only accessible to that goroutine; it is removed from the channel for all the other goroutines.



* Exercise

.play -edit deadlock_example.go /^//START/,/^//END/

This programme deadlocks. Can you guess why? How would you fix it?

Add sends and receives to fix ideas. Discuss.



* Receive ambiguity

As shown by the diagram on the previous slide, when a channel is closed and empty, receiving from that channel yields the zero value of the channel's element type...

.image https://blog.golang.org/gopher/plush.jpg 300 _

How can we tell whether the value we're receiving is from a closed channel or whether someone really sent a zero value of the element's type to the channel?



* Dispelling the ambiguity

There is a special form of channel receive that yields an additional boolean value (named "ok", by convention):

   v, ok := <-ch


The value of `ok` is

- `true` if the value received was delivered by a successful send operation to the channel, or
- `false` if it is a zero value generated because the channel is closed and empty.



* Closing a channel

A freshly initialized channel starts its life in an "open" state.

  ch := make(chan string) // ch is open (until closed)

You can close a channel to indicate that no more values are to be added to it:

  close(ch)

Closing a channel is definitive; a closed channel cannot be "re-opened".



* Semantics of close

.image close_semantics.svg _ 800

Note:

- Closing the nil channel causes a panic.
- Closing an already closed channel causes a panic




* How is closing a channel useful?

*Terminating*a*range*operation*

If you range over a channel anywhere in your code, that range expression will block until you close the channel.

*Broadcasting*a*signal*

Because closing a channel unblocks all receives from that channel, it can be used to broadcast a signal to multiple goroutines!

In fact, the [[https://golang.org/pkg/context/][`context` package]] is [[https://vimeo.com/115309491#t=10m][based on this idea]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/projects/go-grpc-web.svg 200 _



* Do not systematically close channels

Channels are not resources; closing a channel is not a way to reclaim or clean up resources (memory, etc.).

Channels will get garbage-collected like any other variable once they become unreachable.

You only need to close a channel if the semantics of your programme demand it.




* Closing a channel doesn't drain it

Think of a restaurant as a channel.

- Announcing the end of service doesn't mean pushing all the patrons out; they can finish their meal before leaving.
- Similarly, closing a channel doesn't amount to flushing it out; some goroutine(s) can still consume those elements.

.image https://rew-online.com/wp-content/uploads/2019/10/restaurantCLOSED.jpg 300 _








* Ranging over a channel

Ranging over a channel amounts to iteratively receiving from it:

  for v := range ch {
    // do something with v
  }

Note: only iteration variable is permitted.

The code above is an exact equivalent to the following:

  for {
    v, ok := <-ch
    if !ok {
      break
    }
    // do something with v
  }



* Ranging over a channel blocks until the channel is closed

Important: the `for` statement will block until the channel is closed!

.play -edit range_blocks_until_channel_closed.go /^//START/,/^//END/



* Reminder: channels are reference types

Operating on a copy `cb` of a channel `ca` affects the same underlying data structure as if you operated on channel `ca` directly.

.play -edit channels_are_references.go /^//START/,/^//END/

If that weren't the case, passing channels to functions wouldn't be very useful.



* Namecheck project: gather the results via a channel

1. In `main`, declare some `Result` type.
2. In `main`, initialize a `chan`Result`, and make sure it is accessible to the spawned goroutines.
3. In each spawned goroutine, create a `Result` value and send it to the channel.
4. In `main`, range over that channel and store the results in a slice.
5. In `main`, Print the resulting slice.

.image https://blog.golang.org/store/gophers.jpg 400 _

: type Result struct { Username string Platform string Valid bool Available bool Error error }
: the channel allows us to serialize access to the slice (local mutable state)



* Channel directions

You can mark a channel as _send-only_ or _receive-only_ by adding the optional `<-` operator on the right or left (respectively) of the `chan` keyword.

This is particularly useful for locally restricting the operations possible on a channel parameter within a function:

  func produce(c chan<- string) {} // c is send-only within produce
  func consume(c <-chan string) {} // c is receive-only within consume

You can pass a bidirectional channel wherever a unidirectional channel is expected.

The compiler disallows

- receiving from a send-only channel, and
- sending to or closing a receive-only channel.



* Channel directions: example

.play -edit channel_dir.go /^//START/,/^//END/



* Why use unidirectional channels

Unidirectional channels are great for

- clarifying the role of a channel within a function,
- increasing your confidence in the correctness of your code.

Use them liberally, wherever possible.

However, in cases where a function [[https://talks.golang.org/2012/10things.slide#10][legitimately needs to both send to and receive from a channel]], a bidirectional channel is needed.



* Namecheck project: use unidirectional channels

Review the functions that accept a channel parameter, and determine whether a channel direction could have been specified.

.image https://blog.golang.org/gopher/plush.jpg 400 _



* Select statement

A `select` statement is multiway concurrent control switch.

  select {
  case v, ok:= <-ch1:
    // do something with v and ok
  case ch2 <- 42:
    // ...
  default:
    // ...
  }

- Each of the "normal" (non-default) cases correspond to a channel communication (send or receive).
- The first normal case that can proceed gets selected.
- If more than one normal cases can proceed, one of them is chosen in a uniform pseudo-random fashion.
- If no normal case can proceed, the default case (if any) gets selected; otherwise, the `select` statement blocks.



* For-select loop

`select` is often used in conjunction with `for` to form an "event loop":

  for someCondition {
    select {
    case v, ok := <-results:
      // ...
    case  err, ok := <-errc:
      // ...
    }
  }



* Namecheck project: fail early

1. Remove the `Error` field from your `Result` type
2. Modify your code to report normal results and errors through separate channels.
3. Use a `select` statement to receive from both channels.
4. Terminate the programme as soon as one error is received

Hint: choose channel capacity wisely.

.image https://blog.golang.org/gopher/plush.jpg 300 _


* Canceling goroutines

Spawning goroutines is easy, but making sure they terminate sometimes requires more effort. One common recipe for canceling a goroutine consists of

- a `select` statement
- a channel of type `<-chan`struct{}` (commonly named "quit" or "done")

  func cancellable(quit <-chan struct{}) {
    for {
        select {
        case <-quit:
          return
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

If function `cancellable` is launched as a goroutine, another goroutine can get it to terminate by sending to or closing the `quit` channel. Why?



* Exercise: render a function cancellable

.play -edit uncancellable.go /^//START/,/^//END/

Function `printInts` only terminates when the whole program does.

Modify `printInts` to make it cancellable from `main`. Cancel the goroutine after one second.

You can do this exercise in the [[https://play.golang.org/p/ANQV_mTOriS][Go Playground]].



* Exercise: render a function cancellable (solution)

.play -edit cancellable.go /^//START/,/^//END/

This solution is available on the [[https://play.golang.org/p/xlT_rE5B43n][Go Playground]].

: mention that closing the channel broadcasts a signal to all goroutines that receive from it



* Canceling goroutines with context

The `context` package exports an interface type named `Context` that is convenient for terminating goroutines via cancellation and/or timeouts.

`Context`'s cancellation mechanism is based on the same quit-channel trick; the channel is accessible via `Context`'s `Done` method:

  func cancellable(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
          return
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

By convention, the `context.Context` parameter (if any) is always first.



* Exercise: cancelling a goroutine with context.Context

Browse the documentation of the `context`, and modify the code from the previous exercise to use a `context.Context` rather than a `quit` channel.

You can do this exercise in the [[https://play.golang.org/p/xlT_rE5B43n][Go Playground]].



* Exercise: ping-pong and goroutine leaks

This [[https://play.golang.org/p/R4_2kBHF3gy][Go Playground]] models a ping-pong game.

Unfortunately, a goroutine systematically leaks.

Explain why and how you would you fix it.

: two goroutines exchanging one value over and over
: valid use case of a bidirectional channel
: pointer element to reduce memory footprint
: show that deadlock if you never throw the ball on the table
: one player terminates while the other is left holding the ball
: one possibility: buffer size of 1, but no guarantee that the same player will play twice in a row
: non-blocking send by adding a select statement



* Namecheck project: turn your CLI tool into a Web server

Create a `server` folder under `cmd` and copy `cmd/cli/main.go` to `cmd/server/main.go`.

  namecheck
  ├── cmd
  │   ├── cli
  │   │   └── main.go
  │   └── server
  │       └── main.go
  ├── github
  │   ├── github.go
  │   └── github_test.go
  ├── go.mod
  ├── namecheck.go
  └── twitter
      ├── twitter.go
      └── twitter_test.go



* Namecheck project: turn your CLI tool into a Web server

1. Start from [[https://golang.org/pkg/net/http/#example_ListenAndServe][https://golang.org/pkg/net/http/#example_ListenAndServe]].
2. Adapt the code from the CLI executable to your server
3. Define a `/check` route that accepts a username to test as a query parameter.
4. Return JSON in the HTTP response (see [[https://golang.org/pkg/encoding/json/][encoding/json]]); make sure the content type is correct.



* Namecheck project: use a third-party package for routing

We'll use [[https://github.com/gorilla/mux][gorilla/mux]], a popular alternative to `net/http` for defining routes.

To download the dependency, run the following command at the root of your project:

  go get github.com/gorilla/mux

Doing so will also update your `go.mod` file and create a `go.sum` file.

Import `gorilla/mux` in your server's `main.go` and redefine your route with it.

: we don't really need mux here; nothing fancy; just for practice



* Communicating by sharing memory

Go encourages you to use channels to communicate between goroutines.

However, sometimes, sharing memory is simpler and/or performant.

We'll cover two facilities for sharing memory:

- synchronized operations on fixed-sized integers, provided by the [[https://golang.org/pkg/sync/atomic/][`sync/atomic` package]],
- [[https://en.wikipedia.org/wiki/Mutual_exclusion][mutual exclusions]], provided by [[https://golang.org/pkg/sync/][`sync` package]].



* Namecheck project: number of visits

This a motivating exercise for atomics.

Keep an in-memory count of the number of requests served by our `/check` route.

- Declare an integer variable named `visits` at the level of the `main` package.
- Increment `visits` at each invokation of `/check` handler.
- Create an additional route `/count` that returns the total number of visits.

Discuss.



* The need for atomic operations

Our server is concurrent: it handles each incoming request in a separate goroutine.

However, unsafely incrementing an integer from multiple goroutines yields unpredictable results: some updates typically get lost.

.play -edit plusplus_isnt_atomic.go /^//START/,/^//END/



* Namecheck project: number of visits

By unsafely writing to and reading from our `visits` variable from multiple goroutines, we've created a data race and are likely to lose updates to `visits`.

Consult the documentation of the [[https://golang.org/pkg/sync/atomic/][`sync/atomic` package]] and fix the data race.

.image http://alinken.people.ua.edu/uploads/8/7/9/2/87929690/published/ghostbusters.jpg

: Check whether the race detector can detect it.



* Namecheck project: count of checks per username

This a motivating exercise for mutual exclusions.

Keep track (in memory) of how many times each username has been checked.

- What data structure seems appropriate?
- Create an additional `/frequency` route that returns a JSON representation of the data structure in question.

Discuss.


* TODO

map is not concurrency-safe
can't use sync/atomics because only applies to fixed-sized integers.



* What we haven't covered

We're nearing the end of the course.

You've learned a lot, but there is [[https://www.humancoders.com/formations/go-avance][more]]!

.image https://blog.golang.org/store/gophers.jpg 400 _


* Open discussion
