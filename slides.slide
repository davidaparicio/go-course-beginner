Formation Go
01 January 2021

Julien Cretel
jcretel-infosec@protonmail.com
https://jub0bs.com
@jub0bs

* Setup

- Go (>= 1.16)
- Visual Studio Code
- [[https://code.visualstudio.com/docs/languages/go][Go extension for Visual Studio Code]]
- Git


* About the course

- interaction
- regular breaks
- learn the fundamentals
- emphasis on practice over theory
- long-running project

: the source code of my solution will be available on GitHub



* Namecheck project

*Objectives*

- Write a small CLI tool to check the validity and status of a username on multiple social networks.
- Convert it into a HTTP server.
- A forcing function for learning Go: we'll introduce new concepts as needed.

*Business* *case*

- Choose a brand name consistent across multiple platforms.
- Username squatting ðŸ˜ˆ

: mention Newsweaver's rebranding to Poppulo, missed claiming @Poppulo on Twitter


* Before we get started: Hello World

.play -edit helloworld.go




* A few words about Go



* Go's mascot

\... [[https://blog.golang.org/gopher][is a gopher]].

.image https://blog.golang.org/gopher/gopher.png 400 _



* Go's logo

\... [[https://blog.golang.org/go-brand][is not the gopher!]]

.image https://blog.golang.org/go-brand/logos.jpg 400 _



* Genesis

Go was created in 2007 at Google by Robert Griesemer, Rob Pike, and Ken Thompson.

.image three_lads.jpeg



* Genesis

Robert, Rob, and Ken started working on Go (on 20% time) out of frustration with C++: language complexity, long build times, poor support for concurrency.

.image https://imgs.xkcd.com/comics/compiling.png



* History of the Go project

- started in 2007
- open-sourced in 2009
- Go 1.0 released in 2012
- ...
- Go 1.16 released in 2021.



* Go's object orientation

Go allows you to declare custom types (and methods on them), which promote _abstraction_.

Go has no concept of _inheritance_. Instead, it facilitates _composition_.

Go interfaces enable _polymorphism_ and structural subtyping.

Go packages enable _encapsulation_.



* Go's functional orientation

Functions are first-class citizens: they can

- take other functions as parameters, and
- return functions as results.

Go also supports

- anonymous functions (though no concise "lambda" notation), and
- lexical closures (functions can capture variables from the scope they're declared in).



* Keywords

  break       default       func      interface   select
  case        defer         go        map         struct
  chan        else          goto      package     switch
  const       fallthrough   if        range       type
  continue    for           import    return      var

Which ones are new to you? Which ones seem to be missing?



* Namecheck project: validation of Twitter usernames

A prospective username is accepted by Twitter if it

- does not contain any case-insensitive match of "twitter" (e.g. "TwItTEr"),
- contains between 4 and 15 alphanumeric or underscore characters.

Write a function that implements the first rule:

  func containsNoIllegalPattern(username string) bool {
    // returns true if username does not contain "twitter"
    // (and all case variations, incl. "TwItTEr", etc.)
  }

Hint: keep it simple!


* Namecheck project: validation of Twitter usernames

Use the `regexp` package to write a function that implements the second rule:

  func containsOnlyLegalChars(username string) (bool, error) {
    // returns true if username matches ^[0-9A-Z_a-z]{4,15}$
  }

Does the function's signature satisfy you? What would you prefer? Why? How would you do it?



* Concurrency



* Concurrency

Concurrency is the art of composing a programme in terms of independently executing computations.

Go has native support (i.e. in the language and runtime) for concurrency.

Go's concurrency model is arguably one of the language's strengths, but can be difficult to learn and master.

: hence being relegated to the end of many learning resources



* Concurrency

Disclaimer: many cooking metaphors ahead!

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 400 _



* Concurrency is not parallelism

*Concurrency*

- the art of structuring a programme in terms of independenly executing computations
- a property of the programme's code

*Parallelism*

- the simultaneous execution of multiple things on multiple cores
- a property of the running program



* Parallelism is not the goal of concurrency

Concurrency _enables_ parallelism, but parallelism isn't the goal.

It's valuable to write concurrent code even while being ignorant of whether that code will eventually run in parallel.

And if good concurrent code does run in parallel, we should get graceful performance improvement for free as the number of cores increase.

See also

- [[https://www.youtube.com/watch?v=oV9rvDllKEg][Rob Pike - Concurrency is not Parallelism (2012)]].
- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=3m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]



* Go's concurrency model

Largely inspired by [[https://dl.acm.org/doi/10.1145/359576.359585][Tony Hoare's  _Communicating_Sequential_Processes_ (1978)]]

Two fundamental mechanisms:

- goroutines: lightweight threads
- channels: typed pipes used to communicate and synchronize between goroutines

.image busy_gophers.jpeg 300 _



* Goroutines

A goroutine is a concurrent function execution.

It can be thought of as a very lightweight thread: it's common for programmes to have 1000s of goroutines, even on a single core.

The `main` function is itself a goroutine that is created when the programme starts.

Each goroutine gets its own stack, which starts small and grows/shrinks as required.

.image https://blog.golang.org/store/gophers.jpg 400 _



* Goroutines execute in the same address space

For example, a goroutine can pass a pointer to another goroutine, and the latter can dereference that pointer without causing an access violation.

[[https://golang.org/doc/effective_go.html#goroutines][The onus is on you to be careful]] in order to avoid data races!

(A [[https://en.wikipedia.org/wiki/Race_condition#Data_race][data race]] occurs when multiple goroutines write to and read from the same memory location at the same time.)



* The Go scheduler

The _Go_scheduler_ is a part of the Go runtime that automatically multiplexes goroutines onto operating-systems threads and manages their scheduling for us.

It continually observes the run-time behavior of goroutines and decides to suspends them when they block and then resumes them when they become unblocked.

No need for you to think about it; just picture the Go scheduler and goroutines as a chef and his/her kitchen assistants.

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 250 _



* The go keyword

The `go` keyword spawns a new goroutine: it causes the function call that follows it to get executed "in the background".

  go grindCoffeeBeans()
  go frothMilk()

`go` statements return _immediately_.

The result(s) of the function call to which the `go` keyword is applied are lost.

Launching an anonymous function as a goroutine is common:

  go func() {
    fmt.Println("Grinding coffee beans...")
  }()

: just don't forget to invoke it!
: terminology: spawning goroutine vs. spawned goroutine



* Goroutines vs. Unix processes

It's useful to compare goroutines to Unix processes...

The `go` keyword is reminiscent of the ampersand operator (`&`) in Unix shells.

  #!/usr/bin/env sh

  grindCoffeeBeans &
  frothMilk &

However, unlike a Unix process, a goroutine has no concept of an ID (see why [[https://talks.golang.org/2014/go4gophers.slide#38][here]]).

Therefore, a goroutine cannot readily be _killed_.



* The golden rule

Before spawning a new goroutine, you must understand exactly under what conditions it will terminate.

If you're careless and spawn goroutines willy-nilly, you expose yourself to correctness and performance bugs (_goroutine_leaks_).

.image this_is_fine.png 300 _



* Exercise: concurrent coffee making

Write two functions, `grindCoffeeBeans` and `frothMilk`, that

- take no parameters and return no results,
- simply write an informative message to stdout.

Call them concurrently in the `main` function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _

: Q: Which message will be printed first? We can't tell. Up to the scheduler.



* Exercise: concurrent coffee making (first attempt)

.play -edit goroutines_without_waitgroup.go /^//START/,/^//END/

Does the programme behave as you expected? Why or why not?



* main does not wait!

Nothing gets written to stdout because

- the two `go` statements _immediately_ transfer control back to `main`, and
- `main` terminates _before_ your two goroutines themselves terminate!

We need a way to tell `main` to "wait" until the two goroutines terminate.

Any ideas?



* Exercise: concurrent coffee making (with sleep)

Sleep a bit at the end?

.play -edit goroutines_with_sleep.go /^//START/,/^//END/

However, this solution is not entirely satisfactory. Why?

: inefficient at best, nondeterministic at worst



* Sleeping is not the answer

How long should the sleep be, exactly? Impossible to know in advance.

- Wait too little: `main` terminates too quickly for all the other goroutines to terminate.
- Wait too long: `main` ends up needlessly spinning and wasting time.

.image https://drek4537l1klr.cloudfront.net/youngman/Figures/f0255-01.jpg 200 _

Sleeping is simply not a reliable and efficient way of coordinating goroutines!

We need another mechanism...

: there are legitimate use cases for `time.Sleep` in a Go programme, but...



* Wait groups

The standard library's [[https://golang.org/pkg/sync/#WaitGroup][`sync` package]] provides a mechanism for _orchestrating_ goroutines: wait groups.

Wait groups are particularly useful when the number of goroutines to spawn is not known in advance.

: e.g. if you're spawning a goroutine for each line of a file that you're reading, or for each element received from a channel



* Declaring a wait group

The zero value is readily usable:

  wg := sync.WaitGroup{} // unnecessary

  var wg sync.WaitGroup  // better



* Operations on a wait group

A wait group is little more than a glorified counter with _concurrency-safe_ operations.

- `wg.Add(n)` increments the counter by n (>0).
- `wg.Done()` decrements the counter by 1. It's equivalent to `wg.Add(-1)`.
- `wg.Wait()` blocks until the counter goes back to 0; it acts as a [[https://en.wikipedia.org/wiki/Barrier_(computer_science)][_barrier_]].



* How to use a wait group

Call `wg.Add(1)` _just_before_ spawning a goroutine.

Call `wg.Done()` _at_the_very_end_ of each spawned goroutine (use `defer`!).

Call `wg.Wait()` in the spawning goroutine to wait for all spawned goroutines to terminate.



* Exercise: concurrent coffee making (using a wait group)

Use a wait group to make `main` wait until both `grindCoffeeBeans` and `frothMilk` have terminated before `main` itself can terminate.

Tip: you can apply the `go` keyword to an anonymous function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _



* Exercise: concurrent coffee making (using a wait group)

(implementations of `grindCoffeeBeans` and `frothMilk` are as before)

.play -edit goroutines_with_waitgroup.go /^//START/,/^//END/

: don't forget the pair of parens at the end of each function literal!
: What happens if I remove a wg.Done()? deadlock
: What happens if I remove a wg.Add(1)? only one of the two goroutine will likely have time execute



* How not to misuse wait groups

Calls to `wg.Add` must take place in the spawning goroutine, _not_ within the spawned goroutine.

The call to `wg.Wait` must happen _after_ all calls to `wg.Add` (otherwise: data race).

If a function needs a wait group declared elsewhere, pass a pointer to it (`*sync.WaitGroup`) as an argument to the function.

.image https://blog.golang.org/gopher/plush.jpg 300 _

: if wg.Add concurrent with wg.Wait, data race: https://play.golang.org/p/PPlY-M7yfYh



* Closures running as goroutines: spot the bug

Can you spot the bug in the following programme?

.play -edit goroutine_func_quiz.go /^//START/,/^//END/

: ask them first how they expect the programme to behave
: sometimes prints 10, not 9! because loop variable goes beyond bound before loop can end



* Closures running as goroutines: explanation

There is a _data_race_: a variable is being read and updated by different goroutines at the same time!

More specifically, the goroutines spawned by `printTenIntsConcurrently` _capture_ and read loop variable `i` as it's being updated by the loop.

.play -edit goroutine_func_answer.go /^//START/,/^//END/

Consequently, the programme is underministic: the results are unpredictable.



* Detecting the data race

We've identified the data race by inspection, but some static- and dynamic-analysis tools can help.

*go*vet*

This subcommand analyzes the code and can detect issues that the compiler does not.

Try running `go` `vet` on the programme.

*race*detector*

The Go CLI provides a [[https://blog.golang.org/race-detector][race detector]], i.e. a tool that can detect data races during execution.

Try running the programme with the `-race` flag.

Caution: the race detector is [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][not guaranteed to catch all data races]].



* Fixing the data race

Pass the value of the loop variable as an argument to the anonymous function.

That way, by virtue of Go's call-by-value evaluation strategy, the function only has access to a copy of the loop variable.

.play -edit goroutine_func_arg.go /^//START/,/^//END/



* Fixing the data race

An alternative solution consists in redeclaring the variable inside the loop.

.play -edit goroutine_func_redecl.go /^//START/,/^//END/

See also the [[https://golang.org/doc/faq#closures_and_goroutines][Golang FAQ about this]].



* Be careful when running closures as goroutines

When running a closure as a goroutine, it's very easy to inadvertently capture variables, which may cause data races.

Defining a dedicated named function can help:

.play -edit goroutine_func_standalone.go /^//START/,/^//END/



* Namecheck project: check concurrently

Rather than checking the username on each platform sequentially, do so concurrently.

Does the user experience improve?



* Namecheck project: aggregate the results (how?)

What if, instead of simply printing the results, we wanted to somehow aggregated them?

Remember: the result(s) of the function call to which the `go` keyword is applied are lost.

We need a way to communicate between goroutines...



* Channels



* Don't communicate by sharing memory; share memory by communicating.

Because goroutines all execute in the same address space, we need to be careful about data access from multiple goroutines.

We could use locks to synchronize goroutine access to the shared memory...

\... but Go encourages a different approach, in which shared values are passed around on _channels_.

See also

- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=2m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]
- [[https://golang.org/doc/effective_go#sharing][Effective Go (Share by communicating)]]



* Channels are typed

Channels are typed conduits that allow goroutines to synchronize and exchange information.

The element type of a channel is arbitrary.

A channel whose element type is `T` has type `chan`T`.

  var ch chan string // channel of strings

: channels only exist within the confines of your programme; they can't be used to communicate between different processes, be they written in Go.



* Popular naming choices for channels

"c" or "ch", on its own or as a suffix (with or without camelcase):

  var c chan int
  var ch chan string
  var errc chan error
  var taskCh chan Task

Plural of the channel's element type:

  var tasks chan Task



* Channels are first-class values

You can pass a channel to a function:

  func Aggregate(results chan Result) Result { /* ... */ }

You can return a channel from a function:

  func Generate(upTo int) chan int { /* ... */ }

You can store a channel in a struct type:

  type Request struct {
      fn func() int  // The operation to perform.
      c  chan bool    // The channel to return the result.
  }

Channels are comparable.




* Initializing a channel

Channels are reference types; their zero value is `nil`.

To initialize a channel, use built-in function `make` with two arguments:

- the first argument corresponds to the type of the channel;
- the second argument is an (optional) `int` corresponding to the channel's desired (non-negative) _capacity_.

  c1 := make(chan string) // equivalent to make(chan string, 0)
  c2 := make(chan string, c)

A channel's capacity cannot be changed after initialization.

A freshly initialized channel starts its life in an "open" state, but can later be _closed_.

: The specified capacity (if any) must be non-negative; otherwise, you'll get a compilation error or, worse, a panic.



* Channel capacity

A channel's capacity corresponds to the size of its _buffer_.

Choosing it wisely is important, as it usually affects the correctness and/or the performance of your programme.

Built-in function `cap` can be used to query a channel's capacity:

  c := make(chan string, 20)
  fmt.Println(cap(c)) // 20

Some terminology:

- A channel of zero capacity is called an _unbuffered_channel_.
- A channel of positive capacity is called a _buffered_channel_.

: The number of elements queued in a channel's buffer can also be queried via built-in function `len`, but is rarely useful. Why?
: if more than one goroutine interact with the channel, len(ch) is stale as soon as queried
: increasing buffer size may help reduce pressure on the Go scheduler



* A kitchen serving-hatch as a metaphor

Think of goroutines as cooks and waiters on either side of a serving hatch, which represents a channel.

The channel's capacity corresponds to the number of plates that can fit on the serving hatch's platform at any one time.

.image https://josephdmcnamee.files.wordpress.com/2012/01/serving-hatch1.jpg 350 _

: what does a channel of capacity 0 correspond to?
: the analogy is imperfect because channels are FIFO and waiters don't necessarily pick up plates in the order in which they arrived



* Operations on a channel

Channels support the following operations:

- _sending_ a value to a channel,
- _receiving_ a value from a channel,
- _closing_ a channel (that hasn't been closed yet).

You can also _range_ over a channel, which consists in continually receiving values from it until the channel gets closed.

All those operations are *concurrency-safe*.

: _Channel_communications_ is a general term for describing both channel sends and receives.
: we'll see why closing a channel is useful soon



* Sending to a channel

The syntax of a _channel_send_ consists in the channel in question, followed by a left-pointing arrow (`<-`), followed by the value to send.

  ch := make(chan string)
  // ...
  v := "superimportant message"
  ch <- v

The `gofmt` tool will adds a space on either side of the arrow; don't fight it.

A channel send is a statement, not an expression.



* Semantics of a channel send

.image send_semantics.svg 400 _

Note: buffered channels accept a limited number of values without a corresponding receive for those values.


* Receiving from a channel

The syntax of a _channel_receive_ consists in a left-pointing arrow (`<-`), followed by the channel in question.

  ch := make(chan string)
  // ...
  <-ch

The `gofmt` tool removes any whitespace between the arrow the channel; don't fight it.

A channel receive is an expression: you can store the received value in a variable, or pass it to a function.

  v := <-ch
  fmt.Println(<-ch)

The value received is only a copy of the value that was sent to the channel.



* Semantics of a channel receive

.image receive_semantics.svg 400 _

Note: the value received from a channel by a goroutine is only accessible to that goroutine; it is removed from the channel for all the other goroutines.



* Exercise

.play -edit deadlock_example.go /^//START/,/^//END/

This programme deadlocks. Can you guess why? How would you fix it?

Add sends and receives to fix ideas. Discuss.



* Receive ambiguity

As shown by the diagram on the previous slide, when a channel is closed and empty, receiving from that channel yields the zero value of the channel's element type...

.image https://blog.golang.org/gopher/plush.jpg 300 _

How can we tell whether the value we're receiving is from a closed channel or whether someone really sent a zero value of the element's type to the channel?



* Dispelling the ambiguity

There is a special form of channel receive that yields an additional boolean value (named "ok", by convention):

   v, ok := <-ch


The value of `ok` is

- `true` if the value received was delivered by a successful send operation to the channel, or
- `false` if it is a zero value generated because the channel is closed and empty.



* Closing a channel

A freshly initialized channel starts its life in an "open" state.

  ch := make(chan string) // ch is open (until closed)

You can close a channel to indicate that no more values are to be added to it:

  close(ch)

Closing a channel is definitive; a closed channel cannot be "re-opened".



* Semantics of close

.image close_semantics.svg _ 800

Note:

- Closing the nil channel causes a panic.
- Closing an already closed channel causes a panic




* How is closing a channel useful?

*Terminating*a*range*operation*

If you range over a channel anywhere in your code, that range expression will block until you close the channel.

*Broadcasting*a*signal*

Because closing a channel unblocks all receives from that channel, it can be used to broadcast a signal to multiple goroutines!

In fact, the [[https://golang.org/pkg/context/][`context` package]] is [[https://vimeo.com/115309491#t=10m][based on this idea]].



* Do not systematically close channels

Channels are not resources; closing a channel is not a way to reclaim or clean up resources (memory, etc.).

Channels will get garbage-collected like any other variable once they become unreachable.

You only need to close a channel if the semantics of your programme demand it.




* Closing a channel doesn't drain it

Think of a restaurant as a channel.

- Announcing the end of service doesn't mean pushing all the patrons out; they can finish their meal before leaving.
- Similarly, closing a channel doesn't amount to flushing it out; some goroutine(s) can still consume those elements.

.image https://rew-online.com/wp-content/uploads/2019/10/restaurantCLOSED.jpg 300 _








* Ranging over a channel

Ranging over a channel amounts to iteratively receiving from it:

  for v := range ch {
    // do something with v
  }

Note: only iteration variable is permitted.

The code above is an exact equivalent to the following:

  for {
    v, ok := <-ch
    if !ok {
      break
    }
    // do something with v
  }



* Ranging over a channel blocks until the channel is closed

Important: the `for` statement will block until the channel is closed!

.play -edit range_blocks_until_channel_closed.go /^//START/,/^//END/



* Reminder: channels are reference types

Operating on a copy `cb` of a channel `ca` affects the same underlying data structure as if you operated on channel `ca` directly.

.play -edit channels_are_references.go /^//START/,/^//END/

If that weren't the case, passing channels to functions wouldn't be very useful.



* Namecheck project: gather the results via a channel

1. In `main`, declare some `Result` type.
2. In `main`, initialize a `chan`Result`, and make sure it is accessible to the spawned goroutines.
3. In each spawned goroutine, create a `Result` value and send it to the channel.
4. In `main`, range over that channel and store the results in a slice.
5. In `main`, Print the resulting slice.

.image https://blog.golang.org/store/gophers.jpg 400 _

: type Result struct { Username string Platform string Valid bool Available bool Error error }
: the channel allows us to serialize access to the slice (local mutable state)



* Channel directions

You can mark a channel as _send-only_ or _receive-only_ by adding the optional `<-` operator on the right or left (respectively) of the `chan` keyword.

This is particularly useful for locally restricting the operations possible on a channel parameter within a function:

  func produce(c chan<- string) {} // c is send-only within produce
  func consume(c <-chan string) {} // c is receive-only within consume

You can pass a bidirectional channel wherever a unidirectional channel is expected.

The compiler disallows

- receiving from a send-only channel, and
- sending to or closing a receive-only channel.



* Channel directions: example

.play -edit channel_dir.go /^//START/,/^//END/



* Why use unidirectional channels

Unidirectional channels are great for

- clarifying the role of a channel within a function,
- increasing your confidence in the correctness of your code.

Use them liberally, wherever possible.

However, in cases where a function [[https://talks.golang.org/2012/10things.slide#10][legitimately needs to both send to and receive from a channel]], a bidirectional channel is needed.



* Namecheck project: use unidirectional channels

Review the functions that accept a channel parameter, and determine whether a channel direction could have been specified.

.image https://blog.golang.org/gopher/plush.jpg 400 _



* Select statement

A `select` statement is multiway concurrent control switch.

  select {
  case v, ok:= <-ch1:
    // do something with v and ok
  case ch2 <- 42:
    // ...
  default:
    // ...
  }

- Each of the "normal" (non-default) cases correspond to a channel communication (send or receive).
- The first normal case that can proceed gets selected.
- If more than one normal cases can proceed, one of them is chosen in a uniform pseudo-random fashion.
- If no normal case can proceed, the default case (if any) gets selected; otherwise, the `select` statement blocks.



* For-select loop

`select` is often used in conjunction with `for` to form an "event loop":

  for someCondition {
    select {
    case v, ok := <-results:
      // ...
    case  err, ok := <-errc:
      // ...
    }
  }



* Namecheck project: fail early

1. Remove the `Error` field from your `Result` type
2. Modify your code to report normal results and errors through separate channels.
3. Use a `select` statement to receive from both channels.
4. Terminate the programme as soon as one error is received

Hint: choose channel capacity wisely.

.image https://blog.golang.org/gopher/plush.jpg 300 _


* Canceling goroutines

Spawning goroutines is easy, but making sure they terminate sometimes requires more effort. One common recipe for canceling a goroutine consists of

- a `select` statement
- a channel of type `<-chan`struct{}` (commonly named "quit" or "done")

  func cancellable(quit <-chan struct{}) {
    for {
        select {
        case <-quit:
          return
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

If function `cancellable` is launched as a goroutine, another goroutine can get it to terminate by sending to or closing the `quit` channel. Why?



* Exercise: render a function cancellable

.play -edit uncancellable.go /^//START/,/^//END/

Function `printInts` only terminates when the whole program does.

Modify `printInts` to make it cancellable from `main`. Cancel the goroutine after one second.

You can do this exercise in the [[https://play.golang.org/p/ANQV_mTOriS][Go Playground]].



* Exercise: render a function cancellable (solution)

.play -edit cancellable.go /^//START/,/^//END/

This solution is available on the [[https://play.golang.org/p/xlT_rE5B43n][Go Playground]].

: mention that closing the channel broadcasts a signal to all goroutines that receive from it



* Canceling goroutines with context

The `context` package exports an interface type named `Context` that is convenient for terminating goroutines via cancellation and/or timeouts.

`Context`'s cancellation mechanism is based on the same quit-channel trick; the channel is accessible via `Context`'s `Done` method:

  func cancellable(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
          return
        default:
          // do something, and maybe sleep a bit
        }
    }
  }

By convention, the `context.Context` parameter (if any) is always first.



* Exercise: cancelling a goroutine with context.Context

Browse the documentation of the `context`, and modify the code from the previous exercise to use a `context.Context` rather than a `quit` channel.

You can do this exercise in the [[https://play.golang.org/p/xlT_rE5B43n][Go Playground]].



* Exercise: ping-pong and goroutine leaks

This [[https://play.golang.org/p/R4_2kBHF3gy][Go Playground]] models a ping-pong game.

Unfortunately, a goroutine systematically leaks.

Explain why and how you would you fix it.

: two goroutines exchanging one value over and over
: valid use case of a bidirectional channel
: pointer element to reduce memory footprint
: show that deadlock if you never throw the ball on the table
: one player terminates while the other is left holding the ball
: one possibility: buffer size of 1, but no guarantee that the same player will play twice in a row
: non-blocking send by adding a select statement



* Namecheck project: turn your CLI tool into a Web server

Create a `server` folder under `cmd` and copy `cmd/cli/main.go` to `cmd/server/main.go`.

  namecheck
  â”œâ”€â”€ cmd
  â”‚Â Â  â”œâ”€â”€ cli
  â”‚Â Â  â”‚Â Â  â””â”€â”€ main.go
  â”‚Â Â  â””â”€â”€ server
  â”‚Â Â      â””â”€â”€ main.go
  â”œâ”€â”€ github
  â”‚Â Â  â”œâ”€â”€ github.go
  â”‚Â Â  â””â”€â”€ github_test.go
  â”œâ”€â”€ go.mod
  â”œâ”€â”€ namecheck.go
  â””â”€â”€ twitter
      â”œâ”€â”€ twitter.go
      â””â”€â”€ twitter_test.go



* Namecheck project: turn your CLI tool into a Web server

1. Start from [[https://golang.org/pkg/net/http/#example_ListenAndServe][https://golang.org/pkg/net/http/#example_ListenAndServe]].
2. Adapt the code from the CLI executable to your server
3. Define a `/check` route that accepts a username to test as a query parameter.
4. Return JSON in the HTTP response (see [[https://golang.org/pkg/encoding/json/][encoding/json]]); make sure the content type is correct.



* Namecheck project: use a third-party package for routing

We'll use [[https://github.com/gorilla/mux][gorilla/mux]], a popular alternative to `net/http` for defining routes.

To download the dependency, run the following command at the root of your project:

  go get github.com/gorilla/mux

Doing so will also update your `go.mod` file and create a `go.sum` file.

Import `gorilla/mux` in your server's `main.go` and redefine your route with it.

: we don't really need mux here; nothing fancy; just for practice



* Communicating by sharing memory

Go encourages you to use channels to communicate between goroutines.

However, sometimes, sharing memory is simpler and/or performant.

We'll cover two facilities for sharing memory:

- synchronized operations on fixed-sized integers, provided by the [[https://golang.org/pkg/sync/atomic/][`sync/atomic` package]],
- [[https://en.wikipedia.org/wiki/Mutual_exclusion][mutual exclusions]], provided by [[https://golang.org/pkg/sync/][`sync` package]].



* Namecheck project: number of visits

This a motivating exercise for atomics.

Keep an in-memory count of the number of requests served by our `/check` route.

- Declare an integer variable named `visits` at the level of the `main` package.
- Increment `visits` at each invokation of `/check` handler.
- Create an additional route `/count` that returns the total number of visits.

Discuss.



* The need for atomic operations

Our server is concurrent: it handles each incoming request in a separate goroutine.

However, unsafely incrementing an integer from multiple goroutines yields unpredictable results: some updates typically get lost.

.play -edit plusplus_isnt_atomic.go /^//START/,/^//END/



* Namecheck project: number of visits

By unsafely writing to and reading from our `visits` variable from multiple goroutines, we've created a data race and are likely to lose updates to `visits`.

Consult the documentation of the [[https://golang.org/pkg/sync/atomic/][`sync/atomic` package]] and fix the data race.

.image http://alinken.people.ua.edu/uploads/8/7/9/2/87929690/published/ghostbusters.jpg

: Check whether the race detector can detect it.



* Namecheck project: count of checks per username

This a motivating exercise for mutual exclusions.

Keep track (in memory) of how many times each username has been checked.

- What data structure seems appropriate?
- Create an additional `/frequency` route that returns a JSON representation of the data structure in question.

Discuss.


* TODO

map is not concurrency-safe
can't use sync/atomics because only applies to fixed-sized integers.



* What we haven't covered

We're nearing the end of the course.

You've learned a lot, but there is [[https://www.humancoders.com/formations/go-avance][more]]!

.image https://blog.golang.org/store/gophers.jpg 400 _


* Open discussion
