Introduction to Go
01 January 2021

Julien Cretel
jcretel-infosec@protonmail.com
https://jub0bs.com
@jub0bs

* Setup

- Go (>= 1.16)
- Visual Studio Code
- [[https://code.visualstudio.com/docs/languages/go][Go extension for Visual Studio Code]]
- Git


* About the course

- interaction
- regular breaks
- learn the fundamentals
- emphasis on practice over theory
- long-running project

: the source code of my solution will be available on GitHub



* Namecheck project

*Objectives*

- Write a small CLI tool to check the validity and status of a username on multiple social networks.
- Convert it into a HTTP server.
- A forcing function for learning Go: we'll introduce new concepts as needed.

*Business* *case*

- Choose a brand name consistent across multiple platforms.
- Username squatting ðŸ˜ˆ



* Before we get started: Hello World

.play -edit helloworld.go




* A few words about Go



* Go's mascot

\... [[https://blog.golang.org/gopher][is a gopher]].

.image https://blog.golang.org/gopher/gopher.png 400 _



* Go's logo

\... [[https://blog.golang.org/go-brand][is not the gopher!]]

.image https://blog.golang.org/go-brand/logos.jpg 400 _



* Genesis

Go was created in 2007 at Google by Robert Griesemer, Rob Pike, and Ken Thompson.

.image three_lads.jpeg



* Genesis

Robert, Rob, and Ken started working on Go (on 20% time) out of frustration with C++: language complexity, long build times, poor support for concurrency.

.image https://imgs.xkcd.com/comics/compiling.png



* History of the Go project

- started in 2007
- open-sourced in 2009
- Go 1.0 released in 2012
- ...
- Go 1.16 released in 2021.



* Go's object orientation

Go allows you to declare custom types (and methods on them), which promote _abstraction_.

Go has no concept of _inheritance_. Instead, it facilitates _composition_.

Go interfaces enable _polymorphism_ and structural subtyping.

Go packages enable _encapsulation_.



* Go's functional orientation

Functions are first-class citizens: they can

- take other functions as parameters, and
- return functions as results.

Go also supports

- anonymous functions (though no concise "lambda" notation), and
- lexical closures.



* Concurrency



* Concurrency

Concurrency is the art of composing a programme in terms of independently executing computations.

Go has native support (i.e. in the language and runtime) for concurrency.

Go's concurrency model is arguably one of the language's strengths, but can be difficult to learn and master.

: hence being relegated to the end of many learning resources



* Concurrency

Disclaimer: many cooking metaphors ahead!

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 400 _



* Concurrency is not parallelism

*Concurrency*

- the art of composing a programme in terms of independenly executing computations
- a quality of the programme's structure (happens at _write_ time)

*Parallelism*

- the act of executing code on multiple cores
- a quality of the programme's execution (happens at _run_ time)

Concurrency _enables_ parallelism. See also

- [[https://www.youtube.com/watch?v=oV9rvDllKEg][Rob Pike - Concurrency is not Parallelism (2012)]].
- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=3m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]



* Go's concurrency model

Largely inspired by [[https://dl.acm.org/doi/10.1145/359576.359585][Tony Hoare's  _Communicating_Sequential_Processes_ (1978)]]

Two fundamental mechanisms:

- goroutines: lightweight threads
- channels: typed pipes used to communicate and synchronize between goroutines

.image busy_gophers.jpeg 300 _



* Goroutines

A goroutine is a concurrent function execution.

It can be thought of as a very lightweight thread: it's common for programmes to have 1000s of goroutines, even on a single core.

The `main` function is itself a goroutine that is created when the programme starts.



* Goroutines execute in the same address space

For example, a goroutine can pass a pointer to another goroutine, and the latter can dereference that pointer without causing an access violation.

[[https://golang.org/doc/effective_go.html#goroutines][The onus is on you to be careful]] in order to avoid data races!

(A [[https://en.wikipedia.org/wiki/Race_condition#Data_race][data race]] occurs when multiple goroutines write to and read from the same memory location at the same time.)



* The Go scheduler

The _Go_scheduler_ is the part of the Go runtime responsible for "juggling" goroutines in order to maximise work.

No need to understand how the Go scheduler works, at this stage of your Go learning.

Just think of the Go scheduler and goroutines as a chef and his/her kitchen assistants.

.image https://homemaking.com/wp-content/uploads/2020/04/cooking.jpg 300 _



* The go keyword

The `go` keyword spawns a new goroutine: it causes the function call that follows it to get executed "in the background".

  go grindCoffeeBeans()
  go frothMilk()

`go` statements return _immediately_.

The result(s) of the function call to which the `go` keyword is applied are lost.

Launching an anonymous function as a goroutine is common:

  go func() {
    fmt.Println("Grinding coffee beans...")
  }()

: just don't forget to invoke it!
: terminology: spawning goroutine vs. spawned goroutine



* Goroutines vs. Unix processes

It's useful to compare goroutines to Unix processes...

The `go` keyword is reminiscent of the ampersand operator (`&`) in Unix shells.

  #!/usr/bin/env sh

  grindCoffeeBeans &
  frothMilk &

However, unlike a Unix process, a goroutine has no concept of an ID (see why [[https://talks.golang.org/2014/go4gophers.slide#38][here]]).

Therefore, a goroutine cannot readily be _killed_.



* The golden rule

Before spawning a new goroutine, you must understand exactly under what conditions it will terminate.

If you're careless and spawn goroutines willy-nilly, you expose yourself to correctness and performance bugs (_goroutine_leaks_).

.image this_is_fine.png 300 _



* Exercise: concurrent coffee making

Write two functions, `grindCoffeeBeans` and `frothMilk`, that

- take no parameters and return no results,
- simply write an informative message to stdout.

Call them concurrently in the `main` function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _

: Q: Which message will be printed first? We can't tell. Up to the scheduler.



* Exercise: concurrent coffee making (first attempt)

.play -edit goroutines_without_waitgroup.go /^//START/,/^//END/

Does the programme behave as you expected? Why or why not?



* main does not wait!

Nothing gets written to stdout because

- the two `go` statements _immediately_ transfer control back to `main`, and
- `main` terminates _before_ your two goroutines themselves terminate!

We need a way to tell `main` to "wait" until the two goroutines terminate.

Any ideas?



* Exercise: concurrent coffee making (with sleep)

Sleep a bit at the end?

.play -edit goroutines_with_sleep.go /^//START/,/^//END/

However, this solution is not entirely satisfactory. Why?

: inefficient at best, nondeterministic at worst



* Sleeping is not the answer

How long should the sleep be, exactly? Impossible to know in advance.

- Wait too little: `main` terminates too quickly for all the other goroutines to terminate.
- Wait too long: `main` ends up needlessly spinning and wasting time.

.image https://drek4537l1klr.cloudfront.net/youngman/Figures/f0255-01.jpg 200 _

Sleeping is simply not a reliable and efficient way of coordinating goroutines!

We need another mechanism...

: there are legitimate use cases for `time.Sleep` in a Go programme, but...



* Wait groups

The standard library's [[https://golang.org/pkg/sync/#WaitGroup][`sync` package]] provides a mechanism for _orchestrating_ goroutines: wait groups.

Wait groups are particularly useful when the number of goroutines to spawn is not known in advance.

: e.g. if you're spawning a goroutine for each line of a file that you're reading



* Declaring a wait group

The zero value is readily usable:

  wg := sync.WaitGroup{} // unnecessary

  var wg sync.WaitGroup  // better



* Operations on a wait group

A wait group is little more than a glorified counter with _concurrency-safe_ operations.

- `wg.Add(n)` increments the counter by n (>0).
- `wg.Done()` decrements the counter by 1. It's equivalent to `wg.Add(-1)`.
- `wg.Wait()` blocks until the counter goes back to 0.



* How to use a wait group

Call `wg.Add(1)` _just_before_ spawning a goroutine.

Call `wg.Done()` _at_the_very_end_ of each spawned goroutine (use `defer`!).

Call `wg.Wait()` in the spawning goroutine to wait for all spawned goroutines to terminate.



* Exercise: concurrent coffee making (using a wait group)

Use a wait group to make `main` wait until both `grindCoffeeBeans` and `frothMilk` have terminated before `main` itself can terminate.

Tip: you can apply the `go` keyword to an anonymous function.

.image https://i.pinimg.com/originals/41/8b/9c/418b9cb037389f7c5b6783ced8a7156b.jpg 300 _



* Exercise: concurrent coffee making (using a wait group)

(implementations of `grindCoffeeBeans` and `frothMilk` are as before)

.play -edit goroutines_with_waitgroup.go /^//START/,/^//END/

: don't forget the pair of parens at the end of each function literal!
: What happens if I remove a wg.Done()? deadlock
: What happens if I remove a wg.Add(1)? only one of the two goroutine will likely have time execute



* How not to misuse wait groups

Calls to `wg.Add` must take place in the spawning goroutine, _not_ within the spawned goroutine.

The call to `wg.Wait` must happen _after_ all calls to `wg.Add` (otherwise: data race).

If a function needs a wait group declared elsewhere, pass a pointer to it (`*sync.WaitGroup`) as an argument to the function.

.image https://blog.golang.org/gopher/plush.jpg 300 _

: if wg.Add concurrent with wg.Wait, data race: https://play.golang.org/p/PPlY-M7yfYh



* Closures running as goroutines: spot the bug

Can you spot the bug in the following programme?

.play -edit goroutine_func_quiz.go /^//START/,/^//END/

: ask them first how they expect the programme to behave



* Closures running as goroutines: explanation

There is a _data_race_: a variable is being read and updated by different goroutines at the same time!

More specifically, the goroutines spawned by `printTenIntsConcurrently` _capture_ and read loop variable `i` as it's being updated by the loop.

.play -edit goroutine_func_answer.go /^//START/,/^//END/

Consequently, the programme is underministic: the results are unpredictable.



* Detecting the data race

We've identified the data race by inspection, but some static- and dynamic-analysis tools can help.

*go*vet*

This subcommand analyzes the code and can detect issues that the compiler does not.

Try running `go` `vet` on the programme.

*race*detector*

The Go CLI provides a [[https://blog.golang.org/race-detector][race detector]], i.e. a tool that can detect data races during execution.

Try running the programme with the `-race` flag.

Caution: the race detector is [[https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb][not guaranteed to catch all data races]].



* Fixing the data race

Pass the value of the loop variable as an argument to the anonymous function.

That way, by virtue of Go's call-by-value evaluation strategy, the function only has access to a copy of the loop variable.

.play -edit goroutine_func_arg.go /^//START/,/^//END/



* Fixing the data race

An alternative solution consists in redeclaring the variable inside the loop.

.play -edit goroutine_func_redecl.go /^//START/,/^//END/

See also the [[https://golang.org/doc/faq#closures_and_goroutines][Golang FAQ about this]].



* Be careful when running closures as goroutines

When running a closure as a goroutine, it's very easy to inadvertently capture variables, which may cause data races.

Defining a dedicated named function can help:

.play -edit goroutine_func_standalone.go /^//START/,/^//END/



* Namecheck project: check concurrently

Rather than checking the username on each platform sequentially, do so concurrently.

Does the user experience improve?



* Namecheck project: aggregate the results (how?)

What if, instead of simply printing the results, we wanted to somehow aggregated them?

Remember: the result(s) of the function call to which the `go` keyword is applied are lost.

We need a way to communicate between goroutines...



* Channels



* Don't communicate by sharing memory; share memory by communicating.

Because goroutines all execute in the same address space, we need to be careful about data access from multiple goroutines.

We could use locks to synchronize goroutine access to the shared memory...

\... but Go encourages a different approach, in which shared values are passed around on _channels_.

See also

- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=2m42s][Rob Pike - Go proverbs (Gopherfest 2015)]]
- [[https://golang.org/doc/effective_go#sharing][Effective Go (Share by communicating)]]



* Channels are typed

Channels are typed conduits that allow goroutines to synchronize and exchange information.

The element type of a channel is arbitrary.

A channel whose element type is `T` has type `chan`T`.

  var ch chan string // channel of strings



* Popular naming choices for channels

"c" or "ch", on its own or as a suffix (with or without camelcase):

  var c chan int
  var ch chan string
  var errc chan error
  var taskCh chan Task

Plural of the channel's element type:

  var tasks chan Task



* Channels are first-class values

You can pass a channel to a function:

  func Aggregate(results chan Result) Result { /* ... */ }

You can return a channel from a function:

  func Generate(upTo int) chan int { /* ... */ }

You can store a channel in a struct type:

  type Request struct {
      fn func() int  // The operation to perform.
      c  chan bool    // The channel to return the result.
  }

Channels are comparable.




* Initializing a channel

Channels are reference types; their zero value is `nil`.

To initialize a channel, use built-in function `make` with two arguments:

- the first argument corresponds to the type of the channel;
- the second argument is an (optional) `int` corresponding to the channel's desired (non-negative) _capacity_.

  c1 := make(chan string) // equivalent to make(chan string, 0)
  c2 := make(chan string, c)

A channel's capacity cannot be changed after initialization.

A freshly initialized channel starts its life in an "open" state, but can later be _closed_.

: The specified capacity (if any) must be non-negative; otherwise, you'll get a compilation error or, worse, a panic.



* Channel capacity

A channel's capacity corresponds to the size of its _buffer_.

Choosing it wisely is important, as it usually affects the correctness and/or the performance of your programme.

Built-in function `cap` can be used to query a channel's capacity:

  c := make(chan string, 20)
  fmt.Println(cap(c)) // 20

Some terminology:

- A channel of zero capacity is called an _unbuffered_channel_.
- A channel of positive capacity is called a _buffered_channel_.

: The number of elements queued in a channel's buffer can also be queried via built-in function `len`, but is rarely useful. Why?
: if more than one goroutine interact with the channel, len(ch) is stale as soon as queried
: increasing buffer size may help reduce pressure on the Go scheduler



* A kitchen serving-hatch as a metaphor

Think of goroutines as cooks and waiters on either side of a serving hatch, which represents a channel.

The channel's capacity corresponds to the number of plates that can fit on the serving hatch's platform at any one time.

.image https://josephdmcnamee.files.wordpress.com/2012/01/serving-hatch1.jpg 350 _

: what does a channel of capacity 0 correspond to?
: the analogy is imperfect because channels are FIFO and waiters don't necessarily pick up plates in the order in which they arrived



* Operations on a channel

Channels support the following operations:

- _sending_ a value to a channel,
- _receiving_ a value from a channel,
- _closing_ a channel (that hasn't been closed yet).

You can also _range_ over a channel, which consists in continually receiving values from it until the channel gets closed.

All those operations are *concurrency-safe*.

: _Channel_communications_ is a general term for describing both channel sends and receives.
: we'll see why closing a channel is useful soon



* Sending to a channel

The syntax of a _channel_send_ consists in the channel in question, followed by a left-pointing arrow (`<-`), followed by the value to send.

  ch := make(chan string)
  // ...
  v := "superimportant message"
  ch <- v

The `gofmt` tool will adds a space on either side of the arrow; don't fight it.

A channel send is a statement, not an expression.



* Semantics of a channel send

.image send_semantics.svg 400 _

Note: buffered channels accept a limited number of values without a corresponding receive for those values.


* Receiving from a channel

The syntax of a _channel_receive_ consists in a left-pointing arrow (`<-`), followed by the channel in question.

  ch := make(chan string)
  // ...
  <-ch

The `gofmt` tool removes any whitespace between the arrow the channel; don't fight it.

A channel receive is an expression: you can store the received value in a variable, or pass it to a function.

  v := <-ch
  fmt.Println(<-ch)

The value received is only a copy of the value that was sent to the channel.



* Semantics of a channel receive

.image receive_semantics.svg 400 _

Note: the value received from a channel by a goroutine is only accessible to that goroutine; it is removed from the channel for all the other goroutines.



* Exercise

.play -edit deadlock_example.go /^//START/,/^//END/

This programme deadlocks. Can you guess why? How would you fix it?

Add sends and receives to fix ideas. Discuss.



* Receive ambiguity

As shown by the diagram on the previous slide, when a channel is closed and empty, receiving from that channel yields the zero value of the channel's element type...

.image https://blog.golang.org/gopher/plush.jpg 300 _

How can we tell whether the value we're receiving is from a closed channel or whether someone really sent a zero value of the element's type to the channel?



* Dispelling the ambiguity

There is a special form of channel receive that yields an additional boolean value (named "ok", by convention):

   v, ok := <-ch


The value of `ok` is

- `true` if the value received was delivered by a successful send operation to the channel, or
- `false` if it is a zero value generated because the channel is closed and empty.



* Closing a channel

A freshly initialized channel starts its life in an "open" state.

  ch := make(chan string) // ch is open (until closed) 

You can close a channel to indicate that no more values are to be added to it:

  close(ch)

Closing a channel is definitive; a closed channel cannot be "re-opened".



* Semantics of close

.image close_semantics.svg _ 800

Note:

- Closing the nil channel causes a panic.
- Closing an already closed channel causes a panic




* How is closing a channel useful?

*Terminating*a*range*operation*

If you range over a channel anywhere in your code, that range expression will block until you close the channel.

*Broadcasting*a*signal*
 
Because closing a channel unblocks all receives from that channel, it can be used to broadcast a signal to multiple goroutines! 

In fact, the [[https://golang.org/pkg/context/][`context` package]] is [[https://vimeo.com/115309491#t=10m][based on this idea]].



* Do not systematically close channels

Channels are not resources; closing a channel is not a way to reclaim or clean up resources (memory, etc.).

Channels will get garbage-collected like any other variable once they become unreachable.

You only need to close a channel if the semantics of your programme demand it.




* Closing a channel doesn't drain it

Think of a restaurant as a channel.

- Announcing the end of service doesn't mean pushing all the patrons out; they can finish their meal before leaving.
- Similarly, closing a channel doesn't amount to flushing it out; some goroutine(s) can still consume those elements.

.image https://rew-online.com/wp-content/uploads/2019/10/restaurantCLOSED.jpg 300 _








* Ranging over a channel

Ranging over a channel amounts to iteratively receiving from it:

  for v := range ch {
    // do something with v
  }

Note: only iteration variable is permitted.

The code above is an exact equivalent to the following:

  for {
    v, ok := <-ch
    if !ok {
      break
    }
    // do something with v
  }



* Ranging over a channel blocks until the channel is closed

Important: the `for` statement will block until the channel is closed!

.play -edit range_blocks_until_channel_closed.go /^//START/,/^//END/



* Reminder: channels are reference types

Operating on a copy `cb` of a channel `ca` affects the same underlying data structure as if you operated on channel `ca` directly.

.play -edit channels_are_references.go /^//START/,/^//END/

If that weren't the case, passing channels to functions wouldn't be very useful.


* Exercise: ping-pong game with cancelation (via a done channel) TODO

.play -edit ping_pong_done.go /^//START/,/^//END/



* Exercise: ping-pong game with cancelation with context TODO

.play -edit ping_pong_ctx.go /^//START/,/^//END/
